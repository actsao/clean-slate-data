{"version":3,"sources":["webpack:///./node_modules/data-forge/dist/esm/index.esm.js"],"names":["_extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__values","o","m","Symbol","iterator","i","call","next","length","value","done","__read","n","r","e","ar","push","error","__spread","arguments","concat","Direction","EmptyIterator","EmptyIterable","CountIterator","index","CountIterable","MultiIterator","iterators","e_1","_c","multiResult","_a","_b","result","e_1_1","return","MultiIterable","iterables","iterable","SelectIterator","selector","SelectIterable","SelectManyIterator","outputIterator","outputIterable","outputResult","SelectManyIterable","TakeIterator","childIterator","numElements","TakeIterable","childIterable","TakeWhileIterator","predicate","TakeWhileIterable","WhereIterator","WhereIterable","ConcatIterator","curIterator","moveToNextIterable","nextIterable","ConcatIterable","SeriesWindowIterator","period","whichIndex","curWindow","curPos","window","Series","pairs","WhichIndex","Start","getIndex","first","last","SeriesWindowIterable","ArrayIterator","arr","ReverseIterable","working","reverse","ZipIterator","zipper","map","results","results_1","results_1_1","zippedValues","zipperInput","ZipIterable","DistinctIterator","valuesAlreadySeen","Set","potentialOutput","has","add","DistinctIterable","SeriesRollingWindowIterator","shift","SeriesRollingWindowIterable","SeriesVariableWindowIterator","comparer","nextValue","prevValue","SeriesVariableWindowIterable","SortOperation","values","sortSpec","keys","genKeys","compare","indexA","indexB","keyA","keyB","comparison","direction","Descending","OrderedIterable","indexes","e_2_1","e_2","sortOperations","_d","_e","e_3_1","e_3","_f","sort","sortOperations_1","sortOperations_1_1","e_4_1","e_4","e_5","_g","sortedValues","indexes_1","indexes_1_1","index_1","e_5_1","ExtractElementIterator","extractIndex","ExtractElementIterable","arrayIterable","arrayIterator","SkipIterator","numValues","SkipIterable","SkipWhileIterator","doneSkipping","SkipWhileIterable","DataFrameWindowIterator","columnNames","DataFrame","DataFrameWindowIterable","CsvRowsIterator","rowsIterable","from","rowsIterator","row","cellIndex","CsvRowsIterable","rows","DataFrameRollingWindowIterator","DataFrameRollingWindowIterable","DataFrameVariableWindowIterator","DataFrameVariableWindowIterable","RepeatIterator","count","repetition","RepeatIterable","TileIterator","firstIteration","TileIterable","RavelIterator","iteratorIndex","RavelIterable","ColumnNamesIterator","considerAllRows","columnNamesIterator","combinedFields","firstResult","ColumnNamesIterable","makeDistinct","items","set","output","items_1","items_1_1","item","key","toMap","keySelector","valueSelector","items_2","items_2_1","determineType","undefined","isNumber","isString","Date","v","isBoolean","isObject","isDate","isFunction","toString","isArray","isUndefined","config","configFn","content","indexedContent","initFromArray","initFromConfig","initEmpty","defaultCountIterable","isBaked","defaultEmptyIterable","initColumnNames","inputColumnNames","isCaseSensitive","outputColumnNames","columnNamesMap","inputColumnNames_1","inputColumnNames_1_1","columnName","columnNameLwr","toLowerCase","columnNoMap","inputColumnNames_2","inputColumnNames_2_1","curColumnNo","checkIterable","input","fieldName","Error","columns","columnsConfig","iterableColumnsConfig","column","name","series","columnIterables","columnNames_1","columnNames_1_1","caseSensitive","c","baked","lazyInit","getContent","getRowByIndex","Map","pair","get","getColumnNames","getColumns","_this","getSeries","skipWhile","type","any","cast","Index","setIndex","withIndex","newIndex","deflate","resetIndex","hasSeries","expectSeries","withSeries","columnNameOrSpec","columnSpec","workingDataFrame","columnNames_2","columnNames_2_1","columnName_1","e_6_1","e_6","none","inflate","seriesValueMap","items_3","items_3_1","toMap2","toPairs","modified","assign","merge","dataFrames","rowMap","dataFrames_1","dataFrames_1_1","dataFrame","clone","e_7_1","e_7","e_8_1","e_8","newColumnNames","reduce","prev","mergedPairs","a","otherDataFrames","_i","ensureSeries","columnNames_3","columnNames_3_1","columnName_2","e_9_1","e_9","subset","e_10","columnNames_4","columnNames_4_1","e_10_1","e_11","columnNames_5","columnNames_5_1","e_11_1","dropSeries","columnOrColumns","e_12","indexOf","e_12_1","e_13","columnOrColumns_1","columnOrColumns_1_1","e_13_1","e_14","columnOrColumns_2","columnOrColumns_2_1","e_14_1","reorderSeries","e_15","columnNames_6","columnNames_6_1","e_15_1","e_16","columnNames_7","columnNames_7_1","e_16_1","e_17","columnNames_8","columnNames_8_1","e_17_1","bringToFront","e_18","columnOrColumns_3","columnOrColumns_3_1","e_18_1","existingColumns","columnsToMove","columnOrColumns_4","columnOrColumns_4_1","columnToMove","e_19_1","e_19","e_20","untouchedColumnNames","existingColumns_1","existingColumns_1_1","existingColumnName","e_20_1","bringToBack","e_21","columnOrColumns_5","columnOrColumns_5_1","e_21_1","columnOrColumns_6","columnOrColumns_6_1","e_22_1","e_22","e_23","existingColumns_2","existingColumns_2_1","e_23_1","renameSeries","e_24","existingColumnsToRename","existingColumnsToRename_1","existingColumnsToRename_1_1","e_24_1","e_25","renamedColumns","e_25_1","remapValue","e_26","existingColumnsToRename_2","existingColumnsToRename_2_1","existingColumName","e_26_1","toArray","e_27","e_27_1","e_28","e_28_1","toObject","toRows","e_29","columnIndex","e_29_1","select","selectMany","e_30","outputPairs","transformed","e_30_1","transformSeries","columnSelectors","e_31","e_31_1","generateSeries","generator","columnTransformSpec","newColumnNames_2","newColumnNames_2_1","newColumnName","e_33_1","e_33","e_32","newColumns","bake","newColumnNames_1","newColumnNames_1_1","e_32_1","inflateSeries","zip","row1","row2","rollingWindow","variableWindow","sequentialDistinct","aggregate","seedOrSelector","skip","accum","e_34_1","e_34","columnAggregateSpec_1","columnSelector","skipUntil","take","numRows","takeWhile","takeUntil","e_35","total","e_35_1","e_36_1","e_36","e_37","lastValue","e_37_1","at","head","toTake","Math","abs","tail","toSkip","where","forEach","callback","e_38","e_38_1","all","e_39","e_39_1","e_40","e_40_1","e_41","e_41_1","startAt","indexValue","lessThan","getLessThan","endAt","lessThanOrEqualTo","getLessThanOrEqualTo","before","after","between","startIndexValue","endIndexValue","e_42","header","table","cell","newRow","e_42_1","parseInts","columnNameOrNames","columnNameOrNames_1","columnNameOrNames_1_1","e_43_1","e_43","parseFloats","columnNameOrNames_2","columnNameOrNames_2_1","e_44_1","e_44","parseDates","formatString","columnNameOrNames_3","columnNameOrNames_3_1","e_45_1","e_45","toStrings","e_46_1","e_46","e_47_1","e_47","columnNames_9","columnNames_9_1","columnFormatString","e_48_1","e_48","singleColumnName","truncateStrings","maxLength","e_49","substring","e_49_1","round","numDecimalPlaces","e_50","parseFloat","toFixed","e_50_1","distinct","groupBy","e_51","groups","groupMap","valueIndex","groupKey","existingGroup","newGroup","e_51_1","group","groupSequentialBy","dataframes","e_53","e_52","contents","dataframe","contents_1","contents_1_1","e_52_1","e_53_1","e_55","e_54","concatInput","dataframes_1","dataframes_1_1","input_1","input_1_1","subInput","e_54_1","e_55_1","firstSeries","upcast","s","args","slice","apply","orderBy","OrderedDataFrame","Ascending","parent","orderByDescending","union","other","intersection","inner","outerSelector","innerSelector","outerValue","outerKey","innerValue","except","join","outerKeySelector","innerKeySelector","resultSelector","outer","e_57","e_56","innerMap","outer_1","outer_1_1","innerGroup","innerGroup_1","innerGroup_1_1","e_56_1","e_57_1","joinOuter","outerResult","innerResult","intersectionResults","joinOuterLeft","joinOuterRight","summarize","spec","sum","average","e_58_1","e_58","inputColumnName","inputSpec","e_59_1","e_59","e_61","_h","e_60","outputFieldsMap","valueColumnName","inputColumnNames_3","inputColumnNames_3_1","outputFieldNames","outputFieldNames_1","outputFieldNames_1_1","outputFieldName","aggregatorFn","e_60_1","e_61_1","pivot","valueColumnNameOrSpec","aggregator","aggSpec","columnNames_10","columnNames_10_1","e_62_1","e_62","columnAggSpec","e_63_1","e_63","aggColumnName","outputSpec","firstColumnName","src","_loop_1","columnNameIndex","nextColumnName","parentGroup","subGroup","valueColumnNames","outputColumnsMap","ordered","e_65","_loop_2","e_64","outputColumnNames_1","outputColumnNames_1_1","outputColumName","srcRow","e_64_1","valueColumnNames_1","valueColumnNames_1_1","e_65_1","_loop_3","thenBy","melt","idColumnOrColumns","valueColumnOrColumns","idColumnNames","idColumnNames_1","idColumnNames_1_1","e_66_1","e_66","valueColumnNames_2","valueColumnNames_2_1","e_67_1","e_67","K","N","mdata","original","idColumnNames_2","idColumnNames_2_1","col","idData","columnData_1","columnSeries_1","e_68_1","e_68","seriesArray","e_69_1","e_69","columnData","columnSeries","valueColumnData","valueColumnSeries","insertPair","appendPair","fillGaps","pairA","pairB","generatedRows","defaultIfEmpty","defaultDataFrame","detectTypes","typeFrequency","Column","detectValues","valueFrequency","toJSON","JSON","stringify","toJSON5","toCSV","options","unparse","toHTML","columNames","columName","serialize","indexValues","serializedColumns","indexType","getType","toISOString","e_71","e_70","cloned","columns_1","columns_1_1","rows_1","rows_1_1","e_70_1","e_71_1","columnOrder","deserialize","e_73","e_72","rows_2","rows_2_1","toDate","e_72_1","e_73_1","getTypeCode","_super","e_74","valueSortSpecs","pairSortSpecs","sortLevel","parents","parents_1","parents_1_1","parentConfig","makeSortSpec","makePairsSelector","e_74_1","thenByDescending","extend","numSeries","seriesIndex","series_1","series_1_1","workingSeries","End","amountRange","max","min","proportionRange","percentRange","amountChange","proportionChange","percentChange","proportionRank","latestValue","prevMomentum","percentRank","proportion","cumsum","rowIndex","parseInt","parseDate","format","median","floor","std","numberSeries","valueCount","mean","sumOfSquaredDiffs","diffFromMean","sqrt","invert","counter","range","replicate","series_2","series_2_1","OrderedSeries","defaultSequence","totalValues","typeFrequencies","valueType","accumulated","typeInfo","valueFrequencies","valueInfo","bucket","numBuckets","width","bucketMin","Value","Bucket","Min","Mid","Max","_type","d1","d2","isBefore","v1","v2","getGreaterThan","isAfter","createCommonjsModule","fn","module","exports","isBuffer","arg","Buffer","inherits_browser","ctor","superCtor","super_","enumerable","writable","configurable","TempCtor","inherits","util$1","util","getOwnPropertyDescriptors","obj","descriptors","getOwnPropertyDescriptor","formatRegExp","f","objects","inspect","len","str","String","replace","x","Number","_","isNull","deprecate","msg","process","noDeprecation","warned","throwDeprecation","traceDeprecation","console","trace","debugEnviron","debugs","opts","ctx","seen","stylize","stylizeNoColor","depth","colors","showHidden","_extend","customInspect","stylizeWithColor","formatValue","styleType","style","styles","recurseTimes","ret","primitive","simple","formatPrimitive","visibleKeys","array","hash","val","idx","arrayToHash","getOwnPropertyNames","isError","formatError","isRegExp","RegExp","base","braces","toUTCString","l","formatProperty","match","formatArray","pop","cur","reduceToSingleString","desc","split","line","substr","re","objectToString","pad","debuglog","NODE_DEBUG","toUpperCase","test","pid","isNullOrUndefined","isSymbol","isPrimitive","months","timestamp","time","getHours","getMinutes","getSeconds","getDate","getMonth","prop","log","origin","kCustomPromisifiedSymbol","callbackifyOnRejected","reason","cb","newReason","promisify","TypeError","defineProperty","promiseResolve","promiseReject","promise","Promise","resolve","reject","err","getPrototypeOf","defineProperties","custom","callbackify","callbackified","maybeCb","self","then","nextTick","rej","util_17","fromCSV","csvTextString","skipEmptyLines","parse","data","trim","start"],"mappings":"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","file":"72d4aed8-bbdbd4ac19c2246f1235.js","sourcesContent":["import \"core-js/modules/es.array.reduce\";\nimport Table from 'easy-table';\nimport moment from 'dayjs/esm';\nimport t from 'typy';\nimport JSON5 from 'json5';\nimport PapaParse from 'papaparse';\nimport customParseFormat from 'dayjs/esm/plugin/customParseFormat';\nimport numeral from 'numeral';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction __values(o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n} //\n// An iterator that returns no values.\n//\n\n\nvar EmptyIterator =\n/** @class */\nfunction () {\n  function EmptyIterator() {}\n\n  EmptyIterator.prototype.next = function () {\n    return {\n      done: true,\n      value: null\n    };\n  };\n\n  return EmptyIterator;\n}(); //\n\n\nvar EmptyIterable =\n/** @class */\nfunction () {\n  function EmptyIterable() {}\n\n  EmptyIterable.prototype[Symbol.iterator] = function () {\n    return new EmptyIterator();\n  };\n\n  return EmptyIterable;\n}(); //\n// An iterator that simply counts up from zero.\n// This creates the default index in Data-Forge.\n//\n\n\nvar CountIterator =\n/** @class */\nfunction () {\n  function CountIterator() {\n    this.index = 0;\n  }\n\n  CountIterator.prototype.next = function () {\n    return {\n      done: false,\n      value: this.index++\n    };\n  };\n\n  return CountIterator;\n}(); //\n\n\nvar CountIterable =\n/** @class */\nfunction () {\n  function CountIterable() {}\n\n  CountIterable.prototype[Symbol.iterator] = function () {\n    return new CountIterator();\n  };\n\n  return CountIterable;\n}(); //\n\n\nvar MultiIterator =\n/** @class */\nfunction () {\n  function MultiIterator(iterators) {\n    this.iterators = iterators;\n  }\n\n  MultiIterator.prototype.next = function () {\n    if (this.iterators.length === 0) {\n      return {\n        done: true,\n        value: []\n      };\n    }\n\n    var multiResult = [];\n\n    try {\n      for (var _a = __values(this.iterators), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var iterator = _b.value;\n        var result = iterator.next();\n\n        if (result.done) {\n          return {\n            done: true,\n            value: []\n          };\n        }\n\n        multiResult.push(result.value);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return {\n      done: false,\n      value: multiResult\n    };\n\n    var e_1, _c;\n  };\n\n  return MultiIterator;\n}(); //\n\n\nvar MultiIterable =\n/** @class */\nfunction () {\n  function MultiIterable(iterables) {\n    this.iterables = iterables;\n  }\n\n  MultiIterable.prototype[Symbol.iterator] = function () {\n    var iterators = [];\n\n    try {\n      for (var _a = __values(this.iterables), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var iterable = _b.value;\n        iterators.push(iterable[Symbol.iterator]());\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return new MultiIterator(iterators);\n\n    var e_1, _c;\n  };\n\n  return MultiIterable;\n}(); //\n// An iterator that applies a selector function to each item.\n//\n\n\nvar SelectIterator =\n/** @class */\nfunction () {\n  function SelectIterator(iterator, selector) {\n    this.index = 0;\n    this.iterator = iterator;\n    this.selector = selector;\n  }\n\n  SelectIterator.prototype.next = function () {\n    var result = this.iterator.next();\n\n    if (result.done) {\n      // https://github.com/Microsoft/TypeScript/issues/8938\n      return {\n        done: true\n      }; // <= explicit cast here!;\n    }\n\n    return {\n      done: false,\n      value: this.selector(result.value, this.index++)\n    };\n  };\n\n  return SelectIterator;\n}(); //\n\n\nvar SelectIterable =\n/** @class */\nfunction () {\n  function SelectIterable(iterable, selector) {\n    this.iterable = iterable;\n    this.selector = selector;\n  }\n\n  SelectIterable.prototype[Symbol.iterator] = function () {\n    var iterator = this.iterable[Symbol.iterator]();\n    return new SelectIterator(iterator, this.selector);\n  };\n\n  return SelectIterable;\n}(); //\n// An iterator that applies a selector function to each item.\n//\n\n\nvar SelectManyIterator =\n/** @class */\nfunction () {\n  function SelectManyIterator(iterator, selector) {\n    this.index = 0;\n    this.iterator = iterator;\n    this.selector = selector;\n    this.outputIterator = null;\n  }\n\n  SelectManyIterator.prototype.next = function () {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (this.outputIterator === null) {\n        var result = this.iterator.next();\n\n        if (result.done) {\n          // https://github.com/Microsoft/TypeScript/issues/8938\n          return {\n            done: true\n          }; // <= explicit cast here!;\n        }\n\n        var outputIterable = this.selector(result.value, this.index++);\n        this.outputIterator = outputIterable[Symbol.iterator]();\n      }\n\n      var outputResult = this.outputIterator.next();\n\n      if (outputResult.done) {\n        this.outputIterator = null;\n        continue;\n      } else {\n        return outputResult;\n      }\n    }\n  };\n\n  return SelectManyIterator;\n}(); //\n\n\nvar SelectManyIterable =\n/** @class */\nfunction () {\n  function SelectManyIterable(iterable, selector) {\n    this.iterable = iterable;\n    this.selector = selector;\n  }\n\n  SelectManyIterable.prototype[Symbol.iterator] = function () {\n    var iterator = this.iterable[Symbol.iterator]();\n    return new SelectManyIterator(iterator, this.selector);\n  };\n\n  return SelectManyIterable;\n}(); //\n// An iterator that a sequence of elements while a predicate function returns true.\n//\n\n\nvar TakeIterator =\n/** @class */\nfunction () {\n  function TakeIterator(childIterator, numElements) {\n    this.childIterator = childIterator;\n    this.numElements = numElements;\n  }\n\n  TakeIterator.prototype.next = function () {\n    if (this.numElements <= 0) {\n      // https://github.com/Microsoft/TypeScript/issues/8938\n      return {\n        done: true\n      }; // <= explicit cast here!;\n    }\n\n    --this.numElements;\n    return this.childIterator.next();\n  };\n\n  return TakeIterator;\n}(); //\n\n\nvar TakeIterable =\n/** @class */\nfunction () {\n  function TakeIterable(childIterable, numElements) {\n    this.childIterable = childIterable;\n    this.numElements = numElements;\n  }\n\n  TakeIterable.prototype[Symbol.iterator] = function () {\n    var childIterator = this.childIterable[Symbol.iterator]();\n    return new TakeIterator(childIterator, this.numElements);\n  };\n\n  return TakeIterable;\n}(); //\n// An iterator that takes a sequence of elements while a predicate function returns true.\n//\n\n\nvar TakeWhileIterator =\n/** @class */\nfunction () {\n  function TakeWhileIterator(childIterator, predicate) {\n    this.done = false;\n    this.childIterator = childIterator;\n    this.predicate = predicate;\n  }\n\n  TakeWhileIterator.prototype.next = function () {\n    if (!this.done) {\n      var result = this.childIterator.next();\n\n      if (result.done) {\n        this.done = true;\n      } else if (this.predicate(result.value)) {\n        return result;\n      } else {\n        this.done = true;\n      }\n    } // https://github.com/Microsoft/TypeScript/issues/8938\n\n\n    return {\n      done: true\n    }; // <= explicit cast here!;\n  };\n\n  return TakeWhileIterator;\n}(); //\n\n\nvar TakeWhileIterable =\n/** @class */\nfunction () {\n  function TakeWhileIterable(childIterable, predicate) {\n    this.childIterable = childIterable;\n    this.predicate = predicate;\n  }\n\n  TakeWhileIterable.prototype[Symbol.iterator] = function () {\n    var childIterator = this.childIterable[Symbol.iterator]();\n    return new TakeWhileIterator(childIterator, this.predicate);\n  };\n\n  return TakeWhileIterable;\n}(); //\n// An iterator that takes elements from a child iterator based on a predicate function.\n//\n\n\nvar WhereIterator =\n/** @class */\nfunction () {\n  function WhereIterator(childIterator, predicate) {\n    this.childIterator = childIterator;\n    this.predicate = predicate;\n  }\n\n  WhereIterator.prototype.next = function () {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      var result = this.childIterator.next();\n\n      if (result.done) {\n        return result;\n      }\n\n      if (this.predicate(result.value)) {\n        // It matches the predicate.\n        return result;\n      }\n    }\n  };\n\n  return WhereIterator;\n}(); //\n\n\nvar WhereIterable =\n/** @class */\nfunction () {\n  function WhereIterable(childIterable, predicate) {\n    this.childIterable = childIterable;\n    this.predicate = predicate;\n  }\n\n  WhereIterable.prototype[Symbol.iterator] = function () {\n    var childIterator = this.childIterable[Symbol.iterator]();\n    return new WhereIterator(childIterator, this.predicate);\n  };\n\n  return WhereIterable;\n}(); //\n// An iterator that concatenates multiple iterables.\n//\n\n\nvar ConcatIterator =\n/** @class */\nfunction () {\n  function ConcatIterator(iterables) {\n    this.curIterator = null;\n    this.iterables = iterables;\n    this.iterator = iterables[Symbol.iterator]();\n    this.moveToNextIterable();\n  } //\n  // Move onto the next iterable.\n  //\n\n\n  ConcatIterator.prototype.moveToNextIterable = function () {\n    var nextIterable = this.iterator.next();\n\n    if (nextIterable.done) {\n      this.curIterator = null;\n    } else {\n      this.curIterator = nextIterable.value[Symbol.iterator]();\n    }\n  };\n\n  ConcatIterator.prototype.next = function () {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (this.curIterator == null) {\n        // Finished iterating all sub-iterators.\n        // https://github.com/Microsoft/TypeScript/issues/8938\n        return {\n          done: true\n        }; // <= explicit cast here!;\n      }\n\n      var result = this.curIterator.next();\n\n      if (!result.done) {\n        return result; // Found a valid result from the current iterable.    \n      } // Find the next non empty iterable.\n\n\n      this.moveToNextIterable();\n    }\n  };\n\n  return ConcatIterator;\n}(); //\n\n\nvar ConcatIterable =\n/** @class */\nfunction () {\n  function ConcatIterable(iterables) {\n    this.iterables = iterables;\n  }\n\n  ConcatIterable.prototype[Symbol.iterator] = function () {\n    return new ConcatIterator(this.iterables);\n  };\n\n  return ConcatIterable;\n}(); //\n\n\nvar SeriesWindowIterator =\n/** @class */\nfunction () {\n  function SeriesWindowIterator(iterable, period, whichIndex) {\n    this.iterable = iterable;\n    this.period = period;\n    this.whichIndex = whichIndex;\n  }\n\n  SeriesWindowIterator.prototype.next = function () {\n    if (!this.iterator) {\n      this.iterator = this.iterable[Symbol.iterator]();\n    }\n\n    var curWindow = [];\n\n    for (var i = 0; i < this.period; ++i) {\n      var curPos = this.iterator.next();\n\n      if (curPos.done) {\n        // Underlying iterator is finished.\n        break;\n      }\n\n      curWindow.push(curPos.value);\n    }\n\n    if (curWindow.length === 0) {\n      // Underlying iterator doesn't have required number of elements.\n      return {\n        done: true\n      };\n    }\n\n    var window = new Series({\n      pairs: curWindow\n    });\n    return {\n      //TODO: The way the index is figured out could have much better performance.\n      value: [this.whichIndex === WhichIndex.Start ? window.getIndex().first() : window.getIndex().last(), window],\n      done: false\n    };\n  };\n\n  return SeriesWindowIterator;\n}(); //\n\n\nvar SeriesWindowIterable =\n/** @class */\nfunction () {\n  function SeriesWindowIterable(iterable, period, whichIndex) {\n    this.iterable = iterable;\n    this.period = period;\n    this.whichIndex = whichIndex;\n  }\n\n  SeriesWindowIterable.prototype[Symbol.iterator] = function () {\n    return new SeriesWindowIterator(this.iterable, this.period, this.whichIndex);\n  };\n\n  return SeriesWindowIterable;\n}(); //\n// An iterator that iterates the elements of an array.\n//\n\n\nvar ArrayIterator =\n/** @class */\nfunction () {\n  function ArrayIterator(arr) {\n    this.index = 0;\n    this.arr = arr;\n  }\n\n  ArrayIterator.prototype.next = function () {\n    if (this.index < this.arr.length) {\n      return {\n        done: false,\n        value: this.arr[this.index++]\n      };\n    } else {\n      // https://github.com/Microsoft/TypeScript/issues/8938\n      return {\n        done: true\n      }; // <= explicit cast here!;\n    }\n  };\n\n  return ArrayIterator;\n}(); //\n\n\nvar ReverseIterable =\n/** @class */\nfunction () {\n  function ReverseIterable(iterable) {\n    this.iterable = iterable;\n  }\n\n  ReverseIterable.prototype[Symbol.iterator] = function () {\n    var working = [];\n\n    try {\n      for (var _a = __values(this.iterable), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        working.push(value);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    working.reverse();\n    return new ArrayIterator(working);\n\n    var e_1, _c;\n  };\n\n  return ReverseIterable;\n}();\n\nvar ZipIterator =\n/** @class */\nfunction () {\n  function ZipIterator(iterables, zipper) {\n    this.iterators = iterables.map(function (iterable) {\n      return iterable[Symbol.iterator]();\n    });\n    this.zipper = zipper;\n  }\n\n  ZipIterator.prototype.next = function () {\n    var results = this.iterators.map(function (iterator) {\n      return iterator.next();\n    });\n\n    try {\n      for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {\n        var result = results_1_1.value;\n\n        if (result.done) {\n          // If any are done we are all done.\n          // https://github.com/Microsoft/TypeScript/issues/8938\n          return {\n            done: true\n          }; // <= explicit cast here!;                \n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var zippedValues = results.map(function (result) {\n      return result.value;\n    });\n    var zipperInput = new Series(zippedValues);\n    return {\n      done: false,\n      value: this.zipper(zipperInput)\n    };\n\n    var e_1, _a;\n  };\n\n  return ZipIterator;\n}(); //\n\n\nvar ZipIterable =\n/** @class */\nfunction () {\n  function ZipIterable(iterables, zipper) {\n    this.iterables = iterables;\n    this.zipper = zipper;\n  }\n\n  ZipIterable.prototype[Symbol.iterator] = function () {\n    return new ZipIterator(this.iterables, this.zipper);\n  };\n\n  return ZipIterable;\n}(); //\n// An iterator that iterates the only distinct elements of another iterable.\n//\n\n\nvar DistinctIterator =\n/** @class */\nfunction () {\n  function DistinctIterator(iterable, selector) {\n    this.valuesAlreadySeen = new Set();\n    this.iterator = iterable[Symbol.iterator]();\n    this.selector = selector;\n  }\n\n  DistinctIterator.prototype.next = function () {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      var result = this.iterator.next();\n\n      if (result.done) {\n        return {\n          done: true\n        };\n      }\n\n      var potentialOutput = void 0;\n\n      if (this.selector) {\n        potentialOutput = this.selector(result.value);\n      } else {\n        potentialOutput = result.value;\n      }\n\n      if (this.valuesAlreadySeen.has(potentialOutput)) {\n        // Already seen this value.\n        // Skip it and continue to next item.\n        continue;\n      }\n\n      this.valuesAlreadySeen.add(potentialOutput);\n      return {\n        done: false,\n        value: result.value\n      };\n    }\n  };\n\n  return DistinctIterator;\n}(); //\n\n\nvar DistinctIterable =\n/** @class */\nfunction () {\n  function DistinctIterable(iterable, selector) {\n    this.iterable = iterable;\n    this.selector = selector;\n  }\n\n  DistinctIterable.prototype[Symbol.iterator] = function () {\n    return new DistinctIterator(this.iterable, this.selector);\n  };\n\n  return DistinctIterable;\n}(); //\n\n\nvar SeriesRollingWindowIterator =\n/** @class */\nfunction () {\n  function SeriesRollingWindowIterator(iterable, period, whichIndex) {\n    this.iterable = iterable;\n    this.period = period;\n    this.whichIndex = whichIndex;\n  }\n\n  SeriesRollingWindowIterator.prototype.next = function () {\n    if (!this.curWindow) {\n      this.curWindow = [];\n      this.iterator = this.iterable[Symbol.iterator]();\n\n      for (var i = 0; i < this.period; ++i) {\n        var curPos = this.iterator.next();\n\n        if (curPos.done) {\n          // Underlying iterator doesn't have required number of elements.\n          return {\n            done: true\n          };\n        }\n\n        this.curWindow.push(curPos.value);\n      }\n    } else {\n      this.curWindow.shift(); // Remove first item from window.\n\n      var curPos = this.iterator.next();\n\n      if (curPos.done) {\n        // Underlying iterator doesn't have enough elements left.\n        return {\n          done: true\n        };\n      }\n\n      this.curWindow.push(curPos.value); // Add next item to window.\n    }\n\n    var window = new Series({\n      pairs: this.curWindow\n    });\n    return {\n      //TODO: The way the index is figured out could have much better performance.\n      value: [this.whichIndex === WhichIndex.Start ? window.getIndex().first() : window.getIndex().last(), window],\n      done: false\n    };\n  };\n\n  return SeriesRollingWindowIterator;\n}(); //\n\n\nvar SeriesRollingWindowIterable =\n/** @class */\nfunction () {\n  function SeriesRollingWindowIterable(iterable, period, whichIndex) {\n    this.iterable = iterable;\n    this.period = period;\n    this.whichIndex = whichIndex;\n  }\n\n  SeriesRollingWindowIterable.prototype[Symbol.iterator] = function () {\n    return new SeriesRollingWindowIterator(this.iterable, this.period, this.whichIndex);\n  };\n\n  return SeriesRollingWindowIterable;\n}(); //\n\n\nvar SeriesVariableWindowIterator =\n/** @class */\nfunction () {\n  function SeriesVariableWindowIterator(iterable, comparer) {\n    this.iterator = iterable[Symbol.iterator]();\n    this.nextValue = this.iterator.next();\n    this.comparer = comparer;\n  }\n\n  SeriesVariableWindowIterator.prototype.next = function () {\n    if (this.nextValue.done) {\n      // Nothing more to read.\n      // https://github.com/Microsoft/TypeScript/issues/8938\n      return {\n        done: true\n      }; // <= explicit cast here!;\n    }\n\n    var pairs = [this.nextValue.value];\n    var prevValue = this.nextValue.value; // Pull values until there is one that doesn't compare.\n    // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      this.nextValue = this.iterator.next();\n\n      if (this.nextValue.done) {\n        break; // No more values.\n      }\n\n      if (!this.comparer(prevValue[1], this.nextValue.value[1])) {\n        prevValue = this.nextValue.value;\n        break; // Doesn't compare. Start a new window.\n      }\n\n      pairs.push(this.nextValue.value);\n      prevValue = this.nextValue.value;\n    }\n\n    var window = new Series({\n      pairs: pairs\n    });\n    return {\n      value: window,\n      done: false\n    };\n  };\n\n  return SeriesVariableWindowIterator;\n}(); //\n\n\nvar SeriesVariableWindowIterable =\n/** @class */\nfunction () {\n  function SeriesVariableWindowIterable(iterable, comparer) {\n    this.iterable = iterable;\n    this.comparer = comparer;\n  }\n\n  SeriesVariableWindowIterable.prototype[Symbol.iterator] = function () {\n    return new SeriesVariableWindowIterator(this.iterable, this.comparer);\n  };\n\n  return SeriesVariableWindowIterable;\n}(); //\n\n\nvar Direction;\n\n(function (Direction) {\n  Direction[Direction[\"Ascending\"] = 0] = \"Ascending\";\n  Direction[Direction[\"Descending\"] = 1] = \"Descending\";\n})(Direction || (Direction = {}));\n\nvar SortOperation =\n/** @class */\nfunction () {\n  function SortOperation(values, sortSpec) {\n    this.values = values;\n    this.sortSpec = sortSpec;\n    this.keys = [];\n  }\n\n  SortOperation.prototype.genKeys = function () {\n    if (this.keys.length > 0) {\n      // Already cached.\n      return;\n    }\n\n    var index = 0;\n\n    try {\n      for (var _a = __values(this.values), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        this.keys.push(this.sortSpec.selector(value, index));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var e_1, _c;\n  };\n\n  SortOperation.prototype.compare = function (indexA, indexB) {\n    this.genKeys();\n    var keyA = this.keys[indexA];\n    var keyB = this.keys[indexB];\n    var comparison = -1;\n\n    if (keyA === keyB) {\n      comparison = 0;\n    } else if (keyA > keyB) {\n      comparison = 1;\n    }\n\n    return this.sortSpec.direction === Direction.Descending ? -comparison : comparison;\n  };\n\n  return SortOperation;\n}();\n\nvar OrderedIterable =\n/** @class */\nfunction () {\n  function OrderedIterable(iterable, sortSpec) {\n    this.iterable = iterable;\n    this.sortSpec = sortSpec;\n  }\n\n  OrderedIterable.prototype[Symbol.iterator] = function () {\n    var indexes = [];\n    var values = [];\n    var index = 0;\n\n    try {\n      for (var _a = __values(this.iterable), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        indexes.push(index);\n        values.push(value);\n        ++index;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    var sortOperations = [];\n\n    try {\n      for (var _d = __values(this.sortSpec), _e = _d.next(); !_e.done; _e = _d.next()) {\n        var sortSpec = _e.value;\n        sortOperations.push(new SortOperation(values, sortSpec));\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    sortOperations[0].genKeys();\n    indexes.sort(function (indexA, indexB) {\n      try {\n        for (var sortOperations_1 = __values(sortOperations), sortOperations_1_1 = sortOperations_1.next(); !sortOperations_1_1.done; sortOperations_1_1 = sortOperations_1.next()) {\n          var sortOperation = sortOperations_1_1.value;\n          var comparison = sortOperation.compare(indexA, indexB);\n\n          if (comparison !== 0) {\n            return comparison;\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (sortOperations_1_1 && !sortOperations_1_1.done && (_a = sortOperations_1.return)) _a.call(sortOperations_1);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      return 0;\n\n      var e_4, _a;\n    });\n    var sortedValues = [];\n\n    try {\n      for (var indexes_1 = __values(indexes), indexes_1_1 = indexes_1.next(); !indexes_1_1.done; indexes_1_1 = indexes_1.next()) {\n        var index_1 = indexes_1_1.value;\n        sortedValues.push(values[index_1]);\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (indexes_1_1 && !indexes_1_1.done && (_g = indexes_1.return)) _g.call(indexes_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return new ArrayIterator(sortedValues);\n\n    var e_2, _c, e_3, _f, e_5, _g;\n  };\n\n  return OrderedIterable;\n}(); //\n// An iterator to extact an element from an array.\n//\n\n\nvar ExtractElementIterator =\n/** @class */\nfunction () {\n  function ExtractElementIterator(iterator, extractIndex) {\n    this.iterator = iterator;\n    this.extractIndex = extractIndex;\n  }\n\n  ExtractElementIterator.prototype.next = function () {\n    var result = this.iterator.next();\n\n    if (result.done) {\n      return result;\n    } else {\n      return {\n        done: false,\n        value: result.value[this.extractIndex]\n      };\n    }\n  };\n\n  return ExtractElementIterator;\n}(); //\n\n\nvar ExtractElementIterable =\n/** @class */\nfunction () {\n  function ExtractElementIterable(arrayIterable, extractIndex) {\n    this.arrayIterable = arrayIterable;\n    this.extractIndex = extractIndex;\n  }\n\n  ExtractElementIterable.prototype[Symbol.iterator] = function () {\n    var arrayIterator = this.arrayIterable[Symbol.iterator]();\n    return new ExtractElementIterator(arrayIterator, this.extractIndex);\n  };\n\n  return ExtractElementIterable;\n}(); //\n// An iterator that skips a number of values.\n//\n\n\nvar SkipIterator =\n/** @class */\nfunction () {\n  function SkipIterator(iterator, numValues) {\n    this.iterator = iterator;\n    this.numValues = numValues;\n  }\n\n  SkipIterator.prototype.next = function () {\n    while (--this.numValues >= 0) {\n      var result = this.iterator.next();\n\n      if (result.done) {\n        return result;\n      }\n    }\n\n    return this.iterator.next();\n  };\n\n  return SkipIterator;\n}(); //\n\n\nvar SkipIterable =\n/** @class */\nfunction () {\n  function SkipIterable(iterable, numValues) {\n    this.iterable = iterable;\n    this.numValues = numValues;\n  }\n\n  SkipIterable.prototype[Symbol.iterator] = function () {\n    var iterator = this.iterable[Symbol.iterator]();\n    return new SkipIterator(iterator, this.numValues);\n  };\n\n  return SkipIterable;\n}(); //\n// An iterator that skips a sequence of elements while a predicate function returns true.\n//\n\n\nvar SkipWhileIterator =\n/** @class */\nfunction () {\n  function SkipWhileIterator(childIterator, predicate) {\n    this.doneSkipping = false;\n    this.childIterator = childIterator;\n    this.predicate = predicate;\n  }\n\n  SkipWhileIterator.prototype.next = function () {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      var result = this.childIterator.next();\n\n      if (result.done) {\n        return result; // Done.\n      }\n\n      if (!this.doneSkipping && this.predicate(result.value)) {\n        continue; // Skip it.\n      } // It matches, stop skipping.\n\n\n      this.doneSkipping = true;\n      return result;\n    }\n  };\n\n  return SkipWhileIterator;\n}(); //\n\n\nvar SkipWhileIterable =\n/** @class */\nfunction () {\n  function SkipWhileIterable(childIterable, predicate) {\n    this.childIterable = childIterable;\n    this.predicate = predicate;\n  }\n\n  SkipWhileIterable.prototype[Symbol.iterator] = function () {\n    var childIterator = this.childIterable[Symbol.iterator]();\n    return new SkipWhileIterator(childIterator, this.predicate);\n  };\n\n  return SkipWhileIterable;\n}(); //\n\n\nvar DataFrameWindowIterator =\n/** @class */\nfunction () {\n  function DataFrameWindowIterator(columnNames, iterable, period) {\n    this.columnNames = columnNames;\n    this.iterable = iterable;\n    this.period = period;\n  }\n\n  DataFrameWindowIterator.prototype.next = function () {\n    if (!this.iterator) {\n      this.iterator = this.iterable[Symbol.iterator]();\n    }\n\n    var curWindow = [];\n\n    for (var i = 0; i < this.period; ++i) {\n      var curPos = this.iterator.next();\n\n      if (curPos.done) {\n        // Underlying iterator is finished.\n        break;\n      }\n\n      curWindow.push(curPos.value);\n    }\n\n    if (curWindow.length === 0) {\n      // Underlying iterator doesn't have required number of elements.\n      return {\n        done: true\n      };\n    }\n\n    var window = new DataFrame({\n      columnNames: this.columnNames,\n      pairs: curWindow\n    });\n    return {\n      value: window,\n      done: false\n    };\n  };\n\n  return DataFrameWindowIterator;\n}(); //\n\n\nvar DataFrameWindowIterable =\n/** @class */\nfunction () {\n  function DataFrameWindowIterable(columnNames, iterable, period) {\n    this.columnNames = columnNames;\n    this.iterable = iterable;\n    this.period = period;\n  }\n\n  DataFrameWindowIterable.prototype[Symbol.iterator] = function () {\n    return new DataFrameWindowIterator(this.columnNames, this.iterable, this.period);\n  };\n\n  return DataFrameWindowIterable;\n}(); //\n// An iterator that iterates the rows of a CSV file.\n//\n\n\nvar CsvRowsIterator =\n/** @class */\nfunction () {\n  function CsvRowsIterator(columnNames, rowsIterable) {\n    this.index = 0;\n    this.columnNames = Array.from(columnNames);\n    this.rowsIterator = rowsIterable[Symbol.iterator]();\n  }\n\n  CsvRowsIterator.prototype.next = function () {\n    var result = this.rowsIterator.next();\n\n    if (result.done) {\n      // https://github.com/Microsoft/TypeScript/issues/8938\n      return {\n        done: true\n      }; // <= explicit cast here!;\n    }\n\n    var row = result.value;\n    var value = {};\n\n    for (var cellIndex = 0; cellIndex < this.columnNames.length; ++cellIndex) {\n      var columnName = this.columnNames[cellIndex];\n      value[columnName] = row[cellIndex];\n    }\n\n    return {\n      done: false,\n      value: value\n    };\n  };\n\n  return CsvRowsIterator;\n}(); //\n\n\nvar CsvRowsIterable =\n/** @class */\nfunction () {\n  function CsvRowsIterable(columnNames, rows) {\n    this.columnNames = columnNames;\n    this.rows = rows;\n  }\n\n  CsvRowsIterable.prototype[Symbol.iterator] = function () {\n    return new CsvRowsIterator(this.columnNames, this.rows);\n  };\n\n  return CsvRowsIterable;\n}(); //\n\n\nvar DataFrameRollingWindowIterator =\n/** @class */\nfunction () {\n  function DataFrameRollingWindowIterator(columnNames, iterable, period) {\n    this.columnNames = columnNames;\n    this.iterable = iterable;\n    this.period = period;\n  }\n\n  DataFrameRollingWindowIterator.prototype.next = function () {\n    if (!this.curWindow) {\n      this.curWindow = [];\n      this.iterator = this.iterable[Symbol.iterator]();\n\n      for (var i = 0; i < this.period; ++i) {\n        var curPos = this.iterator.next();\n\n        if (curPos.done) {\n          // Underlying iterator doesn't have required number of elements.\n          return {\n            done: true\n          };\n        }\n\n        this.curWindow.push(curPos.value);\n      }\n    } else {\n      this.curWindow.shift(); // Remove first item from window.\n\n      var curPos = this.iterator.next();\n\n      if (curPos.done) {\n        // Underlying iterator doesn't have enough elements left.\n        return {\n          done: true\n        };\n      }\n\n      this.curWindow.push(curPos.value); // Add next item to window.\n    }\n\n    var window = new DataFrame({\n      columnNames: this.columnNames,\n      pairs: this.curWindow\n    });\n    return {\n      value: window,\n      done: false\n    };\n  };\n\n  return DataFrameRollingWindowIterator;\n}(); //\n\n\nvar DataFrameRollingWindowIterable =\n/** @class */\nfunction () {\n  function DataFrameRollingWindowIterable(columnNames, iterable, period) {\n    this.columnNames = columnNames;\n    this.iterable = iterable;\n    this.period = period;\n  }\n\n  DataFrameRollingWindowIterable.prototype[Symbol.iterator] = function () {\n    return new DataFrameRollingWindowIterator(this.columnNames, this.iterable, this.period);\n  };\n\n  return DataFrameRollingWindowIterable;\n}(); //\n\n\nvar DataFrameVariableWindowIterator =\n/** @class */\nfunction () {\n  function DataFrameVariableWindowIterator(columnNames, iterable, comparer) {\n    this.columnNames = columnNames;\n    this.iterator = iterable[Symbol.iterator]();\n    this.nextValue = this.iterator.next();\n    this.comparer = comparer;\n  }\n\n  DataFrameVariableWindowIterator.prototype.next = function () {\n    if (this.nextValue.done) {\n      // Nothing more to read.\n      // https://github.com/Microsoft/TypeScript/issues/8938\n      return {\n        done: true\n      }; // <= explicit cast here!;\n    }\n\n    var pairs = [this.nextValue.value];\n    var prevValue = this.nextValue.value; // Pull values until there is one that doesn't compare.\n    // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      this.nextValue = this.iterator.next();\n\n      if (this.nextValue.done) {\n        break; // No more values.\n      }\n\n      if (!this.comparer(prevValue[1], this.nextValue.value[1])) {\n        prevValue = this.nextValue.value;\n        break; // Doesn't compare. Start a new window.\n      }\n\n      pairs.push(this.nextValue.value);\n      prevValue = this.nextValue.value;\n    }\n\n    var window = new DataFrame({\n      columnNames: this.columnNames,\n      pairs: pairs\n    });\n    return {\n      value: window,\n      done: false\n    };\n  };\n\n  return DataFrameVariableWindowIterator;\n}(); //\n\n\nvar DataFrameVariableWindowIterable =\n/** @class */\nfunction () {\n  function DataFrameVariableWindowIterable(columnNames, iterable, comparer) {\n    this.columnNames = columnNames;\n    this.iterable = iterable;\n    this.comparer = comparer;\n  }\n\n  DataFrameVariableWindowIterable.prototype[Symbol.iterator] = function () {\n    return new DataFrameVariableWindowIterator(this.columnNames, this.iterable, this.comparer);\n  };\n\n  return DataFrameVariableWindowIterable;\n}(); //\n// An iterator that iterates the elements of an iterable multiple times.\n// Implementation similar to https://numpy.org/doc/stable/reference/generated/numpy.repeat.html\n//\n\n\nvar RepeatIterator =\n/** @class */\nfunction () {\n  function RepeatIterator(iterable, count) {\n    this.repetition = 0;\n    this.iterator = iterable[Symbol.iterator]();\n    this.count = count;\n    this.result = this.iterator.next();\n  }\n\n  RepeatIterator.prototype.next = function () {\n    if (this.count == 0) {\n      return {\n        done: true\n      };\n    }\n\n    if (this.repetition == this.count) {\n      this.result = this.iterator.next();\n      this.repetition = 0;\n    }\n\n    this.repetition += 1;\n\n    if (this.result.done) {\n      // https://github.com/Microsoft/TypeScript/issues/8938\n      return {\n        done: true\n      }; // <= explicit cast here!;\n    }\n\n    return {\n      done: false,\n      value: this.result.value\n    };\n  };\n\n  return RepeatIterator;\n}(); //\n\n\nvar RepeatIterable =\n/** @class */\nfunction () {\n  function RepeatIterable(iterable, count) {\n    this.iterable = iterable;\n    this.count = count;\n  }\n\n  RepeatIterable.prototype[Symbol.iterator] = function () {\n    return new RepeatIterator(this.iterable, this.count);\n  };\n\n  return RepeatIterable;\n}(); //\n// An iterator that iterates the elements of an iterable multiple times.\n// Implementation similar to - https://numpy.org/doc/stable/reference/generated/numpy.tile.html\n//\n\n\nvar TileIterator =\n/** @class */\nfunction () {\n  function TileIterator(iterable, count) {\n    this.count = 0;\n    this.repetition = 0;\n    this.firstIteration = true;\n    this.iterable = iterable;\n    this.iterator = iterable[Symbol.iterator]();\n    this.count = count;\n  }\n\n  TileIterator.prototype.next = function () {\n    var result = this.iterator.next(); // Return done for empty iterable\n\n    if (this.firstIteration && result.done) {\n      return {\n        done: true\n      };\n    }\n\n    this.firstIteration = false;\n\n    if (result.done) {\n      this.repetition += 1; // Reinitialize iterator once iterated completely\n\n      this.iterator = this.iterable[Symbol.iterator]();\n      result = this.iterator.next();\n    }\n\n    if (this.repetition < this.count) {\n      return {\n        done: false,\n        value: result.value\n      };\n    } else {\n      // https://github.com/Microsoft/TypeScript/issues/8938\n      return {\n        done: true\n      }; // <= explicit cast here!;\n    }\n  };\n\n  return TileIterator;\n}(); //\n\n\nvar TileIterable =\n/** @class */\nfunction () {\n  function TileIterable(iterable, count) {\n    this.iterable = iterable;\n    this.count = count;\n  }\n\n  TileIterable.prototype[Symbol.iterator] = function () {\n    return new TileIterator(this.iterable, this.count);\n  };\n\n  return TileIterable;\n}(); //\n// An iterator that produces a contiguous flattened array generated from each set of elements in child iterables.\n// Implementation similar to https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html with order 'C'\n//\n// Note that numpy does not work with arrays of varying lengths. However, the dataforge implementation ignores\n// that requirement due to the iterator architecture. Moreover, since the RavelIterator is only used internally\n// such cases will not occur.\n//\n\n\nvar RavelIterator =\n/** @class */\nfunction () {\n  function RavelIterator(iterables) {\n    this.iteratorIndex = 0;\n    this.iterators = iterables.map(function (iterable) {\n      return iterable[Symbol.iterator]();\n    });\n  }\n\n  RavelIterator.prototype.next = function () {\n    if (this.iterators.length > 0) {\n      var result = this.iterators[this.iteratorIndex].next();\n\n      while (result.done) {\n        this.iteratorIndex += 1;\n\n        if (this.iteratorIndex < this.iterators.length) {\n          result = this.iterators[this.iteratorIndex].next();\n        } else {\n          // https://github.com/Microsoft/TypeScript/issues/8938\n          return {\n            done: true\n          }; // <= explicit cast here!;\n        }\n      }\n\n      return {\n        done: false,\n        value: result.value\n      };\n    } // Return done if empty array passed\n\n\n    return {\n      done: true\n    };\n  };\n\n  return RavelIterator;\n}(); //\n\n\nvar RavelIterable =\n/** @class */\nfunction () {\n  function RavelIterable(iterables) {\n    this.iterables = iterables;\n  }\n\n  RavelIterable.prototype[Symbol.iterator] = function () {\n    return new RavelIterator(this.iterables);\n  };\n\n  return RavelIterable;\n}(); //\n\n\nvar ColumnNamesIterator =\n/** @class */\nfunction () {\n  function ColumnNamesIterator(values, considerAllRows) {\n    this.columnNamesIterator = null;\n    this.values = values;\n    this.considerAllRows = considerAllRows;\n  }\n\n  ColumnNamesIterator.prototype.next = function () {\n    if (this.columnNamesIterator === null) {\n      if (this.considerAllRows) {\n        var combinedFields = {};\n\n        try {\n          // Check all items.\n          for (var _a = __values(this.values), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var value = _b.value;\n\n            try {\n              for (var _c = __values(Object.keys(value)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var fieldName = _d.value;\n                combinedFields[fieldName] = true;\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (_d && !_d.done && (_e = _c.return)) _e.call(_c);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_b && !_b.done && (_f = _a.return)) _f.call(_a);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        this.columnNamesIterator = new ArrayIterator(Object.keys(combinedFields));\n      } else {\n        // Just check the first item.\n        var valuesIterator = this.values[Symbol.iterator]();\n        var firstResult = valuesIterator.next();\n\n        if (firstResult.done) {\n          return {\n            done: true,\n            value: \"\"\n          };\n        }\n\n        this.columnNamesIterator = new ArrayIterator(Object.keys(firstResult.value));\n      }\n    }\n\n    return this.columnNamesIterator.next();\n\n    var e_2, _f, e_1, _e;\n  };\n\n  return ColumnNamesIterator;\n}(); //\n\n\nvar ColumnNamesIterable =\n/** @class */\nfunction () {\n  function ColumnNamesIterable(values, considerAllRows) {\n    this.values = values;\n    this.considerAllRows = considerAllRows;\n  }\n\n  ColumnNamesIterable.prototype[Symbol.iterator] = function () {\n    return new ColumnNamesIterator(this.values, this.considerAllRows);\n  };\n\n  return ColumnNamesIterable;\n}(); //\n// Helper function to only return distinct items.\n//\n\n\nfunction makeDistinct(items, selector) {\n  var set = {};\n  var output = [];\n\n  try {\n    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n      var item = items_1_1.value;\n      var key = selector && selector(item) || item;\n\n      if (!set[key]) {\n        // Haven't yet seen this key.\n        set[key] = true;\n        output.push(item);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return output;\n\n  var e_1, _a;\n} //\n// Helper function to map an array of objects.\n//\n\n\nfunction toMap(items, keySelector, valueSelector) {\n  var output = {};\n\n  try {\n    for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {\n      var item = items_2_1.value;\n      var key = keySelector(item);\n      output[key] = valueSelector(item);\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (items_2_1 && !items_2_1.done && (_a = items_2.return)) _a.call(items_2);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n\n  return output;\n\n  var e_2, _a;\n} //\n// Helper function to map an array of objects.\n//\n\n\nfunction toMap2(items, keySelector, valueSelector) {\n  var output = new Map();\n\n  try {\n    for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {\n      var item = items_3_1.value;\n      output.set(keySelector(item), valueSelector(item));\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (items_3_1 && !items_3_1.done && (_a = items_3.return)) _a.call(items_3);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return output;\n\n  var e_3, _a;\n} //\n// Determine the type of a value.\n//\n\n\nfunction determineType(value) {\n  if (value === undefined) {\n    return \"undefined\";\n  } else if (isNumber(value)) {\n    return \"number\";\n  } else if (isString(value)) {\n    return \"string\";\n  } else if (value instanceof Date) {\n    return \"date\";\n  } else if (isBoolean(value)) {\n    return \"boolean\";\n  } else {\n    return \"unsupported\";\n  }\n}\n\nfunction isObject(v) {\n  return t(v).isObject && !isDate(v);\n}\n\nfunction isFunction(v) {\n  return t(v).isFunction;\n}\n\nfunction isString(v) {\n  return t(v).isString;\n}\n\nfunction isDate(v) {\n  return Object.prototype.toString.call(v) === \"[object Date]\";\n}\n\nfunction isBoolean(v) {\n  return t(v).isBoolean;\n}\n\nfunction isNumber(v) {\n  return t(v).isNumber;\n}\n\nfunction isArray(v) {\n  return t(v).isArray;\n}\n\nfunction isUndefined(v) {\n  return v === undefined;\n}\n/**\r\n * Class that represents a dataframe.\r\n * A dataframe contains an indexed sequence of data records.\r\n * Think of it as a spreadsheet or CSV file in memory.\r\n *\r\n * Each data record contains multiple named fields, the value of each field represents one row in a column of data.\r\n * Each column of data is a named {@link Series}.\r\n * You think of a dataframe a collection of named data series.\r\n *\r\n * @typeparam IndexT The type to use for the index.\r\n * @typeparam ValueT The type to use for each row/data record.\r\n */\n\n\nvar DataFrame =\n/** @class */\nfunction () {\n  /**\r\n   * Create a dataframe.\r\n   *\r\n   * @param config This can be an array, a configuration object or a function that lazily produces a configuration object.\r\n   *\r\n   * It can be an array that specifies the data records that the dataframe contains.\r\n   *\r\n   * It can be a {@link IDataFrameConfig} that defines the data and configuration of the dataframe.\r\n   *\r\n   * Or it can be a function that lazily produces a {@link IDataFrameConfig}.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = new DataFrame();\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = new DataFrame([ { A: 10 }, { A: 20 }, { A: 30 }, { A: 40 }]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = new DataFrame({ index: [1, 2, 3, 4], values: [ { A: 10 }, { A: 20 }, { A: 30 }, { A: 40 }] });\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [ { A: 10 }, { A: 20 }, { A: 30 }, { A: 40 }] });\r\n   * const df = new DataFrame(lazyInit);\r\n   * </pre>\r\n   */\n  function DataFrame(config) {\n    //\n    // Function to lazy evaluate the configuration of the dataframe.\n    //\n    this.configFn = null; //\n    // The content of the dataframe.\n    // When this is null it means the dataframe is yet to be lazy initialised.\n    //\n\n    this.content = null; // \n    // Indexed content of the dataframe.\n    // \n\n    this.indexedContent = null;\n\n    if (config) {\n      if (isFunction(config)) {\n        this.configFn = config;\n      } else if (isArray(config) || isFunction(config[Symbol.iterator])) {\n        this.content = DataFrame.initFromArray(config);\n      } else {\n        this.content = DataFrame.initFromConfig(config);\n      }\n    } else {\n      this.content = DataFrame.initEmpty();\n    }\n  } //\n  // Initialise dataframe content from an iterable of values.\n  //\n\n\n  DataFrame.initFromArray = function (arr) {\n    var firstResult = arr[Symbol.iterator]().next();\n    var columnNames = !firstResult.done ? Object.keys(firstResult.value) : [];\n    return {\n      index: DataFrame.defaultCountIterable,\n      values: arr,\n      pairs: new MultiIterable([DataFrame.defaultCountIterable, arr]),\n      isBaked: true,\n      columnNames: columnNames\n    };\n  }; //\n  // Initialise an empty dataframe.\n  //\n\n\n  DataFrame.initEmpty = function () {\n    return {\n      index: DataFrame.defaultEmptyIterable,\n      values: DataFrame.defaultEmptyIterable,\n      pairs: DataFrame.defaultEmptyIterable,\n      isBaked: true,\n      columnNames: []\n    };\n  }; //\n  // Initialise dataframe column names.\n  //\n\n\n  DataFrame.initColumnNames = function (inputColumnNames, isCaseSensitive) {\n    var outputColumnNames = [];\n    var columnNamesMap = {};\n\n    try {\n      // Search for duplicate column names.\n      for (var inputColumnNames_1 = __values(inputColumnNames), inputColumnNames_1_1 = inputColumnNames_1.next(); !inputColumnNames_1_1.done; inputColumnNames_1_1 = inputColumnNames_1.next()) {\n        var columnName = inputColumnNames_1_1.value;\n        var columnNameLwr = isCaseSensitive !== undefined && isCaseSensitive ? columnName : columnName.toLowerCase();\n\n        if (columnNamesMap[columnNameLwr] === undefined) {\n          columnNamesMap[columnNameLwr] = 1;\n        } else {\n          columnNamesMap[columnNameLwr] += 1;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (inputColumnNames_1_1 && !inputColumnNames_1_1.done && (_a = inputColumnNames_1.return)) _a.call(inputColumnNames_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var columnNoMap = {};\n\n    try {\n      for (var inputColumnNames_2 = __values(inputColumnNames), inputColumnNames_2_1 = inputColumnNames_2.next(); !inputColumnNames_2_1.done; inputColumnNames_2_1 = inputColumnNames_2.next()) {\n        var columnName = inputColumnNames_2_1.value;\n        var columnNameLwr = isCaseSensitive !== undefined && isCaseSensitive ? columnName : columnName.toLowerCase();\n\n        if (columnNamesMap[columnNameLwr] > 1) {\n          var curColumnNo = 1; // There are duplicates of this column.\n\n          if (columnNoMap[columnNameLwr] !== undefined) {\n            curColumnNo = columnNoMap[columnNameLwr];\n          }\n\n          outputColumnNames.push(columnName + \".\" + curColumnNo);\n          columnNoMap[columnNameLwr] = curColumnNo + 1;\n        } else {\n          // No duplicates.\n          outputColumnNames.push(columnName);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (inputColumnNames_2_1 && !inputColumnNames_2_1.done && (_b = inputColumnNames_2.return)) _b.call(inputColumnNames_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return outputColumnNames;\n\n    var e_1, _a, e_2, _b;\n  }; //\n  // Check that a value is an interable.\n  //\n\n\n  DataFrame.checkIterable = function (input, fieldName) {\n    if (isArray(input)) ;else if (isFunction(input[Symbol.iterator])) ;else {\n      // Not ok\n      throw new Error(\"Expected '\" + fieldName + \"' field of DataFrame config object to be an array of values or an iterable of values.\");\n    }\n  }; //\n  // Initialise dataframe content from a config object.\n  //\n\n\n  DataFrame.initFromConfig = function (config) {\n    var index;\n    var values;\n    var pairs;\n    var isBaked = false;\n    var columnNames;\n\n    if (config.pairs) {\n      DataFrame.checkIterable(config.pairs, \"pairs\");\n      pairs = config.pairs;\n    }\n\n    if (config.columns) {\n      var columnsConfig = config.columns;\n\n      if (isArray(columnsConfig) || isFunction(columnsConfig[Symbol.iterator])) {\n        var iterableColumnsConfig = columnsConfig;\n        columnNames = Array.from(iterableColumnsConfig).map(function (column) {\n          return column.name;\n        });\n        columnsConfig = toMap(iterableColumnsConfig, function (column) {\n          return column.name;\n        }, function (column) {\n          return column.series;\n        });\n      } else {\n        if (!isObject(columnsConfig)) throw new Error(\"Expected 'columns' member of 'config' parameter to DataFrame constructor to be an object with fields that define columns.\");\n        columnNames = Object.keys(columnsConfig);\n      }\n\n      var columnIterables = [];\n\n      try {\n        for (var columnNames_1 = __values(columnNames), columnNames_1_1 = columnNames_1.next(); !columnNames_1_1.done; columnNames_1_1 = columnNames_1.next()) {\n          var columnName = columnNames_1_1.value;\n          DataFrame.checkIterable(columnsConfig[columnName], columnName);\n          columnIterables.push(columnsConfig[columnName]);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (columnNames_1_1 && !columnNames_1_1.done && (_a = columnNames_1.return)) _a.call(columnNames_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      values = new CsvRowsIterable(columnNames, new MultiIterable(columnIterables));\n    } else {\n      if (config.columnNames) {\n        columnNames = this.initColumnNames(config.columnNames, config.caseSensitive);\n      }\n\n      if (config.rows) {\n        if (!config.columnNames) {\n          columnNames = new SelectIterable(new CountIterable(), function (c) {\n            return \"Column.\" + c.toString();\n          });\n        }\n\n        DataFrame.checkIterable(config.rows, 'rows');\n        values = new CsvRowsIterable(columnNames, config.rows); // Convert data from rows to columns.\n      } else if (config.values) {\n        DataFrame.checkIterable(config.values, 'values');\n        values = config.values;\n\n        if (!config.columnNames) {\n          columnNames = new ColumnNamesIterable(values, config.considerAllRows || false);\n        }\n      } else if (pairs) {\n        values = new ExtractElementIterable(pairs, 1);\n\n        if (!config.columnNames) {\n          columnNames = new ColumnNamesIterable(values, config.considerAllRows || false);\n        }\n      } else {\n        values = DataFrame.defaultEmptyIterable;\n\n        if (!config.columnNames) {\n          columnNames = DataFrame.defaultEmptyIterable;\n        }\n      }\n    }\n\n    if (config.index) {\n      DataFrame.checkIterable(config.index, 'index');\n      index = config.index;\n    } else if (pairs) {\n      index = new ExtractElementIterable(pairs, 0);\n    } else {\n      index = DataFrame.defaultCountIterable;\n    }\n\n    if (!pairs) {\n      pairs = new MultiIterable([index, values]);\n    }\n\n    if (config.baked !== undefined) {\n      isBaked = config.baked;\n    }\n\n    return {\n      index: index,\n      values: values,\n      pairs: pairs,\n      isBaked: isBaked,\n      columnNames: columnNames\n    };\n\n    var e_3, _a;\n  }; //\n  // Ensure the dataframe content has been initialised.\n  //\n\n\n  DataFrame.prototype.lazyInit = function () {\n    if (this.content === null && this.configFn !== null) {\n      this.content = DataFrame.initFromConfig(this.configFn());\n    }\n  }; //\n  // Ensure the dataframe content is lazy initialised and return it.\n  //\n\n\n  DataFrame.prototype.getContent = function () {\n    this.lazyInit();\n    return this.content;\n  }; // \n  // Lazy builds content index, does basic hash lookup.\n  //\n\n\n  DataFrame.prototype.getRowByIndex = function (index) {\n    if (!this.indexedContent) {\n      this.indexedContent = new Map();\n\n      try {\n        for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var pair = _b.value;\n          this.indexedContent.set(pair[0], pair[1]);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    }\n\n    return this.indexedContent.get(index);\n\n    var e_4, _c;\n  };\n  /**\r\n   * Get an iterator to enumerate the rows of the dataframe.\r\n   * Enumerating the iterator forces lazy evaluation to complete.\r\n   * This function is automatically called by `for...of`.\r\n   *\r\n   * @return An iterator for the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * for (const row of df) {\r\n   *     // ... do something with the row ...\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype[Symbol.iterator] = function () {\n    return this.getContent().values[Symbol.iterator]();\n  };\n  /**\r\n   * Get the names of the columns in the dataframe.\r\n   *\r\n   * @return Returns an array of the column names in the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * console.log(df.getColumnNames());\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.getColumnNames = function () {\n    return Array.from(this.getContent().columnNames);\n  };\n  /**\r\n   * Retreive the collection of all columns in the dataframe.\r\n   *\r\n   * @return Returns a {@link Series} containing the names of the columns in the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * for (const column in df.getColumns()) {\r\n   *      console.log(\"Column name: \");\r\n   *      console.log(column.name);\r\n   *\r\n   *      console.log(\"Data:\");\r\n   *      console.log(column.series.toArray());\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.getColumns = function () {\n    var _this = this;\n\n    return new Series(function () {\n      var columnNames = _this.getColumnNames();\n\n      return {\n        values: columnNames.map(function (columnName) {\n          var series = _this.getSeries(columnName).skipWhile(function (value) {\n            return value === undefined || value === null;\n          });\n\n          var firstValue = series.any() ? series.first() : undefined;\n          return {\n            name: columnName,\n            type: determineType(firstValue),\n            series: series\n          };\n        })\n      };\n    });\n  };\n  /**\r\n   * Cast the value of the dataframe to a new type.\r\n   * This operation has no effect but to retype the value that the dataframe contains.\r\n   *\r\n   * @return The same dataframe, but with the type changed.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const castDf = df.cast<SomeOtherType>();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.cast = function () {\n    return this;\n  };\n  /**\r\n   * Get the index for the dataframe.\r\n   *\r\n   * @return The {@link Index} for the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const index = df.getIndex();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.getIndex = function () {\n    var _this = this;\n\n    return new Index(function () {\n      return {\n        values: _this.getContent().index\n      };\n    });\n  };\n  /**\r\n   * Set a named column as the {@link Index} of the dataframe.\r\n   *\r\n   * @param columnName Name of the column to use as the new {@link Index} of the returned dataframe.\r\n   *\r\n   * @return Returns a new dataframe with the values of the specified column as the new {@link Index}.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const indexedDf = df.setIndex(\"SomeColumn\");\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.setIndex = function (columnName) {\n    if (!isString(columnName)) throw new Error(\"Expected 'columnName' parameter to 'DataFrame.setIndex' to be a string that specifies the name of the column to set as the index for the dataframe.\");\n    return this.withIndex(this.getSeries(columnName));\n  };\n  /**\r\n   * Apply a new {@link Index} to the dataframe.\r\n   *\r\n   * @param newIndex The new array or iterable to be the new {@link Index} of the dataframe. Can also be a selector to choose the {@link Index} for each row in the dataframe.\r\n   *\r\n   * @return Returns a new dataframe or dataframe with the specified {@link Index} attached.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const indexedDf = df.withIndex([10, 20, 30]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const indexedDf = df.withIndex(df.getSeries(\"SomeColumn\"));\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const indexedDf = df.withIndex(row => row.SomeColumn);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const indexedDf = df.withIndex(row => row.SomeColumn + 20);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.withIndex = function (newIndex) {\n    var _this = this;\n\n    if (isFunction(newIndex)) {\n      return new DataFrame(function () {\n        var content = _this.getContent();\n\n        return {\n          columnNames: content.columnNames,\n          values: content.values,\n          index: _this.deflate(newIndex)\n        };\n      });\n    } else {\n      DataFrame.checkIterable(newIndex, 'newIndex');\n      return new DataFrame(function () {\n        var content = _this.getContent();\n\n        return {\n          columnNames: content.columnNames,\n          values: content.values,\n          index: newIndex\n        };\n      });\n    }\n  };\n  /**\r\n   * Resets the {@link Index} of the dataframe back to the default zero-based sequential integer index.\r\n   *\r\n   * @return Returns a new dataframe with the {@link Index} reset to the default zero-based index.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfWithResetIndex = df.resetIndex();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.resetIndex = function () {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: content.columnNames,\n        values: content.values\n      };\n    });\n  };\n  /**\r\n   * Extract a {@link Series} from a named column in the dataframe.\r\n   *\r\n   * @param columnName Specifies the name of the column that contains the {@link Series} to retreive.\r\n   *\r\n   * @return Returns the {@link Series} extracted from the named column in the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = df.getSeries(\"SomeColumn\");\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.getSeries = function (columnName) {\n    var _this = this;\n\n    if (!isString(columnName)) throw new Error(\"Expected 'columnName' parameter to 'DataFrame.getSeries' function to be a string that specifies the name of the column to retreive.\");\n    return new Series(function () {\n      return {\n        values: new SelectIterable(_this.getContent().values, function (row) {\n          return row[columnName];\n        }),\n        index: _this.getContent().index\n      };\n    });\n  };\n  /**\r\n   * Determine if the dataframe contains a {@link Series} the specified named column.\r\n   *\r\n   * @param columnName Name of the column to check for.\r\n   *\r\n   * @return Returns true if the dataframe contains the requested {@link Series}, otherwise returns false.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * if (df.hasSeries(\"SomeColumn\")) {\r\n   *      // ... the dataframe contains a series with the specified column name ...\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.hasSeries = function (columnName) {\n    var columnNameLwr = columnName.toLowerCase();\n\n    try {\n      for (var _a = __values(this.getColumnNames()), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var existingColumnName = _b.value;\n\n        if (existingColumnName.toLowerCase() === columnNameLwr) {\n          return true;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return false;\n\n    var e_5, _c;\n  };\n  /**\r\n   * Verify the existence of a name column and extracts the {@link Series} for it.\r\n   * Throws an exception if the requested column doesn't exist.\r\n   *\r\n   * @param columnName Name of the column to extract.\r\n   *\r\n   * @return Returns the {@link Series} for the column if it exists, otherwise it throws an exception.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * try {\r\n   *      const series = df.expectSeries(\"SomeColumn\");\r\n   *      // ... do something with the series ...\r\n   * }\r\n   * catch (err) {\r\n   *      // ... the dataframe doesn't contain the column \"SomeColumn\" ...\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.expectSeries = function (columnName) {\n    if (!this.hasSeries(columnName)) {\n      throw new Error(\"Expected dataframe to contain series with column name: '\" + columnName + \"'.\");\n    }\n\n    return this.getSeries(columnName);\n  };\n  /**\r\n   * Create a new dataframe with a replaced or additional column specified by the passed-in series.\r\n   *\r\n   * @param columnNameOrSpec The name of the column to add or replace or a {@link IColumnGenSpec} that defines the columns to add.\r\n   * @param series When columnNameOrSpec is a string that identifies the column to add, this specifies the {@link Series} to add to the dataframe or a function that produces a series (given a dataframe).\r\n   *\r\n   * @return Returns a new dataframe replacing or adding a particular named column.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const modifiedDf = df.withSeries(\"ANewColumn\", new Series([1, 2, 3]));\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const modifiedDf = df.withSeries(\"ANewColumn\", df =>\r\n   *      df.getSeries(\"SourceData\").select(aTransformation)\r\n   * );\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const modifiedDf = df.withSeries({\r\n   *      ANewColumn: new Series([1, 2, 3]),\r\n   *      SomeOtherColumn: new Series([10, 20, 30])\r\n   * });\r\n   * <pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const modifiedDf = df.withSeries({\r\n   *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\r\n   * });\r\n   * <pre>\r\n   */\n\n\n  DataFrame.prototype.withSeries = function (columnNameOrSpec, series) {\n    var _this = this;\n\n    if (!isObject(columnNameOrSpec)) {\n      if (!isString(columnNameOrSpec)) throw new Error(\"Expected 'columnNameOrSpec' parameter to 'DataFrame.withSeries' function to be a string that specifies the column to set or replace.\");\n\n      if (!isFunction(series)) {\n        if (!isObject(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.withSeries' to be a Series object or a function that takes a dataframe and produces a Series.\");\n      }\n    } else {\n      if (!isUndefined(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.withSeries' to not be set when 'columnNameOrSpec is an object.\");\n    }\n\n    if (isObject(columnNameOrSpec)) {\n      var columnSpec = columnNameOrSpec;\n      var columnNames = Object.keys(columnSpec);\n      var workingDataFrame = this;\n\n      try {\n        for (var columnNames_2 = __values(columnNames), columnNames_2_1 = columnNames_2.next(); !columnNames_2_1.done; columnNames_2_1 = columnNames_2.next()) {\n          var columnName_1 = columnNames_2_1.value;\n          workingDataFrame = workingDataFrame.withSeries(columnName_1, columnSpec[columnName_1]);\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (columnNames_2_1 && !columnNames_2_1.done && (_a = columnNames_2.return)) _a.call(columnNames_2);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n\n      return workingDataFrame.cast();\n    }\n\n    var columnName = columnNameOrSpec;\n\n    if (this.none()) {\n      // We have an empty data frame.\n      var importSeries = void 0;\n\n      if (isFunction(series)) {\n        importSeries = series(this);\n      } else {\n        importSeries = series;\n      }\n\n      return importSeries.inflate(function (value) {\n        var row = {};\n        row[columnName] = value;\n        return row;\n      }).cast();\n    }\n\n    return new DataFrame(function () {\n      var importSeries;\n\n      if (isFunction(series)) {\n        importSeries = series(_this);\n      } else {\n        importSeries = series;\n      }\n\n      var seriesValueMap = toMap2(importSeries.toPairs(), function (pair) {\n        return pair[0];\n      }, function (pair) {\n        return pair[1];\n      });\n      var newColumnNames = makeDistinct(_this.getColumnNames().concat([columnName]));\n      return {\n        columnNames: newColumnNames,\n        index: _this.getContent().index,\n        pairs: new SelectIterable(_this.getContent().pairs, function (pair) {\n          var index = pair[0];\n          var value = pair[1];\n          var modified = Object.assign({}, value);\n          modified[columnName] = seriesValueMap.get(index);\n          return [index, modified];\n        })\n      };\n    });\n\n    var e_6, _a;\n  };\n  /**\r\n   * Merge multiple dataframes into a single dataframe.\r\n   * Rows are merged by indexed.\r\n   * Same named columns in subsequent dataframes override columns earlier dataframes.\r\n   *\r\n   * @param dataFrames An array or series of dataframes to merge.\r\n   *\r\n   * @returns The merged data frame.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const mergedDF = DataFrame.merge([df1, df2, etc]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.merge = function (dataFrames) {\n    var rowMap = new Map();\n\n    try {\n      for (var dataFrames_1 = __values(dataFrames), dataFrames_1_1 = dataFrames_1.next(); !dataFrames_1_1.done; dataFrames_1_1 = dataFrames_1.next()) {\n        var dataFrame = dataFrames_1_1.value;\n\n        try {\n          for (var _a = __values(dataFrame.toPairs()), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var pair = _b.value;\n            var index = pair[0];\n\n            if (!rowMap.has(index)) {\n              var clone = Object.assign({}, pair[1]);\n              rowMap.set(index, clone);\n            } else {\n              rowMap.set(index, Object.assign(rowMap.get(index), pair[1]));\n            }\n          }\n        } catch (e_7_1) {\n          e_7 = {\n            error: e_7_1\n          };\n        } finally {\n          try {\n            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n          } finally {\n            if (e_7) throw e_7.error;\n          }\n        }\n      }\n    } catch (e_8_1) {\n      e_8 = {\n        error: e_8_1\n      };\n    } finally {\n      try {\n        if (dataFrames_1_1 && !dataFrames_1_1.done && (_d = dataFrames_1.return)) _d.call(dataFrames_1);\n      } finally {\n        if (e_8) throw e_8.error;\n      }\n    }\n\n    var allColumnNames = Array.from(dataFrames).map(function (dataFrame) {\n      return dataFrame.getColumnNames();\n    }).reduce(function (prev, next) {\n      return prev.concat(next);\n    }, []);\n    var newColumnNames = makeDistinct(allColumnNames);\n    var mergedPairs = Array.from(rowMap.keys()).map(function (index) {\n      return [index, rowMap.get(index)];\n    });\n    mergedPairs.sort(function (a, b) {\n      if (a[0] === b[0]) {\n        return 0;\n      } else if (a[0] > b[0]) {\n        return 1;\n      } else {\n        return -1;\n      }\n    });\n    return new DataFrame({\n      columnNames: newColumnNames,\n      pairs: mergedPairs\n    });\n\n    var e_8, _d, e_7, _c;\n  };\n  /**\r\n   * Merge one or more dataframes into this dataframe.\r\n   * Rows are merged by indexed.\r\n   * Same named columns in subsequent dataframes override columns in earlier dataframes.\r\n   *\r\n   * @param otherDataFrames... One or more dataframes to merge into this dataframe.\r\n   *\r\n   * @returns The merged data frame.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const mergedDF = df1.merge(df2);\r\n   * </pre>\r\n   *\r\n   * <pre>\r\n   *\r\n   * const mergedDF = df1.merge(df2, df3, etc);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.merge = function () {\n    var otherDataFrames = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      otherDataFrames[_i] = arguments[_i];\n    }\n\n    return DataFrame.merge([this].concat(otherDataFrames));\n  };\n  /**\r\n   * Add a series to the dataframe, but only if it doesn't already exist.\r\n   *\r\n   * @param columnNameOrSpec The name of the series to add or a {@link IColumnGenSpec} that specifies the columns to add.\r\n   * @param series If columnNameOrSpec is a string that specifies the name of the series to add, this specifies the actual {@link Series} to add or a selector that generates the series given the dataframe.\r\n   *\r\n   * @return Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const updatedDf = df.ensureSeries(\"ANewColumn\", new Series([1, 2, 3]));\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const updatedDf = df.ensureSeries(\"ANewColumn\", df =>\r\n   *      df.getSeries(\"AnExistingSeries\").select(aTransformation)\r\n   * );\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const modifiedDf = df.ensureSeries({\r\n   *      ANewColumn: new Series([1, 2, 3]),\r\n   *      SomeOtherColumn: new Series([10, 20, 30])\r\n   * });\r\n   * <pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const modifiedDf = df.ensureSeries({\r\n   *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\r\n   * });\r\n   * <pre>\r\n   */\n\n\n  DataFrame.prototype.ensureSeries = function (columnNameOrSpec, series) {\n    if (!isObject(columnNameOrSpec)) {\n      if (!isString(columnNameOrSpec)) throw new Error(\"Expected 'columnNameOrSpec' parameter to 'DataFrame.ensureSeries' function to be a string that specifies the column to set or replace.\");\n\n      if (!isFunction(series)) {\n        if (!isObject(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.ensureSeries' to be a Series object or a function that takes a dataframe and produces a Series.\");\n      }\n    } else {\n      if (!isUndefined(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.ensureSeries' to not be set when 'columnNameOrSpec is an object.\");\n    }\n\n    if (isObject(columnNameOrSpec)) {\n      var columnSpec = columnNameOrSpec;\n      var columnNames = Object.keys(columnNameOrSpec);\n      var workingDataFrame = this;\n\n      try {\n        for (var columnNames_3 = __values(columnNames), columnNames_3_1 = columnNames_3.next(); !columnNames_3_1.done; columnNames_3_1 = columnNames_3.next()) {\n          var columnName_2 = columnNames_3_1.value;\n          workingDataFrame = workingDataFrame.ensureSeries(columnName_2, columnSpec[columnName_2]);\n        }\n      } catch (e_9_1) {\n        e_9 = {\n          error: e_9_1\n        };\n      } finally {\n        try {\n          if (columnNames_3_1 && !columnNames_3_1.done && (_a = columnNames_3.return)) _a.call(columnNames_3);\n        } finally {\n          if (e_9) throw e_9.error;\n        }\n      }\n\n      return workingDataFrame;\n    }\n\n    var columnName = columnNameOrSpec;\n\n    if (this.hasSeries(columnName)) {\n      return this; // Already have the series.\n    } else {\n      return this.withSeries(columnName, series);\n    }\n\n    var e_9, _a;\n  };\n  /**\r\n   * Create a new dataframe with just a subset of columns.\r\n   *\r\n   * @param columnNames Array of column names to include in the new dataframe.\r\n   *\r\n   * @return Returns a dataframe with a subset of columns from the original dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const subsetDf = df.subset([\"ColumnA\", \"ColumnB\"]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.subset = function (columnNames) {\n    var _this = this;\n\n    if (!isArray(columnNames)) throw new Error(\"Expected 'columnNames' parameter to 'DataFrame.subset' to be an array of column names to keep.\");\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: columnNames,\n        index: content.index,\n        values: new SelectIterable(content.values, function (value) {\n          var output = {};\n\n          try {\n            for (var columnNames_4 = __values(columnNames), columnNames_4_1 = columnNames_4.next(); !columnNames_4_1.done; columnNames_4_1 = columnNames_4.next()) {\n              var columnName = columnNames_4_1.value;\n              output[columnName] = value[columnName];\n            }\n          } catch (e_10_1) {\n            e_10 = {\n              error: e_10_1\n            };\n          } finally {\n            try {\n              if (columnNames_4_1 && !columnNames_4_1.done && (_a = columnNames_4.return)) _a.call(columnNames_4);\n            } finally {\n              if (e_10) throw e_10.error;\n            }\n          }\n\n          return output;\n\n          var e_10, _a;\n        }),\n        pairs: new SelectIterable(content.pairs, function (pair) {\n          var output = {};\n          var value = pair[1];\n\n          try {\n            for (var columnNames_5 = __values(columnNames), columnNames_5_1 = columnNames_5.next(); !columnNames_5_1.done; columnNames_5_1 = columnNames_5.next()) {\n              var columnName = columnNames_5_1.value;\n              output[columnName] = value[columnName];\n            }\n          } catch (e_11_1) {\n            e_11 = {\n              error: e_11_1\n            };\n          } finally {\n            try {\n              if (columnNames_5_1 && !columnNames_5_1.done && (_a = columnNames_5.return)) _a.call(columnNames_5);\n            } finally {\n              if (e_11) throw e_11.error;\n            }\n          }\n\n          return [pair[0], output];\n\n          var e_11, _a;\n        })\n      };\n    });\n  };\n  /**\r\n   * Create a new dataframe with the requested column or columns dropped.\r\n   *\r\n   * @param columnOrColumns Specifies the column name (a string) or columns (array of strings) to drop.\r\n   *\r\n   * @return Returns a new dataframe with a particular named column or columns removed.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const modifiedDf = df.dropSeries(\"SomeColumn\");\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const modifiedDf = df.dropSeries([\"ColumnA\", \"ColumnB\"]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.dropSeries = function (columnOrColumns) {\n    var _this = this;\n\n    if (!isArray(columnOrColumns)) {\n      if (!isString(columnOrColumns)) throw new Error(\"'DataFrame.dropSeries' expected either a string or an array or strings.\");\n      columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.\n    }\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      var newColumnNames = [];\n\n      try {\n        for (var _a = __values(content.columnNames), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var columnName = _b.value;\n\n          if (columnOrColumns.indexOf(columnName) === -1) {\n            newColumnNames.push(columnName); // This column is not being dropped.\n          }\n        }\n      } catch (e_12_1) {\n        e_12 = {\n          error: e_12_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_12) throw e_12.error;\n        }\n      }\n\n      return {\n        columnNames: newColumnNames,\n        index: content.index,\n        values: new SelectIterable(content.values, function (value) {\n          var clone = Object.assign({}, value);\n\n          try {\n            for (var columnOrColumns_1 = __values(columnOrColumns), columnOrColumns_1_1 = columnOrColumns_1.next(); !columnOrColumns_1_1.done; columnOrColumns_1_1 = columnOrColumns_1.next()) {\n              var droppedColumnName = columnOrColumns_1_1.value;\n              delete clone[droppedColumnName];\n            }\n          } catch (e_13_1) {\n            e_13 = {\n              error: e_13_1\n            };\n          } finally {\n            try {\n              if (columnOrColumns_1_1 && !columnOrColumns_1_1.done && (_a = columnOrColumns_1.return)) _a.call(columnOrColumns_1);\n            } finally {\n              if (e_13) throw e_13.error;\n            }\n          }\n\n          return clone;\n\n          var e_13, _a;\n        }),\n        pairs: new SelectIterable(content.pairs, function (pair) {\n          var clone = Object.assign({}, pair[1]);\n\n          try {\n            for (var columnOrColumns_2 = __values(columnOrColumns), columnOrColumns_2_1 = columnOrColumns_2.next(); !columnOrColumns_2_1.done; columnOrColumns_2_1 = columnOrColumns_2.next()) {\n              var droppedColumnName = columnOrColumns_2_1.value;\n              delete clone[droppedColumnName];\n            }\n          } catch (e_14_1) {\n            e_14 = {\n              error: e_14_1\n            };\n          } finally {\n            try {\n              if (columnOrColumns_2_1 && !columnOrColumns_2_1.done && (_a = columnOrColumns_2.return)) _a.call(columnOrColumns_2);\n            } finally {\n              if (e_14) throw e_14.error;\n            }\n          }\n\n          return [pair[0], clone];\n\n          var e_14, _a;\n        })\n      };\n\n      var e_12, _c;\n    });\n  };\n  /**\r\n   * Create a new dataframe with columns reordered.\r\n   * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.\r\n   *\r\n   * @param columnNames Specifies the new order for columns.\r\n   *\r\n   * @return Returns a new dataframe with columns reordered according to the order of the array of column names that is passed in.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const reorderedDf = df.reorderSeries([\"FirstColumn\", \"SecondColumn\", \"etc\"]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.reorderSeries = function (columnNames) {\n    var _this = this;\n\n    if (!isArray(columnNames)) throw new Error(\"Expected parameter 'columnNames' to 'DataFrame.reorderSeries' to be an array with column names.\");\n\n    try {\n      for (var columnNames_6 = __values(columnNames), columnNames_6_1 = columnNames_6.next(); !columnNames_6_1.done; columnNames_6_1 = columnNames_6.next()) {\n        var columnName = columnNames_6_1.value;\n        if (!isString(columnName)) throw new Error(\"Expected parameter 'columnNames' to 'DataFrame.reorderSeries' to be an array with column names.\");\n      }\n    } catch (e_15_1) {\n      e_15 = {\n        error: e_15_1\n      };\n    } finally {\n      try {\n        if (columnNames_6_1 && !columnNames_6_1.done && (_a = columnNames_6.return)) _a.call(columnNames_6);\n      } finally {\n        if (e_15) throw e_15.error;\n      }\n    }\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: columnNames,\n        index: content.index,\n        values: new SelectIterable(content.values, function (value) {\n          var output = {};\n\n          try {\n            for (var columnNames_7 = __values(columnNames), columnNames_7_1 = columnNames_7.next(); !columnNames_7_1.done; columnNames_7_1 = columnNames_7.next()) {\n              var columnName = columnNames_7_1.value;\n              output[columnName] = value[columnName];\n            }\n          } catch (e_16_1) {\n            e_16 = {\n              error: e_16_1\n            };\n          } finally {\n            try {\n              if (columnNames_7_1 && !columnNames_7_1.done && (_a = columnNames_7.return)) _a.call(columnNames_7);\n            } finally {\n              if (e_16) throw e_16.error;\n            }\n          }\n\n          return output;\n\n          var e_16, _a;\n        }),\n        pairs: new SelectIterable(content.pairs, function (pair) {\n          var value = pair[1];\n          var output = {};\n\n          try {\n            for (var columnNames_8 = __values(columnNames), columnNames_8_1 = columnNames_8.next(); !columnNames_8_1.done; columnNames_8_1 = columnNames_8.next()) {\n              var columnName = columnNames_8_1.value;\n              output[columnName] = value[columnName];\n            }\n          } catch (e_17_1) {\n            e_17 = {\n              error: e_17_1\n            };\n          } finally {\n            try {\n              if (columnNames_8_1 && !columnNames_8_1.done && (_a = columnNames_8.return)) _a.call(columnNames_8);\n            } finally {\n              if (e_17) throw e_17.error;\n            }\n          }\n\n          return [pair[0], output];\n\n          var e_17, _a;\n        })\n      };\n    });\n\n    var e_15, _a;\n  };\n  /**\r\n   * Bring the column(s) with specified name(s) to the front of the column order, making it (or them) the first column(s) in the output dataframe.\r\n   *\r\n   * @param columnOrColumns Specifies the column or columns to bring to the front.\r\n   *\r\n   * @return Returns a new dataframe with 1 or more columns bought to the front of the column ordering.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const modifiedDf = df.bringToFront(\"NewFirstColumn\");\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const modifiedDf = df.bringToFront([\"NewFirstColumn\", \"NewSecondColumn\"]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.bringToFront = function (columnOrColumns) {\n    var _this = this;\n\n    if (isArray(columnOrColumns)) {\n      try {\n        for (var columnOrColumns_3 = __values(columnOrColumns), columnOrColumns_3_1 = columnOrColumns_3.next(); !columnOrColumns_3_1.done; columnOrColumns_3_1 = columnOrColumns_3.next()) {\n          var columnName = columnOrColumns_3_1.value;\n\n          if (!isString(columnName)) {\n            throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToFront' function to specify a column or columns via a string or an array of strings.\");\n          }\n        }\n      } catch (e_18_1) {\n        e_18 = {\n          error: e_18_1\n        };\n      } finally {\n        try {\n          if (columnOrColumns_3_1 && !columnOrColumns_3_1.done && (_a = columnOrColumns_3.return)) _a.call(columnOrColumns_3);\n        } finally {\n          if (e_18) throw e_18.error;\n        }\n      }\n    } else {\n      if (!isString(columnOrColumns)) {\n        throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToFront' function to specify a column or columns via a string or an array of strings.\");\n      }\n\n      columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.\n    }\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      var existingColumns = Array.from(content.columnNames);\n      var columnsToMove = [];\n\n      try {\n        for (var columnOrColumns_4 = __values(columnOrColumns), columnOrColumns_4_1 = columnOrColumns_4.next(); !columnOrColumns_4_1.done; columnOrColumns_4_1 = columnOrColumns_4.next()) {\n          var columnToMove = columnOrColumns_4_1.value;\n\n          if (existingColumns.indexOf(columnToMove) !== -1) {\n            // The request column actually exists, so we will move it.\n            columnsToMove.push(columnToMove);\n          }\n        }\n      } catch (e_19_1) {\n        e_19 = {\n          error: e_19_1\n        };\n      } finally {\n        try {\n          if (columnOrColumns_4_1 && !columnOrColumns_4_1.done && (_a = columnOrColumns_4.return)) _a.call(columnOrColumns_4);\n        } finally {\n          if (e_19) throw e_19.error;\n        }\n      }\n\n      var untouchedColumnNames = [];\n\n      try {\n        for (var existingColumns_1 = __values(existingColumns), existingColumns_1_1 = existingColumns_1.next(); !existingColumns_1_1.done; existingColumns_1_1 = existingColumns_1.next()) {\n          var existingColumnName = existingColumns_1_1.value;\n\n          if (columnOrColumns.indexOf(existingColumnName) === -1) {\n            untouchedColumnNames.push(existingColumnName);\n          }\n        }\n      } catch (e_20_1) {\n        e_20 = {\n          error: e_20_1\n        };\n      } finally {\n        try {\n          if (existingColumns_1_1 && !existingColumns_1_1.done && (_b = existingColumns_1.return)) _b.call(existingColumns_1);\n        } finally {\n          if (e_20) throw e_20.error;\n        }\n      }\n\n      return {\n        columnNames: columnsToMove.concat(untouchedColumnNames),\n        index: content.index,\n        values: content.values,\n        pairs: content.pairs\n      };\n\n      var e_19, _a, e_20, _b;\n    });\n\n    var e_18, _a;\n  };\n  /**\r\n   * Bring the column(s) with specified name(s) to the back of the column order, making it (or them) the last column(s) in the output dataframe.\r\n   *\r\n   * @param columnOrColumns Specifies the column or columns to bring to the back.\r\n   *\r\n   * @return Returns a new dataframe with 1 or more columns bought to the back of the column ordering.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const modifiedDf = df.bringToBack(\"NewLastColumn\");\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const modifiedDf = df.bringToBack([\"NewSecondLastColumn, \"\"NewLastColumn\"]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.bringToBack = function (columnOrColumns) {\n    var _this = this;\n\n    if (isArray(columnOrColumns)) {\n      try {\n        for (var columnOrColumns_5 = __values(columnOrColumns), columnOrColumns_5_1 = columnOrColumns_5.next(); !columnOrColumns_5_1.done; columnOrColumns_5_1 = columnOrColumns_5.next()) {\n          var columnName = columnOrColumns_5_1.value;\n\n          if (!isString(columnName)) {\n            throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToBack' function to specify a column or columns via a string or an array of strings.\");\n          }\n        }\n      } catch (e_21_1) {\n        e_21 = {\n          error: e_21_1\n        };\n      } finally {\n        try {\n          if (columnOrColumns_5_1 && !columnOrColumns_5_1.done && (_a = columnOrColumns_5.return)) _a.call(columnOrColumns_5);\n        } finally {\n          if (e_21) throw e_21.error;\n        }\n      }\n    } else {\n      if (!isString(columnOrColumns)) {\n        throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToBack' function to specify a column or columns via a string or an array of strings.\");\n      }\n\n      columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.\n    }\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      var existingColumns = Array.from(content.columnNames);\n      var columnsToMove = [];\n\n      try {\n        for (var columnOrColumns_6 = __values(columnOrColumns), columnOrColumns_6_1 = columnOrColumns_6.next(); !columnOrColumns_6_1.done; columnOrColumns_6_1 = columnOrColumns_6.next()) {\n          var columnToMove = columnOrColumns_6_1.value;\n\n          if (existingColumns.indexOf(columnToMove) !== -1) {\n            // The request column actually exists, so we will move it.\n            columnsToMove.push(columnToMove);\n          }\n        }\n      } catch (e_22_1) {\n        e_22 = {\n          error: e_22_1\n        };\n      } finally {\n        try {\n          if (columnOrColumns_6_1 && !columnOrColumns_6_1.done && (_a = columnOrColumns_6.return)) _a.call(columnOrColumns_6);\n        } finally {\n          if (e_22) throw e_22.error;\n        }\n      }\n\n      var untouchedColumnNames = [];\n\n      try {\n        for (var existingColumns_2 = __values(existingColumns), existingColumns_2_1 = existingColumns_2.next(); !existingColumns_2_1.done; existingColumns_2_1 = existingColumns_2.next()) {\n          var existingColumnName = existingColumns_2_1.value;\n\n          if (columnOrColumns.indexOf(existingColumnName) === -1) {\n            untouchedColumnNames.push(existingColumnName);\n          }\n        }\n      } catch (e_23_1) {\n        e_23 = {\n          error: e_23_1\n        };\n      } finally {\n        try {\n          if (existingColumns_2_1 && !existingColumns_2_1.done && (_b = existingColumns_2.return)) _b.call(existingColumns_2);\n        } finally {\n          if (e_23) throw e_23.error;\n        }\n      }\n\n      return {\n        columnNames: untouchedColumnNames.concat(columnsToMove),\n        index: content.index,\n        values: content.values,\n        pairs: content.pairs\n      };\n\n      var e_22, _a, e_23, _b;\n    });\n\n    var e_21, _a;\n  };\n  /**\r\n   * Create a new dataframe with 1 or more columns renamed.\r\n   *\r\n   * @param newColumnNames A column rename spec - a JavaScript hash that maps existing column names to new column names.\r\n   *\r\n   * @return Returns a new dataframe with specified columns renamed.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const renamedDf = df.renameSeries({ OldColumnName, NewColumnName });\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const renamedDf = df.renameSeries({\r\n   *      Column1: ColumnA,\r\n   *      Column2: ColumnB\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.renameSeries = function (newColumnNames) {\n    var _this = this;\n\n    if (!isObject(newColumnNames)) throw new Error(\"Expected parameter 'newColumnNames' to 'DataFrame.renameSeries' to be an array with column names.\");\n    var existingColumnsToRename = Object.keys(newColumnNames);\n\n    try {\n      for (var existingColumnsToRename_1 = __values(existingColumnsToRename), existingColumnsToRename_1_1 = existingColumnsToRename_1.next(); !existingColumnsToRename_1_1.done; existingColumnsToRename_1_1 = existingColumnsToRename_1.next()) {\n        var existingColumnName = existingColumnsToRename_1_1.value;\n        if (!isString(existingColumnName)) throw new Error(\"Expected existing column name '\" + existingColumnName + \"' of 'newColumnNames' parameter to 'DataFrame.renameSeries' to be a string.\");\n        if (!isString(newColumnNames[existingColumnName])) throw new Error(\"Expected new column name '\" + newColumnNames[existingColumnName] + \"' for existing column '\" + existingColumnName + \"' of 'newColumnNames' parameter to 'DataFrame.renameSeries' to be a string.\");\n      }\n    } catch (e_24_1) {\n      e_24 = {\n        error: e_24_1\n      };\n    } finally {\n      try {\n        if (existingColumnsToRename_1_1 && !existingColumnsToRename_1_1.done && (_a = existingColumnsToRename_1.return)) _a.call(existingColumnsToRename_1);\n      } finally {\n        if (e_24) throw e_24.error;\n      }\n    }\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      var renamedColumns = [];\n\n      try {\n        for (var _a = __values(content.columnNames), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var existingColumnName = _b.value;\n          var columnIndex = existingColumnsToRename.indexOf(existingColumnName);\n\n          if (columnIndex === -1) {\n            renamedColumns.push(existingColumnName); // This column is not renamed.                    \n          } else {\n            renamedColumns.push(newColumnNames[existingColumnName]); // This column is renamed.\n          }\n        }\n      } catch (e_25_1) {\n        e_25 = {\n          error: e_25_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_25) throw e_25.error;\n        }\n      } //\n      // Remap each row of the data frame to the new column names.\n      //\n\n\n      function remapValue(value) {\n        var clone = Object.assign({}, value);\n\n        try {\n          for (var existingColumnsToRename_2 = __values(existingColumnsToRename), existingColumnsToRename_2_1 = existingColumnsToRename_2.next(); !existingColumnsToRename_2_1.done; existingColumnsToRename_2_1 = existingColumnsToRename_2.next()) {\n            var existingColumName = existingColumnsToRename_2_1.value;\n            clone[newColumnNames[existingColumName]] = clone[existingColumName];\n            delete clone[existingColumName];\n          }\n        } catch (e_26_1) {\n          e_26 = {\n            error: e_26_1\n          };\n        } finally {\n          try {\n            if (existingColumnsToRename_2_1 && !existingColumnsToRename_2_1.done && (_a = existingColumnsToRename_2.return)) _a.call(existingColumnsToRename_2);\n          } finally {\n            if (e_26) throw e_26.error;\n          }\n        }\n\n        return clone;\n\n        var e_26, _a;\n      }\n\n      return {\n        columnNames: renamedColumns,\n        index: content.index,\n        values: new SelectIterable(content.values, remapValue),\n        pairs: new SelectIterable(content.pairs, function (pair) {\n          return [pair[0], remapValue(pair[1])];\n        })\n      };\n\n      var e_25, _c;\n    });\n\n    var e_24, _a;\n  };\n  /**\r\n  * Extract values from the dataframe as an array.\r\n  * This forces lazy evaluation to complete.\r\n  *\r\n  * @return Returns an array of the values contained within the dataframe.\r\n  *\r\n  * @example\r\n  * <pre>\r\n  * const values = df.toArray();\r\n  * </pre>\r\n  */\n\n\n  DataFrame.prototype.toArray = function () {\n    var values = [];\n\n    try {\n      for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n\n        if (value !== undefined && value !== null) {\n          values.push(value);\n        }\n      }\n    } catch (e_27_1) {\n      e_27 = {\n        error: e_27_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_27) throw e_27.error;\n      }\n    }\n\n    return values;\n\n    var e_27, _c;\n  };\n  /**\r\n   * Retreive the index and values pairs from the dataframe as an array.\r\n   * Each pair is [index, value].\r\n   * This forces lazy evaluation to complete.\r\n   *\r\n   * @return Returns an array of pairs that contains the dataframe content. Each pair is a two element array that contains an index and a value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const pairs = df.toPairs();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.toPairs = function () {\n    var pairs = [];\n\n    try {\n      for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var pair = _b.value;\n\n        if (pair[1] != undefined && pair[1] !== null) {\n          pairs.push(pair);\n        }\n      }\n    } catch (e_28_1) {\n      e_28 = {\n        error: e_28_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_28) throw e_28.error;\n      }\n    }\n\n    return pairs;\n\n    var e_28, _c;\n  };\n  /**\r\n   * Convert the dataframe to a JavaScript object.\r\n   *\r\n   * @param keySelector Function that selects keys for the resulting object.\r\n   * @param valueSelector Function that selects values for the resulting object.\r\n   *\r\n   * @return Returns a JavaScript object generated from the dataframe by applying the key and value selector functions.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const someObject = df.toObject(\r\n   *      row => row.SomeColumn, // Specify the column to use for fields in the object.\r\n   *      row => row.SomeOtherColumn // Specify the column to use as the value for each field.\r\n   * );\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.toObject = function (keySelector, valueSelector) {\n    if (!isFunction(keySelector)) throw new Error(\"Expected 'keySelector' parameter to DataFrame.toObject to be a function.\");\n    if (!isFunction(valueSelector)) throw new Error(\"Expected 'valueSelector' parameter to DataFrame.toObject to be a function.\");\n    return toMap(this, keySelector, valueSelector);\n  };\n  /**\r\n   * Bake the data frame to an array of rows were each rows is an array of values in column order.\r\n   *\r\n   * @return Returns an array of rows. Each row is an array of values in column order.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const rows = df.toRows();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.toRows = function () {\n    var columnNames = this.getColumnNames();\n    var rows = [];\n\n    try {\n      for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        var row = [];\n\n        for (var columnIndex = 0; columnIndex < columnNames.length; ++columnIndex) {\n          row.push(value[columnNames[columnIndex]]);\n        }\n\n        rows.push(row);\n      }\n    } catch (e_29_1) {\n      e_29 = {\n        error: e_29_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_29) throw e_29.error;\n      }\n    }\n\n    return rows;\n\n    var e_29, _c;\n  };\n  /**\r\n   * Generates a new dataframe by repeatedly calling a selector function on each row in the original dataframe.\r\n   *\r\n   * @param selector Selector function that transforms each row to create the new dataframe.\r\n   *\r\n   * @return Returns a new dataframe that has been transformed by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * function transformRow (inputRow) {\r\n   *      const outputRow = {\r\n   *          // ... construct output row derived from input row ...\r\n   *      };\r\n   *\r\n   *      return outputRow;\r\n   * }\r\n   *\r\n   * const modifiedDf = df.select(row => transformRow(row));\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.select = function (selector) {\n    var _this = this;\n\n    if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.select' function to be a function.\");\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        values: new SelectIterable(content.values, selector),\n        index: content.index\n      };\n    });\n  };\n  /**\r\n   * Generates a new dataframe by repeatedly calling a selector function on each row in the original dataframe.\r\n   *\r\n   * In this case the selector function produces a collection of output rows that are flattened to create the new dataframe.\r\n   *\r\n   * @param selector Selector function that transforms each row into a collection of output rows.\r\n   *\r\n   * @return  Returns a new dataframe with rows that have been produced by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * function produceOutputRows (inputRow) {\r\n   *      const outputRows = [];\r\n   *      while (someCondition) {     *\r\n   *          // ... generate zero or more output rows ...\r\n   *          outputRows.push(... some generated row ...);\r\n   *      }\r\n   *      return outputRows;\r\n   * }\r\n   *\r\n   * const modifiedDf = df.selectMany(row => produceOutputRows(row));\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.selectMany = function (selector) {\n    var _this = this;\n\n    if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.selectMany' to be a function.\");\n    return new DataFrame(function () {\n      return {\n        pairs: new SelectManyIterable(_this.getContent().pairs, function (pair, index) {\n          var outputPairs = [];\n\n          try {\n            for (var _a = __values(selector(pair[1], index)), _b = _a.next(); !_b.done; _b = _a.next()) {\n              var transformed = _b.value;\n              outputPairs.push([pair[0], transformed]);\n            }\n          } catch (e_30_1) {\n            e_30 = {\n              error: e_30_1\n            };\n          } finally {\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_30) throw e_30.error;\n            }\n          }\n\n          return outputPairs;\n\n          var e_30, _c;\n        })\n      };\n    });\n  };\n  /**\r\n   * Transform one or more columns.\r\n   *\r\n   * This is equivalent to extracting a {@link Series} with {@link getSeries}, then transforming it with {@link Series.select},\r\n   * and finally plugging it back in as the same column using {@link withSeries}.\r\n   *\r\n   * @param columnSelectors Object with field names for each column to be transformed. Each field specifies a selector function that transforms that column.\r\n   *\r\n   * @return Returns a new dataframe with 1 or more columns transformed.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const modifiedDf = df.transformSeries({\r\n   *      AColumnToTransform: columnValue => transformRow(columnValue)\r\n   * });\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const modifiedDf = df.transformSeries({\r\n   *      ColumnA: columnValue => transformColumnA(columnValue),\r\n   *      ColumnB: columnValue => transformColumnB(columnValue)\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.transformSeries = function (columnSelectors) {\n    if (!isObject(columnSelectors)) throw new Error(\"Expected 'columnSelectors' parameter of 'DataFrame.transformSeries' function to be an object. Field names should specify columns to transform. Field values should be selector functions that specify the transformation for each column.\");\n    var working = this;\n\n    try {\n      for (var _a = __values(Object.keys(columnSelectors)), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var columnName = _b.value;\n\n        if (working.hasSeries(columnName)) {\n          working = working.withSeries(columnName, working.getSeries(columnName).select(columnSelectors[columnName]));\n        }\n      }\n    } catch (e_31_1) {\n      e_31 = {\n        error: e_31_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_31) throw e_31.error;\n      }\n    }\n\n    return working;\n\n    var e_31, _c;\n  };\n  /**\r\n   * Generate new columns based on existing rows.\r\n   *\r\n   * This is equivalent to calling {@link select} to transform the original dataframe to a new dataframe with different column,\r\n   * then using {@link withSeries} to merge each the of both the new and original dataframes.\r\n   *\r\n   * @param generator Generator function that transforms each row to produce 1 or more new columns.\r\n   * Or use a column spec that has fields for each column, the fields specify a generate function that produces the value for each new column.\r\n   *\r\n   * @return Returns a new dataframe with 1 or more new columns.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * function produceNewColumns (inputRow) {\r\n   *      const newColumns = {\r\n   *          // ... specify new columns and their values based on the input row ...\r\n   *      };\r\n   *\r\n   *      return newColumns;\r\n   * };\r\n   *\r\n   * const dfWithNewSeries = df.generateSeries(row => produceNewColumns(row));\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfWithNewSeries = df.generateSeries({\r\n   *      NewColumnA: row => produceNewColumnA(row),\r\n   *      NewColumnB: row => produceNewColumnB(row),\r\n   * })\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.generateSeries = function (generator) {\n    if (!isObject(generator)) {\n      if (!isFunction(generator)) {\n        throw new Error(\"Expected 'generator' parameter to 'DataFrame.generateSeries' function to be a function or an object.\");\n      }\n\n      var selector = generator;\n      var newColumns = this.select(selector) // Build a new dataframe.\n      .bake(); //TODO: Bake should be needed here, but it causes problems if not.\n\n      var newColumnNames = newColumns.getColumnNames();\n      var working = this;\n\n      try {\n        //TODO: There must be a cheaper implementation!\n        for (var newColumnNames_1 = __values(newColumnNames), newColumnNames_1_1 = newColumnNames_1.next(); !newColumnNames_1_1.done; newColumnNames_1_1 = newColumnNames_1.next()) {\n          var newColumnName = newColumnNames_1_1.value;\n          working = working.withSeries(newColumnName, newColumns.getSeries(newColumnName));\n        }\n      } catch (e_32_1) {\n        e_32 = {\n          error: e_32_1\n        };\n      } finally {\n        try {\n          if (newColumnNames_1_1 && !newColumnNames_1_1.done && (_a = newColumnNames_1.return)) _a.call(newColumnNames_1);\n        } finally {\n          if (e_32) throw e_32.error;\n        }\n      }\n\n      return working;\n    } else {\n      var columnTransformSpec = generator;\n      var newColumnNames = Object.keys(columnTransformSpec);\n      var working = this;\n\n      try {\n        for (var newColumnNames_2 = __values(newColumnNames), newColumnNames_2_1 = newColumnNames_2.next(); !newColumnNames_2_1.done; newColumnNames_2_1 = newColumnNames_2.next()) {\n          var newColumnName = newColumnNames_2_1.value;\n          working = working.withSeries(newColumnName, working.select(columnTransformSpec[newColumnName]).deflate());\n        }\n      } catch (e_33_1) {\n        e_33 = {\n          error: e_33_1\n        };\n      } finally {\n        try {\n          if (newColumnNames_2_1 && !newColumnNames_2_1.done && (_b = newColumnNames_2.return)) _b.call(newColumnNames_2);\n        } finally {\n          if (e_33) throw e_33.error;\n        }\n      }\n\n      return working;\n    }\n\n    var e_32, _a, e_33, _b;\n  };\n  /**\r\n   * Converts (deflates) a dataframe to a {@link Series}.\r\n   *\r\n   * @param selector Optional selector function that transforms each row to produce the series.\r\n   *\r\n   * @return Returns a series that was created from the deflated from  the original dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = df.deflate(); // Deflate to a series of object.\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = df.deflate(row => row.SomeColumn); // Extract a particular column.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.deflate = function (selector) {\n    var _this = this;\n\n    if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.deflate' function to be a selector function.\");\n    }\n\n    return new Series(function () {\n      var content = _this.getContent();\n\n      if (selector) {\n        return {\n          index: content.index,\n          values: new SelectIterable(content.values, selector),\n          pairs: new SelectIterable(content.pairs, function (pair, index) {\n            return [pair[0], selector(pair[1], index)];\n          })\n        };\n      } else {\n        return {\n          index: content.index,\n          values: content.values,\n          pairs: content.pairs\n        };\n      }\n    });\n  };\n  /**\r\n   * Inflate a named {@link Series} in the dataframe to 1 or more new series in the new dataframe.\r\n   *\r\n   * This is the equivalent of extracting the series using {@link getSeries}, transforming them with {@link Series.select}\r\n   * and then running {@link Series.inflate} to create a new dataframe, then merging each column of the new dataframe\r\n   *  into the original dataframe using {@link withSeries}.\r\n   *\r\n   * @param columnName Name of the series to inflate.\r\n   * @param selector Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.\r\n   *\r\n   * @return Returns a new dataframe with a column inflated to 1 or more new columns.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * function newColumnGenerator (row) {\r\n   *      const newColumns = {\r\n   *          // ... create 1 field per new column ...\r\n   *      };\r\n   *\r\n   *      return row;\r\n   * }\r\n   *\r\n   * const dfWithNewSeries = df.inflateSeries(\"SomeColumn\", newColumnGenerator);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.inflateSeries = function (columnName, selector) {\n    if (!isString(columnName)) throw new Error(\"Expected 'columnName' parameter to 'DataFrame.inflateSeries' to be a string that is the name of the column to inflate.\");\n\n    if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected optional 'selector' parameter to 'DataFrame.inflateSeries' to be a selector function, if it is specified.\");\n    }\n\n    return this.zip(this.getSeries(columnName).inflate(selector), function (row1, row2) {\n      return Object.assign({}, row1, row2);\n    } //todo: this be should zip's default operation.\n    );\n  };\n  /**\r\n   * Partition a dataframe into a {@link Series} of *data windows*.\r\n   * Each value in the new series is a rolling chunk of data from the original dataframe.\r\n   *\r\n   * @param period The number of data rows to include in each data window.\r\n   *\r\n   * @return Returns a new series, each value of which is a chunk of the original dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const windows = df.window(2); // Get values in pairs.\r\n   * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());\r\n   * console.log(pctIncrease.toString());\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const salesDf = ... // Daily sales data.\r\n   * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\r\n   * console.log(weeklySales.toString());\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.window = function (period) {\n    var _this = this;\n\n    if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'DataFrame.window' to be a number.\");\n    return new Series(function () {\n      var content = _this.getContent();\n\n      return {\n        values: new DataFrameWindowIterable(content.columnNames, content.pairs, period)\n      };\n    });\n  };\n  /**\r\n   * Partition a dataframe into a {@link Series} of *rolling data windows*.\r\n   * Each value in the new series is a rolling chunk of data from the original dataframe.\r\n   *\r\n   * @param period The number of data rows to include in each data window.\r\n   *\r\n   * @return Returns a new series, each value of which is a rolling chunk of the original dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const salesDf = ... // Daily sales data.\r\n   * const rollingWeeklySales = salesDf.rollingWindow(7); // Get rolling window over weekly sales data.\r\n   * console.log(rollingWeeklySales.toString());\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.rollingWindow = function (period) {\n    var _this = this;\n\n    if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'DataFrame.rollingWindow' to be a number.\");\n    return new Series(function () {\n      var content = _this.getContent();\n\n      return {\n        values: new DataFrameRollingWindowIterable(content.columnNames, content.pairs, period)\n      };\n    });\n  };\n  /**\r\n   * Partition a dataframe into a {@link Series} of variable-length *data windows*\r\n   * where the divisions between the data chunks are\r\n   * defined by a user-provided *comparer* function.\r\n   *\r\n   * @param comparer Function that compares two adjacent data rows and returns true if they should be in the same window.\r\n   *\r\n   * @return Returns a new series, each value of which is a chunk of data from the original dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * function rowComparer (rowA, rowB) {\r\n   *      if (... rowA should be in the same data window as rowB ...) {\r\n   *          return true;\r\n   *      }\r\n   *      else {\r\n   *          return false;\r\n   *      }\r\n   * };\r\n   *\r\n   * const variableWindows = df.variableWindow(rowComparer);\r\n   */\n\n\n  DataFrame.prototype.variableWindow = function (comparer) {\n    var _this = this;\n\n    if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'DataFrame.variableWindow' to be a function.\");\n    return new Series(function () {\n      var content = _this.getContent();\n\n      return {\n        values: new DataFrameVariableWindowIterable(content.columnNames, content.pairs, comparer)\n      };\n    });\n  };\n  /**\r\n   * Eliminates adjacent duplicate rows.\r\n   *\r\n   * For each group of adjacent rows that are equivalent only returns the last index/row for the group,\r\n   * thus adjacent equivalent rows are collapsed down to the last row.\r\n   *\r\n   * @param selector Optional selector function to determine the value used to compare for equivalence.\r\n   *\r\n   * @return Returns a new dataframe with groups of adjacent duplicate rows collapsed to a single row per group.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfWithDuplicateRowsRemoved = df.sequentialDistinct(row => row.ColumnA);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.sequentialDistinct = function (selector) {\n    if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.\");\n    } else {\n      selector = function selector(value) {\n        return value;\n      };\n    }\n\n    return this.variableWindow(function (a, b) {\n      return selector(a) === selector(b);\n    }).select(function (window) {\n      return [window.getIndex().first(), window.first()];\n    }).withIndex(function (pair) {\n      return pair[0];\n    }).inflate(function (pair) {\n      return pair[1];\n    }); //TODO: Should this be select?\n  };\n  /**\r\n   * Aggregate the rows in the dataframe to a single result.\r\n   *\r\n   * @param seed Optional seed value for producing the aggregation.\r\n   * @param selector Function that takes the seed and then each row in the dataframe and produces the aggregated value.\r\n   *\r\n   * @return Returns a new value that has been aggregated from the dataframe using the 'selector' function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dailySalesDf = ... daily sales figures for the past month ...\r\n   * const totalSalesForthisMonth = dailySalesDf.aggregate(\r\n   *      0, // Seed - the starting value.\r\n   *      (accumulator, row) => accumulator + row.SalesAmount // Aggregation function.\r\n   * );\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.\r\n   * const dailySalesDf = ... daily sales figures for the past month ...\r\n   * const updatedTotalSalesAllTime = dailySalesDf.aggregate(\r\n   *      totalSalesAllTime,\r\n   *      (accumulator, row) => accumulator + row.SalesAmount\r\n   * );\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * var salesDataSummary = salesDataDf.aggregate({\r\n   *      TotalSales: df => df.count(),\r\n   *      AveragePrice: df => df.deflate(row => row.Price).average(),\r\n   *      TotalRevenue: df => df.deflate(row => row.Revenue).sum(),\r\n   * });\r\n   * </pre>\r\n  */\n\n\n  DataFrame.prototype.aggregate = function (seedOrSelector, selector) {\n    var _this = this;\n\n    if (isFunction(seedOrSelector) && !selector) {\n      return this.skip(1).aggregate(this.first(), seedOrSelector);\n    } else if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to aggregate to be a function.\");\n      var accum = seedOrSelector;\n\n      try {\n        for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var value = _b.value;\n          accum = selector(accum, value);\n        }\n      } catch (e_34_1) {\n        e_34 = {\n          error: e_34_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_34) throw e_34.error;\n        }\n      }\n\n      return accum;\n    } else {\n      //\n      //TODO:\n      // This approach is fairly limited because I can't provide a seed.\n      // Consider removing this and replacing it with a 'summarize' function.\n      //\n      if (!isObject(seedOrSelector)) throw new Error(\"Expected 'seed' parameter to aggregate to be an object.\");\n      var columnAggregateSpec_1 = seedOrSelector;\n      var columnNames = Object.keys(columnAggregateSpec_1);\n      var aggregatedColumns = columnNames.map(function (columnName) {\n        var columnSelector = columnAggregateSpec_1[columnName];\n        if (!isFunction(columnSelector)) throw new Error(\"Expected column/selector pairs in 'seed' parameter to aggregate.\");\n        return [columnName, _this.getSeries(columnName).aggregate(columnSelector)];\n      });\n      return toMap(aggregatedColumns, function (pair) {\n        return pair[0];\n      }, function (pair) {\n        return pair[1];\n      });\n    }\n\n    var e_34, _c;\n  };\n  /**\r\n   * Skip a number of rows in the dataframe.\r\n   *\r\n   * @param numValues Number of rows to skip.\r\n   *\r\n   * @return Returns a new dataframe with the specified number of rows skipped.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfWithRowsSkipped = df.skip(10); // Skip 10 rows in the original dataframe.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.skip = function (numValues) {\n    var _this = this;\n\n    if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'DataFrame.skip' to be a number.\");\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: content.columnNames,\n        values: new SkipIterable(content.values, numValues),\n        index: new SkipIterable(content.index, numValues),\n        pairs: new SkipIterable(content.pairs, numValues)\n      };\n    });\n  };\n  /**\r\n   * Skips rows in the dataframe while a condition evaluates to true or truthy.\r\n   *\r\n   * @param predicate Returns true/truthy to continue to skip rows in the original dataframe.\r\n   *\r\n   * @return Returns a new dataframe with all initial sequential rows removed while the predicate returned true/truthy.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfWithRowsSkipped = df.skipWhile(row => row.CustomerName === \"Fred\"); // Skip initial customers named Fred.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.skipWhile = function (predicate) {\n    var _this = this;\n\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.skipWhile' function to be a predicate function that returns true/false.\");\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: content.columnNames,\n        values: new SkipWhileIterable(content.values, predicate),\n        pairs: new SkipWhileIterable(content.pairs, function (pair) {\n          return predicate(pair[1]);\n        })\n      };\n    });\n  };\n  /**\r\n   * Skips rows in the dataframe untils a condition evaluates to true or truthy.\r\n   *\r\n   * @param predicate Return true/truthy to stop skipping rows in the original dataframe.\r\n   *\r\n   * @return Returns a new dataframe with all initial sequential rows removed until the predicate returned true/truthy.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfWithRowsSkipped = df.skipUntil(row => row.CustomerName === \"Fred\"); // Skip initial customers until we find Fred.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.skipUntil = function (predicate) {\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.skipUntil' function to be a predicate function that returns true/false.\");\n    return this.skipWhile(function (value) {\n      return !predicate(value);\n    });\n  };\n  /**\r\n   * Take a number of rows from the dataframe.\r\n   *\r\n   * @param numValues Number of rows to take.\r\n   *\r\n   * @return Returns a new dataframe with only the specified number of rows taken from the original dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfWithRowsTaken = df.take(15); // Take only the first 15 rows from the original dataframe.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.take = function (numRows) {\n    var _this = this;\n\n    if (!isNumber(numRows)) throw new Error(\"Expected 'numRows' parameter to 'DataFrame.take' function to be a number.\");\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: content.columnNames,\n        index: new TakeIterable(content.index, numRows),\n        values: new TakeIterable(content.values, numRows),\n        pairs: new TakeIterable(content.pairs, numRows)\n      };\n    });\n  };\n  /**\r\n   * Takes rows from the dataframe while a condition evaluates to true or truthy.\r\n   *\r\n   * @param predicate Returns true/truthy to continue to take rows from the original dataframe.\r\n   *\r\n   * @return Returns a new dataframe with only the initial sequential rows that were taken while the predicate returned true/truthy.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfWithRowsTaken = df.takeWhile(row => row.CustomerName === \"Fred\"); // Take only initial customers named Fred.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.takeWhile = function (predicate) {\n    var _this = this;\n\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.takeWhile' function to be a predicate function that returns true/false.\");\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: content.columnNames,\n        values: new TakeWhileIterable(content.values, predicate),\n        pairs: new TakeWhileIterable(content.pairs, function (pair) {\n          return predicate(pair[1]);\n        })\n      };\n    });\n  };\n  /**\r\n   * Takes rows from the dataframe untils a condition evaluates to true or truthy.\r\n   *\r\n   * @param predicate Return true/truthy to stop taking rows in the original dataframe.\r\n   *\r\n   * @return Returns a new dataframe with only the initial sequential rows taken until the predicate returned true/truthy.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfWithRowsTaken = df.takeUntil(row => row.CustomerName === \"Fred\"); // Take all initial customers until we find Fred.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.takeUntil = function (predicate) {\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.takeUntil' function to be a predicate function that returns true/false.\");\n    return this.takeWhile(function (value) {\n      return !predicate(value);\n    });\n  };\n  /**\r\n   * Count the number of rows in the dataframe\r\n   *\r\n   * @return Returns the count of all rows.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const numRows = df.count();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.count = function () {\n    var total = 0;\n\n    try {\n      for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        ++total;\n      }\n    } catch (e_35_1) {\n      e_35 = {\n        error: e_35_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_35) throw e_35.error;\n      }\n    }\n\n    return total;\n\n    var e_35, _c;\n  };\n  /**\r\n   * Get the first row of the dataframe.\r\n   *\r\n   * @return Returns the first row of the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const firstRow = df.first();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.first = function () {\n    try {\n      for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        return value; // Only need the first value.\n      }\n    } catch (e_36_1) {\n      e_36 = {\n        error: e_36_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_36) throw e_36.error;\n      }\n    }\n\n    throw new Error(\"DataFrame.first: No values in DataFrame.\");\n\n    var e_36, _c;\n  };\n  /**\r\n   * Get the last row of the dataframe.\r\n   *\r\n   * @return Returns the last row of the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const lastRow = df.last();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.last = function () {\n    var lastValue = null;\n\n    try {\n      for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        lastValue = value; // Throw away all values until we get to the last one.\n      }\n    } catch (e_37_1) {\n      e_37 = {\n        error: e_37_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_37) throw e_37.error;\n      }\n    }\n\n    if (lastValue === null) {\n      throw new Error(\"DataFrame.last: No values in DataFrame.\");\n    }\n\n    return lastValue;\n\n    var e_37, _c;\n  };\n  /**\r\n   * Get the row, if there is one, with the specified index.\r\n   *\r\n   * @param index Index to for which to retreive the row.\r\n   *\r\n   * @return Returns the row from the specified index in the dataframe or undefined if there is no such index in the present in the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const row = df.at(5); // Get the row at index 5 (with a default 0-based index).\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const date = ... some date ...\r\n   * // Retreive the row with specified date from a time-series dataframe (assuming date indexed has been applied).\r\n   * const row = df.at(date);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.at = function (index) {\n    if (this.none()) {\n      return undefined;\n    }\n\n    return this.getRowByIndex(index);\n  };\n  /**\r\n   * Get X rows from the start of the dataframe.\r\n   * Pass in a negative value to get all rows at the head except for X rows at the tail.\r\n   *\r\n   * @param numValues Number of rows to take.\r\n   *\r\n   * @return Returns a new dataframe that has only the specified number of rows taken from the start of the original dataframe.\r\n   *\r\n   * @examples\r\n   * <pre>\r\n   *\r\n   * const sample = df.head(10); // Take a sample of 10 rows from the start of the dataframe.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.head = function (numValues) {\n    if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'DataFrame.head' function to be a number.\");\n\n    if (numValues === 0) {\n      return new DataFrame(); // Empty dataframe.\n    }\n\n    var toTake = numValues < 0 ? this.count() - Math.abs(numValues) : numValues;\n    return this.take(toTake);\n  };\n  /**\r\n   * Get X rows from the end of the dataframe.\r\n   * Pass in a negative value to get all rows at the tail except X rows at the head.\r\n   *\r\n   * @param numValues Number of rows to take.\r\n   *\r\n   * @return Returns a new dataframe that has only the specified number of rows taken from the end of the original dataframe.\r\n   *\r\n   * @examples\r\n   * <pre>\r\n   *\r\n   * const sample = df.tail(12); // Take a sample of 12 rows from the end of the dataframe.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.tail = function (numValues) {\n    if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'DataFrame.tail' function to be a number.\");\n\n    if (numValues === 0) {\n      return new DataFrame(); // Empty dataframe.\n    }\n\n    var toSkip = numValues > 0 ? this.count() - numValues : Math.abs(numValues);\n    return this.skip(toSkip);\n  };\n  /**\r\n   * Filter the dataframe using user-defined predicate function.\r\n   *\r\n   * @param predicate Predicte function to filter rows from the dataframe. Returns true/truthy to keep rows, or false/falsy to omit rows.\r\n   *\r\n   * @return Returns a new dataframe containing only the rows from the original dataframe that matched the predicate.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const filteredDf = df.where(row => row.CustomerName === \"Fred\"); // Filter so we only have customers named Fred.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.where = function (predicate) {\n    var _this = this;\n\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.where' function to be a function.\");\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: content.columnNames,\n        values: new WhereIterable(content.values, predicate),\n        pairs: new WhereIterable(content.pairs, function (pair) {\n          return predicate(pair[1]);\n        })\n      };\n    });\n  };\n  /**\r\n   * Invoke a callback function for each row in the dataframe.\r\n   *\r\n   * @param callback The calback function to invoke for each row.\r\n   *\r\n   * @return Returns the original dataframe with no modifications.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * df.forEach(row => {\r\n   *      // ... do something with the row ...\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.forEach = function (callback) {\n    if (!isFunction(callback)) throw new Error(\"Expected 'callback' parameter to 'DataFrame.forEach' to be a function.\");\n    var index = 0;\n\n    try {\n      for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        callback(value, index++);\n      }\n    } catch (e_38_1) {\n      e_38 = {\n        error: e_38_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_38) throw e_38.error;\n      }\n    }\n\n    return this;\n\n    var e_38, _c;\n  };\n  /**\r\n   * Evaluates a predicate function for every row in the dataframe to determine\r\n   * if some condition is true/truthy for **all** rows in the dataframe.\r\n   *\r\n   * @param predicate Predicate function that receives each row. It should returns true/truthy for a match, otherwise false/falsy.\r\n   *\r\n   * @return Returns true if the predicate has returned true or truthy for every row in the dataframe, otherwise returns false. Returns false for an empty dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const everyoneIsNamedFred = df.all(row => row.CustomerName === \"Fred\"); // Check if all customers are named Fred.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.all = function (predicate) {\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.all' to be a function.\");\n    var count = 0;\n\n    try {\n      for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n\n        if (!predicate(value)) {\n          return false;\n        }\n\n        ++count;\n      }\n    } catch (e_39_1) {\n      e_39 = {\n        error: e_39_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_39) throw e_39.error;\n      }\n    }\n\n    return count > 0;\n\n    var e_39, _c;\n  };\n  /**\r\n   * Evaluates a predicate function for every row in the dataframe to determine\r\n   * if some condition is true/truthy for **any** of rows in the dataframe.\r\n   *\r\n   * If no predicate is specified then it simply checks if the dataframe contains more than zero rows.\r\n   *\r\n   * @param predicate Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\r\n   *\r\n   * @return Returns true if the predicate has returned truthy for any row in the dataframe, otherwise returns false.\r\n   * If no predicate is passed it returns true if the dataframe contains any rows at all.\r\n   * Returns false for an empty dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const anyFreds = df.any(row => row.CustomerName === \"Fred\"); // Do we have any customers named Fred?\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const anyCustomers = df.any(); // Do we have any customers at all?\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.any = function (predicate) {\n    if (predicate) {\n      if (!isFunction(predicate)) throw new Error(\"Expected optional 'predicate' parameter to 'DataFrame.any' to be a function.\");\n    }\n\n    if (predicate) {\n      try {\n        // Use the predicate to check each value.\n        for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var value = _b.value;\n\n          if (predicate(value)) {\n            return true;\n          }\n        }\n      } catch (e_40_1) {\n        e_40 = {\n          error: e_40_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_40) throw e_40.error;\n        }\n      }\n    } else {\n      // Just check if there is at least one item.\n      var iterator = this[Symbol.iterator]();\n      return !iterator.next().done;\n    }\n\n    return false; // Nothing passed.\n\n    var e_40, _c;\n  };\n  /**\r\n   * Evaluates a predicate function for every row in the dataframe to determine\r\n   * if some condition is true/truthy for **none** of rows in the dataframe.\r\n   *\r\n   * If no predicate is specified then it simply checks if the dataframe contains zero rows.\r\n   *\r\n   * @param predicate Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\r\n   *\r\n   * @return Returns true if the predicate has returned truthy for zero rows in the dataframe, otherwise returns false. Returns false for an empty dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const noFreds = df.none(row => row.CustomerName === \"Fred\"); // Do we have zero customers named Fred?\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const noCustomers = df.none(); // Do we have zero customers?\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.none = function (predicate) {\n    if (predicate) {\n      if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.none' to be a function.\");\n    }\n\n    if (predicate) {\n      try {\n        // Use the predicate to check each value.\n        for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var value = _b.value;\n\n          if (predicate(value)) {\n            return false;\n          }\n        }\n      } catch (e_41_1) {\n        e_41 = {\n          error: e_41_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_41) throw e_41.error;\n        }\n      }\n    } else {\n      // Just check if empty.\n      var iterator = this[Symbol.iterator]();\n      return iterator.next().done || false;\n    }\n\n    return true; // Nothing failed the predicate.\n\n    var e_41, _c;\n  }; //TODO: Improve this example (and subsequent examples, they look like series setup rather than dataframe)..\n\n  /**\r\n   * Gets a new dataframe containing all rows starting at or after the specified index value.\r\n   *\r\n   * @param indexValue The index value at which to start the new dataframe.\r\n   *\r\n   * @return Returns a new dataframe containing all rows starting at or after the specified index value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = new DataFrame({\r\n   *      index: [0, 1, 2, 3], // This is the default index.\r\n   *      values: [10, 20, 30, 40],\r\n   * });\r\n   *\r\n   * const lastHalf = df.startAt(2);\r\n   * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n   *\r\n   * // Get all rows starting at (or after) a particular date.\r\n   * const result = timeSeriesDf.startAt(new Date(2016, 5, 4));\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.startAt = function (indexValue) {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      var lessThan = _this.getIndex().getLessThan();\n\n      return {\n        columnNames: content.columnNames,\n        index: new SkipWhileIterable(content.index, function (index) {\n          return lessThan(index, indexValue);\n        }),\n        pairs: new SkipWhileIterable(content.pairs, function (pair) {\n          return lessThan(pair[0], indexValue);\n        })\n      };\n    });\n  };\n  /**\r\n   * Gets a new dataframe containing all rows up until and including the specified index value (inclusive).\r\n   *\r\n   * @param indexValue The index value at which to end the new dataframe.\r\n   *\r\n   * @return Returns a new dataframe containing all rows up until and including the specified index value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = new DataFrame({\r\n   *      index: [0, 1, 2, 3], // This is the default index.\r\n   *      values: [10, 20, 30, 40],\r\n   * });\r\n   *\r\n   * const firstHalf = df.endAt(1);\r\n   * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n   *\r\n   * // Get all rows ending at a particular date.\r\n   * const result = timeSeriesDf.endAt(new Date(2016, 5, 4));\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.endAt = function (indexValue) {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();\n\n      return {\n        columnNames: content.columnNames,\n        index: new TakeWhileIterable(content.index, function (index) {\n          return lessThanOrEqualTo(index, indexValue);\n        }),\n        pairs: new TakeWhileIterable(content.pairs, function (pair) {\n          return lessThanOrEqualTo(pair[0], indexValue);\n        })\n      };\n    });\n  };\n  /**\r\n   * Gets a new dataframe containing all rows up to the specified index value (exclusive).\r\n   *\r\n   * @param indexValue The index value at which to end the new dataframe.\r\n   *\r\n   * @return Returns a new dataframe containing all rows up to (but not including) the specified index value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = new DataFrame({\r\n   *      index: [0, 1, 2, 3], // This is the default index.\r\n   *      values: [10, 20, 30, 40],\r\n   * });\r\n   *\r\n   * const firstHalf = df.before(2);\r\n   * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n   *\r\n   * // Get all rows before the specified date.\r\n   * const result = timeSeriesDf.before(new Date(2016, 5, 4));\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.before = function (indexValue) {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      var lessThan = _this.getIndex().getLessThan();\n\n      return {\n        columnNames: content.columnNames,\n        index: new TakeWhileIterable(content.index, function (index) {\n          return lessThan(index, indexValue);\n        }),\n        pairs: new TakeWhileIterable(content.pairs, function (pair) {\n          return lessThan(pair[0], indexValue);\n        })\n      };\n    });\n  };\n  /**\r\n   * Gets a new dataframe containing all rows after the specified index value (exclusive).\r\n   *\r\n   * @param indexValue The index value after which to start the new dataframe.\r\n   *\r\n   * @return Returns a new dataframe containing all rows after the specified index value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = new DataFrame({\r\n   *      index: [0, 1, 2, 3], // This is the default index.\r\n   *      values: [10, 20, 30, 40],\r\n   * });\r\n   *\r\n   * const lastHalf = df.before(1);\r\n   * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n   *\r\n   * // Get all rows after the specified date.\r\n   * const result = timeSeriesDf.after(new Date(2016, 5, 4));\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.after = function (indexValue) {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();\n\n      return {\n        columnNames: content.columnNames,\n        index: new SkipWhileIterable(content.index, function (index) {\n          return lessThanOrEqualTo(index, indexValue);\n        }),\n        pairs: new SkipWhileIterable(content.pairs, function (pair) {\n          return lessThanOrEqualTo(pair[0], indexValue);\n        })\n      };\n    });\n  };\n  /**\r\n   * Gets a new dataframe containing all rows between the specified index values (inclusive).\r\n   *\r\n   * @param startIndexValue The index at which to start the new dataframe.\r\n   * @param endIndexValue The index at which to end the new dataframe.\r\n   *\r\n   * @return Returns a new dataframe containing all values between the specified index values (inclusive).\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = new DataFrame({\r\n   *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\r\n   *      values: [10, 20, 30, 40, 50, 60],\r\n   * });\r\n   *\r\n   * const middleSection = df.between(1, 4);\r\n   * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n   *\r\n   * // Get all rows between the start and end dates (inclusive).\r\n   * const result = timeSeriesDf.after(new Date(2016, 5, 4), new Date(2016, 5, 22));\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.between = function (startIndexValue, endIndexValue) {\n    return this.startAt(startIndexValue).endAt(endIndexValue);\n  };\n  /**\r\n   * Format the dataframe for display as a string.\r\n   * This forces lazy evaluation to complete.\r\n   *\r\n   * @return Generates and returns a string representation of the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * console.log(df.toString());\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.toString = function () {\n    var columnNames = this.getColumnNames();\n    var header = [\"__index__\"].concat(columnNames);\n    var table = new Table();\n\n    try {\n      //TODO: for (const pair of this.asPairs()) {\n      for (var _a = __values(this.toPairs()), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var pair = _b.value;\n        var index = pair[0];\n        var value = pair[1];\n        table.cell(header[0], index);\n\n        for (var columnIndex = 0; columnIndex < columnNames.length; ++columnIndex) {\n          var columnName = columnNames[columnIndex];\n          table.cell(header[columnIndex + 1], value[columnName]);\n        }\n\n        table.newRow();\n      }\n    } catch (e_42_1) {\n      e_42 = {\n        error: e_42_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_42) throw e_42.error;\n      }\n    }\n\n    return table.toString();\n\n    var e_42, _c;\n  };\n  /**\r\n   * Parse a column with string values and convert it to a column with int values.\r\n   *\r\n   * @param columnNameOrNames Specifies the column name or array of column names to parse.\r\n   *\r\n   * @return Returns a new dataframe with values of particular named column(s) parsed from strings to ints.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const parsed = df.parseInts(\"MyIntColumn\");\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const parsed = df.parseInts([\"MyIntColumnA\", \"MyIntColumnA\"]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.parseInts = function (columnNameOrNames) {\n    if (isArray(columnNameOrNames)) {\n      var working = this;\n\n      try {\n        for (var columnNameOrNames_1 = __values(columnNameOrNames), columnNameOrNames_1_1 = columnNameOrNames_1.next(); !columnNameOrNames_1_1.done; columnNameOrNames_1_1 = columnNameOrNames_1.next()) {\n          var columnName = columnNameOrNames_1_1.value;\n          working = working.parseInts(columnName);\n        }\n      } catch (e_43_1) {\n        e_43 = {\n          error: e_43_1\n        };\n      } finally {\n        try {\n          if (columnNameOrNames_1_1 && !columnNameOrNames_1_1.done && (_a = columnNameOrNames_1.return)) _a.call(columnNameOrNames_1);\n        } finally {\n          if (e_43) throw e_43.error;\n        }\n      }\n\n      return working;\n    } else {\n      return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseInts());\n    }\n\n    var e_43, _a;\n  };\n  /**\r\n   * Parse a column with string values and convert it to a column with float values.\r\n   *\r\n   * @param columnNameOrNames Specifies the column name or array of column names to parse.\r\n   *\r\n   * @return Returns a new dataframe with values of particular named column(s) parsed from strings to floats.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const parsed = df.parseFloats(\"MyFloatColumn\");\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const parsed = df.parseFloats([\"MyFloatColumnA\", \"MyFloatColumnA\"]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.parseFloats = function (columnNameOrNames) {\n    if (isArray(columnNameOrNames)) {\n      var working = this;\n\n      try {\n        for (var columnNameOrNames_2 = __values(columnNameOrNames), columnNameOrNames_2_1 = columnNameOrNames_2.next(); !columnNameOrNames_2_1.done; columnNameOrNames_2_1 = columnNameOrNames_2.next()) {\n          var columnName = columnNameOrNames_2_1.value;\n          working = working.parseFloats(columnName);\n        }\n      } catch (e_44_1) {\n        e_44 = {\n          error: e_44_1\n        };\n      } finally {\n        try {\n          if (columnNameOrNames_2_1 && !columnNameOrNames_2_1.done && (_a = columnNameOrNames_2.return)) _a.call(columnNameOrNames_2);\n        } finally {\n          if (e_44) throw e_44.error;\n        }\n      }\n\n      return working;\n    } else {\n      return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseFloats());\n    }\n\n    var e_44, _a;\n  };\n  /**\r\n   * Parse a column with string values and convert it to a column with date values.\r\n   *\r\n   * @param columnNameOrNames Specifies the column name or array of column names to parse.\r\n   * @param formatString Optional formatting string for dates.\r\n   *\r\n   * Moment is used for date parsing.\r\n   * https://momentjs.com\r\n   *\r\n   * @return Returns a new dataframe with values of particular named column(s) parsed from strings to dates.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const parsed = df.parseDates(\"MyDateColumn\");\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const parsed = df.parseDates([\"MyDateColumnA\", \"MyDateColumnA\"]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.parseDates = function (columnNameOrNames, formatString) {\n    if (formatString) {\n      if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to 'DataFrame.parseDates' to be a string (if specified).\");\n    }\n\n    if (isArray(columnNameOrNames)) {\n      var working = this;\n\n      try {\n        for (var columnNameOrNames_3 = __values(columnNameOrNames), columnNameOrNames_3_1 = columnNameOrNames_3.next(); !columnNameOrNames_3_1.done; columnNameOrNames_3_1 = columnNameOrNames_3.next()) {\n          var columnName = columnNameOrNames_3_1.value;\n          working = working.parseDates(columnName, formatString);\n        }\n      } catch (e_45_1) {\n        e_45 = {\n          error: e_45_1\n        };\n      } finally {\n        try {\n          if (columnNameOrNames_3_1 && !columnNameOrNames_3_1.done && (_a = columnNameOrNames_3.return)) _a.call(columnNameOrNames_3);\n        } finally {\n          if (e_45) throw e_45.error;\n        }\n      }\n\n      return working;\n    } else {\n      return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseDates(formatString));\n    }\n\n    var e_45, _a;\n  };\n  /**\r\n   * Convert a column of values of different types to a column of string values.\r\n   *\r\n   * @param columnNames Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be.\r\n   * @param formatString Optional formatting string for dates.\r\n   *\r\n   * Numeral.js is used for number formatting.\r\n   * http://numeraljs.com/\r\n   *\r\n   * Moment is used for date formatting.\r\n   * https://momentjs.com/docs/#/parsing/string-format/\r\n   *\r\n   * @return Returns a new dataframe with a particular named column converted from values to strings.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const result = df.toStrings(\"MyDateColumn\", \"YYYY-MM-DD\");\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const result = df.toStrings(\"MyFloatColumn\", \"0.00\");\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.toStrings = function (columnNames, formatString) {\n    if (isObject(columnNames)) {\n      try {\n        for (var _a = __values(Object.keys(columnNames)), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var columnName = _b.value;\n          if (!isString(columnNames[columnName])) throw new Error(\"Expected values of 'columnNames' parameter to be strings when a format spec is passed in.\");\n        }\n      } catch (e_46_1) {\n        e_46 = {\n          error: e_46_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_46) throw e_46.error;\n        }\n      }\n\n      if (!isUndefined(formatString)) throw new Error(\"Optional 'formatString' parameter to 'DataFrame.toStrings' should not be set when passing in a format spec.\");\n    } else {\n      if (!isArray(columnNames)) {\n        if (!isString(columnNames)) throw new Error(\"Expected 'columnNames' parameter to 'DataFrame.toStrings' to be a string, array of strings or format spec that specifes which columns should be converted to strings.\");\n      }\n\n      if (formatString) {\n        if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to 'DataFrame.toStrings' to be a string (if specified).\");\n      }\n    }\n\n    if (isObject(columnNames)) {\n      var working = this;\n\n      try {\n        for (var _d = __values(Object.keys(columnNames)), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var columnName = _e.value;\n          working = working.toStrings(columnName, formatString);\n        }\n      } catch (e_47_1) {\n        e_47 = {\n          error: e_47_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n        } finally {\n          if (e_47) throw e_47.error;\n        }\n      }\n\n      return working;\n    } else if (isArray(columnNames)) {\n      var working = this;\n\n      try {\n        for (var columnNames_9 = __values(columnNames), columnNames_9_1 = columnNames_9.next(); !columnNames_9_1.done; columnNames_9_1 = columnNames_9.next()) {\n          var columnName = columnNames_9_1.value;\n          var columnFormatString = columnNames[columnName];\n          working = working.toStrings(columnName, columnFormatString);\n        }\n      } catch (e_48_1) {\n        e_48 = {\n          error: e_48_1\n        };\n      } finally {\n        try {\n          if (columnNames_9_1 && !columnNames_9_1.done && (_g = columnNames_9.return)) _g.call(columnNames_9);\n        } finally {\n          if (e_48) throw e_48.error;\n        }\n      }\n\n      return working;\n    } else {\n      var singleColumnName = columnNames;\n      return this.withSeries(singleColumnName, this.getSeries(singleColumnName).toStrings(formatString));\n    }\n\n    var e_46, _c, e_47, _f, e_48, _g;\n  };\n  /**\r\n   * Produces a new dataframe with all string values truncated to the requested maximum length.\r\n   *\r\n   * @param maxLength The maximum length of the string values after truncation.\r\n   *\r\n   * @return Returns a new dataframe with all strings truncated to the specified maximum length.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Truncate all string columns to 100 characters maximum.\r\n   * const truncatedDf = df.truncateString(100);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.truncateStrings = function (maxLength) {\n    if (!isNumber(maxLength)) throw new Error(\"Expected 'maxLength' parameter to 'truncateStrings' to be an integer.\");\n    return this.select(function (row) {\n      var output = {};\n\n      try {\n        for (var _a = __values(Object.keys(row)), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var key = _b.value;\n          var value = row[key];\n\n          if (isString(value)) {\n            output[key] = value.substring(0, maxLength);\n          } else {\n            output[key] = value;\n          }\n        }\n      } catch (e_49_1) {\n        e_49 = {\n          error: e_49_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_49) throw e_49.error;\n        }\n      }\n\n      return output;\n\n      var e_49, _c;\n    });\n  };\n  /**\r\n   * Produces a new dataframe with all number values rounded to the specified number of places.\r\n   *\r\n   * @param numDecimalPlaces The number of decimal places, defaults to 2.\r\n   *\r\n   * @returns Returns a new dataframe with all number values rounded to the specified number of places.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = ... your data frame ...\r\n   * const rounded = df.round(); // Round numbers to two decimal places.\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = ... your data frame ...\r\n   * const rounded = df.round(3); // Round numbers to three decimal places.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.round = function (numDecimalPlaces) {\n    if (numDecimalPlaces !== undefined) {\n      if (!isNumber(numDecimalPlaces)) {\n        throw new Error(\"Expected 'numDecimalPlaces' parameter to 'DataFrame.round' to be a number.\");\n      }\n    } else {\n      numDecimalPlaces = 2; // Default to two decimal places.\n    }\n\n    return this.select(function (row) {\n      var output = {};\n\n      try {\n        for (var _a = __values(Object.keys(row)), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var key = _b.value;\n          var value = row[key];\n\n          if (isNumber(value)) {\n            output[key] = parseFloat(value.toFixed(numDecimalPlaces));\n          } else {\n            output[key] = value;\n          }\n        }\n      } catch (e_50_1) {\n        e_50 = {\n          error: e_50_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_50) throw e_50.error;\n        }\n      }\n\n      return output;\n\n      var e_50, _c;\n    });\n  };\n  /**\r\n   * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.\r\n   *\r\n   * @return Returns a dataframe that has been 'baked', all lazy evaluation has completed.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const baked = df.bake();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.bake = function () {\n    if (this.getContent().isBaked) {\n      // Already baked.\n      return this;\n    }\n\n    return new DataFrame({\n      columnNames: this.getColumnNames(),\n      values: this.toArray(),\n      pairs: this.toPairs(),\n      baked: true\n    });\n  };\n  /**\r\n   * Gets a new dataframe in reverse order.\r\n   *\r\n   * @return Returns a new dataframe that is the reverse of the input.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const reversedDf = df.reverse();\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.reverse = function () {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: content.columnNames,\n        values: new ReverseIterable(content.values),\n        index: new ReverseIterable(content.index),\n        pairs: new ReverseIterable(content.pairs)\n      };\n    });\n  };\n  /**\r\n   * Returns only the set of rows in the dataframe that are distinct according to some criteria.\r\n   * This can be used to remove duplicate rows from the dataframe.\r\n   *\r\n   * @param selector User-defined selector function that specifies the criteria used to make comparisons for duplicate rows.\r\n   *\r\n   * @return Returns a dataframe containing only unique values as determined by the 'selector' function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Remove duplicate rows by customer id. Will return only a single row per customer.\r\n   * const distinctCustomers = salesDf.distinct(sale => sale.CustomerId);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.distinct = function (selector) {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var content = _this.getContent();\n\n      return {\n        columnNames: content.columnNames,\n        values: new DistinctIterable(content.values, selector),\n        pairs: new DistinctIterable(content.pairs, function (pair) {\n          return selector && selector(pair[1]) || pair[1];\n        })\n      };\n    });\n  };\n  /**\r\n   * Collects rows in the dataframe into a series of groups according to the user-defined selector function that defines the group for each row.\r\n   *\r\n   * @param selector User-defined selector function that defines the value to group by.\r\n   *\r\n   * @return Returns a {@link Series} of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const salesDf = ... product sales ...\r\n   * const salesByProduct = salesDf.groupBy(sale => sale.ProductId);\r\n   * for (const productSalesGroup of salesByProduct) {\r\n   *      // ... do something with each product group ...\r\n   *      const productId = productSalesGroup.first().ProductId;\r\n   *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\r\n   *      console.log(totalSalesForProduct);\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.groupBy = function (selector) {\n    var _this = this;\n\n    if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.groupBy' to be a selector function that determines the value to group the series by.\");\n    return new Series(function () {\n      var groups = []; // Each group, in order of discovery.\n\n      var groupMap = {}; // Group map, records groups by key.\n\n      var valueIndex = 0;\n\n      try {\n        for (var _a = __values(_this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var pair = _b.value;\n          var groupKey = selector(pair[1], valueIndex);\n          ++valueIndex;\n          var existingGroup = groupMap[groupKey];\n\n          if (existingGroup) {\n            existingGroup.push(pair);\n          } else {\n            var newGroup = [];\n            newGroup.push(pair);\n            groups.push(newGroup);\n            groupMap[groupKey] = newGroup;\n          }\n        }\n      } catch (e_51_1) {\n        e_51 = {\n          error: e_51_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_51) throw e_51.error;\n        }\n      }\n\n      return {\n        values: groups.map(function (group) {\n          return new DataFrame({\n            pairs: group\n          });\n        })\n      };\n\n      var e_51, _c;\n    });\n  };\n  /**\r\n   * Collects rows in the dataframe into a series of groups according to a user-defined selector function that identifies adjacent rows that should be in the same group.\r\n   *\r\n   * @param selector Optional selector that defines the value to group by.\r\n   *\r\n   * @return Returns a {@link Series} of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Some ultra simple stock trading strategy backtesting...\r\n   * const dailyStockPriceDf = ... daily stock price for a company ...\r\n   * const priceGroups  = dailyStockPriceDf.groupBy(day => day.close > day.movingAverage);\r\n   * for (const priceGroup of priceGroups) {\r\n   *      // ... do something with each stock price group ...\r\n   *\r\n   *      const firstDay = priceGroup.first();\r\n   *      if (firstDay.close > movingAverage) {\r\n   *          // This group of days has the stock price above its moving average.\r\n   *          // ... maybe enter a long trade here ...\r\n   *      }\r\n   *      else {\r\n   *          // This group of days has the stock price below its moving average.\r\n   *          // ... maybe enter a short trade here ...\r\n   *      }\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.groupSequentialBy = function (selector) {\n    if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.groupSequentialBy' to be a selector function that determines the value to group the series by.\");\n    } else {\n      selector = function selector(value) {\n        return value;\n      };\n    }\n\n    return this.variableWindow(function (a, b) {\n      return selector(a) === selector(b);\n    });\n  };\n  /**\r\n   * Concatenate multiple dataframes into a single dataframe.\r\n   *\r\n   * @param dataframes Array of dataframes to concatenate.\r\n   *\r\n   * @return Returns a single dataframe concatenated from multiple input dataframes.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df1 = ...\r\n   * const df2 = ...\r\n   * const df3 = ...\r\n   * const concatenatedDf = DataFrame.concat([df1, df2, df3]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfs = [... array of dataframes...];\r\n   * const concatenatedDf = DataFrame.concat(dfs);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.concat = function (dataframes) {\n    if (!isArray(dataframes)) throw new Error(\"Expected 'dataframes' parameter to 'DataFrame.concat' to be an array of dataframes.\");\n    return new DataFrame(function () {\n      var upcast = dataframes; // Upcast so that we can access private index, values and pairs.\n\n      var contents = upcast.map(function (dataframe) {\n        return dataframe.getContent();\n      });\n      var columnNames = [];\n\n      try {\n        for (var contents_1 = __values(contents), contents_1_1 = contents_1.next(); !contents_1_1.done; contents_1_1 = contents_1.next()) {\n          var content = contents_1_1.value;\n\n          try {\n            for (var _a = __values(content.columnNames), _b = _a.next(); !_b.done; _b = _a.next()) {\n              var columnName = _b.value;\n              columnNames.push(columnName);\n            }\n          } catch (e_52_1) {\n            e_52 = {\n              error: e_52_1\n            };\n          } finally {\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_52) throw e_52.error;\n            }\n          }\n        }\n      } catch (e_53_1) {\n        e_53 = {\n          error: e_53_1\n        };\n      } finally {\n        try {\n          if (contents_1_1 && !contents_1_1.done && (_d = contents_1.return)) _d.call(contents_1);\n        } finally {\n          if (e_53) throw e_53.error;\n        }\n      }\n\n      columnNames = makeDistinct(columnNames);\n      return {\n        columnNames: columnNames,\n        values: new ConcatIterable(contents.map(function (content) {\n          return content.values;\n        })),\n        pairs: new ConcatIterable(contents.map(function (content) {\n          return content.pairs;\n        }))\n      };\n\n      var e_53, _d, e_52, _c;\n    });\n  };\n  /**\r\n   * Concatenate multiple other dataframes onto this dataframe.\r\n   *\r\n   * @param dataframes Multiple arguments. Each can be either a dataframe or an array of dataframes.\r\n   *\r\n   * @return Returns a single dataframes concatenated from multiple input dataframes.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const concatenatedDf = dfA.concat(dfB);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const concatenatedDf = dfA.concat(dfB, dfC);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const concatenatedDf = dfA.concat([dfB, dfC]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const concatenatedDf = dfA.concat(dfB, [dfC, dfD]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const otherDfs = [... array of dataframes...];\r\n   * const concatenatedDf = dfA.concat(otherDfs);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.concat = function () {\n    var dataframes = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      dataframes[_i] = arguments[_i];\n    }\n\n    var concatInput = [this];\n\n    try {\n      for (var dataframes_1 = __values(dataframes), dataframes_1_1 = dataframes_1.next(); !dataframes_1_1.done; dataframes_1_1 = dataframes_1.next()) {\n        var input = dataframes_1_1.value;\n\n        if (isArray(input)) {\n          try {\n            for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {\n              var subInput = input_1_1.value;\n              concatInput.push(subInput);\n            }\n          } catch (e_54_1) {\n            e_54 = {\n              error: e_54_1\n            };\n          } finally {\n            try {\n              if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);\n            } finally {\n              if (e_54) throw e_54.error;\n            }\n          }\n        } else {\n          concatInput.push(input);\n        }\n      }\n    } catch (e_55_1) {\n      e_55 = {\n        error: e_55_1\n      };\n    } finally {\n      try {\n        if (dataframes_1_1 && !dataframes_1_1.done && (_b = dataframes_1.return)) _b.call(dataframes_1);\n      } finally {\n        if (e_55) throw e_55.error;\n      }\n    }\n\n    return DataFrame.concat(concatInput);\n\n    var e_55, _b, e_54, _a;\n  };\n  /**\r\n  * Zip (or merge) together multiple dataframes to create a new dataframe.\r\n  * Preserves the index of the first dataframe.\r\n  *\r\n  * @param input An iterable of datafames to be zipped.\r\n  * @param zipper User-defined zipper function that merges rows. It produces rows for the new dataframe based-on rows from the input dataframes.\r\n  *\r\n  * @return Returns a single dataframe zipped (or merged) from multiple input dataframes.\r\n  *\r\n  * @example\r\n  * <pre>\r\n  *\r\n  * function produceNewRow (inputRows) {\r\n  *       const outputRow = {\r\n  *           // Produce output row based on the contents of the input rows.\r\n  *       };\r\n  *       return outputRow;\r\n  * }\r\n  *\r\n  * const inputDfs = [... array of input dataframes ...];\r\n  * const zippedDf = DataFrame.zip(inputDfs, produceNewRow);\r\n  *\r\n  * </pre>\r\n  *\r\n  * @example\r\n  * <pre>\r\n  *\r\n  * function produceNewRow (inputRows) {\r\n  *       const outputRow = {\r\n  *           // Produce output row based on the contents of the input rows.\r\n  *       };\r\n  *       return outputRow;\r\n  * }\r\n  *\r\n  * const dfA = new DataFrame([ { Value: 10 }, { Value: 20 }, { Value: 30 }]);\r\n  * const dfB = new DataFrame([ { Value: 100 }, { Value: 200 }, { Value: 300 }]);\r\n  * const zippedDf = DataFrame.zip([dfA, dfB], produceNewRow);\r\n  * </pre>\r\n  */\n\n\n  DataFrame.zip = function (dataframes, zipper) {\n    var input = Array.from(dataframes);\n\n    if (input.length === 0) {\n      return new DataFrame();\n    }\n\n    var firstSeries = input[0];\n\n    if (firstSeries.none()) {\n      return new DataFrame();\n    }\n\n    return new DataFrame(function () {\n      var firstSeriesUpCast = firstSeries;\n      var upcast = input; // Upcast so that we can access private index, values and pairs.\n\n      return {\n        index: firstSeriesUpCast.getContent().index,\n        values: new ZipIterable(upcast.map(function (s) {\n          return s.getContent().values;\n        }), zipper)\n      };\n    });\n  };\n\n  DataFrame.prototype.zip = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var selector = args[args.length - 1];\n    var input = [this].concat(args.slice(0, args.length - 1));\n    return DataFrame.zip(input, function (values) {\n      return selector.apply(void 0, __spread(values));\n    });\n  };\n  /**\r\n   * Sorts the dataframe in ascending order by a value defined by the user-defined selector function.\r\n   *\r\n   * @param selector User-defined selector function that selects the value to sort by.\r\n   *\r\n   * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Order sales by amount from least to most.\r\n   * const orderedDf = salesDf.orderBy(sale => sale.Amount);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.orderBy = function (selector) {\n    var content = this.getContent();\n    return new OrderedDataFrame({\n      columnNames: content.columnNames,\n      values: content.values,\n      pairs: content.pairs,\n      selector: selector,\n      direction: Direction.Ascending,\n      parent: null\n    });\n  };\n  /**\r\n   * Sorts the dataframe in descending order by a value defined by the user-defined selector function.\r\n   *\r\n   * @param selector User-defined selector function that selects the value to sort by.\r\n   *\r\n   * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Order sales by amount from most to least\r\n   * const orderedDf = salesDf.orderByDescending(sale => sale.Amount);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.orderByDescending = function (selector) {\n    var content = this.getContent();\n    return new OrderedDataFrame({\n      columnNames: content.columnNames,\n      values: content.values,\n      pairs: content.pairs,\n      selector: selector,\n      direction: Direction.Descending,\n      parent: null\n    });\n  };\n  /**\r\n   * Creates a new dataframe by merging two input dataframes.\r\n   * The resulting dataframe contains the union of rows from the two input dataframes.\r\n   * These are the unique combination of rows in both dataframe.\r\n   * This is basically a concatenation and then elimination of duplicates.\r\n   *\r\n   * @param other The other dataframes to merge.\r\n   * @param selector Optional user-defined selector function that selects the value to compare to determine distinctness.\r\n   *\r\n   * @return Returns the union of the two dataframes.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfA = ...\r\n   * const dfB = ...\r\n   * const merged = dfA.union(dfB);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Merge two sets of customer records that may contain the same\r\n   * // customer record in each set. This is basically a concatenation\r\n   * // of the dataframes and then an elimination of any duplicate records\r\n   * // that result.\r\n   * const customerRecordsA = ...\r\n   * const customerRecordsB = ...\r\n   * const mergedCustomerRecords = customerRecordsA.union(\r\n   *      customerRecordsB,\r\n   *      customerRecord => customerRecord.CustomerId\r\n   * );\r\n   * </pre>\r\n   *\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Note that you can achieve the exact same result as the previous\r\n   * // example by doing a {@link DataFrame.concat) and {@link DataFrame.distinct}\r\n   * // of the dataframes and then an elimination of any duplicate records\r\n   * // that result.\r\n   * const customerRecordsA = ...\r\n   * const customerRecordsB = ...\r\n   * const mergedCustomerRecords = customerRecordsA\r\n   *      .concat(customerRecordsB)\r\n   *      .distinct(customerRecord => customerRecord.CustomerId);\r\n   * </pre>\r\n   *\r\n   */\n\n\n  DataFrame.prototype.union = function (other, selector) {\n    if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected optional 'selector' parameter to 'DataFrame.union' to be a selector function.\");\n    }\n\n    return this.concat(other).distinct(selector);\n  };\n  /**\r\n   * Creates a new dataframe by merging two input dataframes.\r\n   * The resulting dataframe contains the intersection of rows from the two input dataframes.\r\n   * These are only the rows that appear in both dataframes.\r\n   *\r\n   * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\r\n   * @param outerSelector Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\r\n   * @param innerSelector Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\r\n   *\r\n   * @return Returns a new dataframe that contains the intersection of rows from the two input dataframes.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfA = ...\r\n   * const dfB = ...\r\n   * const mergedDf = dfA.intersection(dfB);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Merge two sets of customer records to find only the\r\n   * // customers that appears in both.\r\n   * const customerRecordsA = ...\r\n   * const customerRecordsB = ...\r\n   * const intersectionOfCustomerRecords = customerRecordsA.intersection(\r\n   *      customerRecordsB,\r\n   *      customerRecord => customerRecord.CustomerId\r\n   * );\r\n   * </pre>\r\n   * */\n\n\n  DataFrame.prototype.intersection = function (inner, outerSelector, innerSelector) {\n    if (outerSelector) {\n      if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'DataFrame.intersection' to be a function.\");\n    } else {\n      outerSelector = function outerSelector(value) {\n        return value;\n      };\n    }\n\n    if (innerSelector) {\n      if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'DataFrame.intersection' to be a function.\");\n    } else {\n      innerSelector = function innerSelector(value) {\n        return value;\n      };\n    }\n\n    var outer = this;\n    return outer.where(function (outerValue) {\n      var outerKey = outerSelector(outerValue);\n      return inner.where(function (innerValue) {\n        return outerKey === innerSelector(innerValue);\n      }).any();\n    });\n  };\n  /**\r\n   * Creates a new dataframe by merging two input dataframes.\r\n   * The resulting dataframe contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\r\n   * This is essentially subtracting the rows from the 2nd dataframe from the 1st and creating a new dataframe with the remaining rows.\r\n   *\r\n   * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\r\n   * @param outerSelector Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\r\n   * @param innerSelector Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\r\n   *\r\n   * @return Returns a new dataframe that contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dfA = ...\r\n   * const dfB = ...\r\n   * const remainingDf = dfA.except(dfB);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Find the list of customers haven't bought anything recently.\r\n   * const allCustomers = ... list of all customers ...\r\n   * const recentCustomers = ... list of customers who have purchased recently ...\r\n   * const remainingCustomers = allCustomers.except(\r\n   *      recentCustomers,\r\n   *      customerRecord => customerRecord.CustomerId\r\n   * );\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.except = function (inner, outerSelector, innerSelector) {\n    if (outerSelector) {\n      if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'DataFrame.except' to be a function.\");\n    } else {\n      outerSelector = function outerSelector(value) {\n        return value;\n      };\n    }\n\n    if (innerSelector) {\n      if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'DataFrame.except' to be a function.\");\n    } else {\n      innerSelector = function innerSelector(value) {\n        return value;\n      };\n    }\n\n    var outer = this;\n    return outer.where(function (outerValue) {\n      var outerKey = outerSelector(outerValue);\n      return inner.where(function (innerValue) {\n        return outerKey === innerSelector(innerValue);\n      }).none();\n    });\n  };\n  /**\r\n    * Creates a new dataframe by merging two input dataframes.\r\n    * The resulting dataframe contains only those rows that have matching keys in both input dataframes.\r\n    *\r\n    * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n    * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n    * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n    * @param resultSelector User-defined function that merges outer and inner values.\r\n    *\r\n    * @return Returns the new merged dataframe.\r\n    *\r\n    * @example\r\n    * <pre>\r\n    *\r\n    * // Join together two sets of customers to find those\r\n    * // that have bought both product A and product B.\r\n    * const customerWhoBoughtProductA = ...\r\n    * const customerWhoBoughtProductB = ...\r\n    * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\r\n    *          customerWhoBoughtProductB,\r\n    *          customerA => customerA.CustomerId, // Join key.\r\n    *          customerB => customerB.CustomerId, // Join key.\r\n    *          (customerA, customerB) => {\r\n    *              return {\r\n    *                  // ... merge the results ...\r\n    *              };\r\n    *          }\r\n    *      );\r\n    * </pre>\r\n    */\n\n\n  DataFrame.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector) {\n    if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.join' to be a selector function.\");\n    if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.join' to be a selector function.\");\n    if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.join' to be a selector function.\");\n    var outer = this;\n    return new DataFrame(function () {\n      var innerMap = inner.groupBy(innerKeySelector).toObject(function (group) {\n        return innerKeySelector(group.first());\n      }, function (group) {\n        return group;\n      });\n      var outerContent = outer.getContent();\n      var output = [];\n\n      try {\n        for (var outer_1 = __values(outer), outer_1_1 = outer_1.next(); !outer_1_1.done; outer_1_1 = outer_1.next()) {\n          var outerValue = outer_1_1.value;\n          var outerKey = outerKeySelector(outerValue);\n          var innerGroup = innerMap[outerKey];\n\n          if (innerGroup) {\n            try {\n              for (var innerGroup_1 = __values(innerGroup), innerGroup_1_1 = innerGroup_1.next(); !innerGroup_1_1.done; innerGroup_1_1 = innerGroup_1.next()) {\n                var innerValue = innerGroup_1_1.value;\n                output.push(resultSelector(outerValue, innerValue));\n              }\n            } catch (e_56_1) {\n              e_56 = {\n                error: e_56_1\n              };\n            } finally {\n              try {\n                if (innerGroup_1_1 && !innerGroup_1_1.done && (_a = innerGroup_1.return)) _a.call(innerGroup_1);\n              } finally {\n                if (e_56) throw e_56.error;\n              }\n            }\n          }\n        }\n      } catch (e_57_1) {\n        e_57 = {\n          error: e_57_1\n        };\n      } finally {\n        try {\n          if (outer_1_1 && !outer_1_1.done && (_b = outer_1.return)) _b.call(outer_1);\n        } finally {\n          if (e_57) throw e_57.error;\n        }\n      }\n\n      return {\n        values: output\n      };\n\n      var e_57, _b, e_56, _a;\n    });\n  };\n  /**\r\n   * Creates a new dataframe by merging two input dataframes.\r\n   * The resulting dataframe contains only those rows that are only present in one or the other of the dataframes, or both.\r\n   *\r\n   * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n   * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n   * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n   * @param resultSelector User-defined function that merges outer and inner values.\r\n   *\r\n   * Implementation from here:\r\n   *\r\n   * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n   *\r\n   * @return Returns the new merged dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Join together two sets of customers to find those\r\n   * // that have bought either product A or product B, or both.\r\n   * const customerWhoBoughtProductA = ...\r\n   * const customerWhoBoughtProductB = ...\r\n   * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\r\n   *          customerWhoBoughtProductB,\r\n   *          customerA => customerA.CustomerId, // Join key.\r\n   *          customerB => customerB.CustomerId, // Join key.\r\n   *          (customerA, customerB) => {\r\n   *              return {\r\n   *                  // ... merge the results ...\r\n   *              };\r\n   *          }\r\n   *      );\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.joinOuter = function (inner, outerKeySelector, innerKeySelector, resultSelector) {\n    if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.joinOuter' to be a selector function.\");\n    if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.joinOuter' to be a selector function.\");\n    if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.joinOuter' to be a selector function.\"); // Get the results in the outer that are not in the inner.\n\n    var outer = this;\n    var outerResult = outer.except(inner, outerKeySelector, innerKeySelector).select(function (outer) {\n      return resultSelector(outer, null);\n    }).resetIndex(); // Get the results in the inner that are not in the outer.\n\n    var innerResult = inner.except(outer, innerKeySelector, outerKeySelector).select(function (inner) {\n      return resultSelector(null, inner);\n    }).resetIndex(); // Get the intersection of results between inner and outer.\n\n    var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);\n    return outerResult.concat(intersectionResults).concat(innerResult).resetIndex();\n  };\n  /**\r\n   * Creates a new dataframe by merging two input dataframes.\r\n   * The resulting dataframe contains only those rows that present either in both dataframes or only in the outer (left) dataframe.\r\n   *\r\n   * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n   * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n   * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n   * @param resultSelector User-defined function that merges outer and inner values.\r\n   *\r\n   * Implementation from here:\r\n   *\r\n   * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n   *\r\n   * @return Returns the new merged dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Join together two sets of customers to find those\r\n   * // that have bought either just product A or both product A and product B.\r\n   * const customerWhoBoughtProductA = ...\r\n   * const customerWhoBoughtProductB = ...\r\n   * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\r\n   *          customerWhoBoughtProductB,\r\n   *          customerA => customerA.CustomerId, // Join key.\r\n   *          customerB => customerB.CustomerId, // Join key.\r\n   *          (customerA, customerB) => {\r\n   *              return {\r\n   *                  // ... merge the results ...\r\n   *              };\r\n   *          }\r\n   *      );\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.joinOuterLeft = function (inner, outerKeySelector, innerKeySelector, resultSelector) {\n    if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.\");\n    if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.\");\n    if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.\"); // Get the results in the outer that are not in the inner.\n\n    var outer = this;\n    var outerResult = outer.except(inner, outerKeySelector, innerKeySelector).select(function (outer) {\n      return resultSelector(outer, null);\n    }).resetIndex(); // Get the intersection of results between inner and outer.\n\n    var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);\n    return outerResult.concat(intersectionResults).resetIndex();\n  };\n  /**\r\n   * Creates a new dataframe by merging two input dataframes.\r\n   * The resulting dataframe contains only those rows that present either in both dataframes or only in the inner (right) dataframe.\r\n   *\r\n   * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n   * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n   * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n   * @param resultSelector User-defined function that merges outer and inner values.\r\n   *\r\n   * Implementation from here:\r\n   *\r\n   * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n   *\r\n   * @return Returns the new merged dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Join together two sets of customers to find those\r\n   * // that have bought either just product B or both product A and product B.\r\n   * const customerWhoBoughtProductA = ...\r\n   * const customerWhoBoughtProductB = ...\r\n   * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\r\n   *          customerWhoBoughtProductB,\r\n   *          customerA => customerA.CustomerId, // Join key.\r\n   *          customerB => customerB.CustomerId, // Join key.\r\n   *          (customerA, customerB) => {\r\n   *              return {\r\n   *                  // ... merge the results ...\r\n   *              };\r\n   *          }\r\n   *      );\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.joinOuterRight = function (inner, outerKeySelector, innerKeySelector, resultSelector) {\n    if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.\");\n    if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.\");\n    if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.\"); // Get the results in the inner that are not in the outer.\n\n    var outer = this;\n    var innerResult = inner.except(outer, innerKeySelector, outerKeySelector).select(function (inner) {\n      return resultSelector(null, inner);\n    }).resetIndex(); // Get the intersection of results between inner and outer.\n\n    var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);\n    return intersectionResults.concat(innerResult).resetIndex();\n  };\n  /**\r\n   * Produces a summary of dataframe. A bit like the 'aggregate' function but much simpler.\r\n   *\r\n   * @param spec Optional parameter that specifies which columns to aggregate and how to aggregate them. Leave this out to produce a default summary of all columns.\r\n   *\r\n   * @returns A object with fields that summary the values in the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = df.summarize();\r\n   * console.log(summary);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = df.summarize({ // Summarize using pre-defined functions.\r\n   *      Column1: Series.sum,\r\n   *      Column2: Series.average,\r\n   *      Column3: Series.count,\r\n   * });\r\n   * console.log(summary);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = df.summarize({ // Summarize using custom functions.\r\n   *      Column1: series => series.sum(),\r\n   *      Column2: series => series.std(),\r\n   *      ColumnN: whateverFunctionYouWant,\r\n   * });\r\n   * console.log(summary);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = df.summarize({ // Multiple output fields per column.\r\n   *      Column1: {\r\n   *          OutputField1: Series.sum,\r\n   *          OutputField2: Series.average,\r\n   *      },\r\n   *      Column2: {\r\n   *          OutputField3: series => series.sum(),\r\n   *          OutputFieldN: whateverFunctionYouWant,\r\n   *      },\r\n   * });\r\n   * console.log(summary);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.summarize = function (spec) {\n    if (spec && !isObject(spec)) {\n      throw new Error(\"Expected 'spec' parameter to 'DataFrame.summarize' to be an object that specifies how to summarize the dataframe.\");\n    }\n\n    if (!spec) {\n      spec = {};\n\n      try {\n        for (var _a = __values(this.getColumnNames()), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var columnName = _b.value;\n          var columnSpec = {};\n          columnSpec[columnName + \"_sum\"] = Series.sum;\n          columnSpec[columnName + \"_average\"] = Series.average;\n          columnSpec[columnName + \"_count\"] = Series.count;\n          spec[columnName] = columnSpec;\n        }\n      } catch (e_58_1) {\n        e_58 = {\n          error: e_58_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_58) throw e_58.error;\n        }\n      }\n    }\n\n    try {\n      for (var _d = __values(Object.keys(spec)), _e = _d.next(); !_e.done; _e = _d.next()) {\n        var inputColumnName = _e.value;\n        var inputSpec = spec[inputColumnName];\n\n        if (isFunction(inputSpec)) {\n          spec[inputColumnName] = {}; // Expand the spec.\n\n          spec[inputColumnName][inputColumnName] = inputSpec;\n        }\n      }\n    } catch (e_59_1) {\n      e_59 = {\n        error: e_59_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n      } finally {\n        if (e_59) throw e_59.error;\n      }\n    }\n\n    var inputColumnNames = Object.keys(spec);\n    var outputFieldsMap = toMap(inputColumnNames, function (valueColumnName) {\n      return valueColumnName;\n    }, function (inputColumnName) {\n      return Object.keys(spec[inputColumnName]);\n    });\n    var output = {};\n\n    try {\n      for (var inputColumnNames_3 = __values(inputColumnNames), inputColumnNames_3_1 = inputColumnNames_3.next(); !inputColumnNames_3_1.done; inputColumnNames_3_1 = inputColumnNames_3.next()) {\n        var inputColumnName = inputColumnNames_3_1.value;\n        var outputFieldNames = outputFieldsMap[inputColumnName];\n\n        try {\n          for (var outputFieldNames_1 = __values(outputFieldNames), outputFieldNames_1_1 = outputFieldNames_1.next(); !outputFieldNames_1_1.done; outputFieldNames_1_1 = outputFieldNames_1.next()) {\n            var outputFieldName = outputFieldNames_1_1.value;\n            var aggregatorFn = spec[inputColumnName][outputFieldName];\n            output[outputFieldName] = aggregatorFn(this.getSeries(inputColumnName));\n          }\n        } catch (e_60_1) {\n          e_60 = {\n            error: e_60_1\n          };\n        } finally {\n          try {\n            if (outputFieldNames_1_1 && !outputFieldNames_1_1.done && (_g = outputFieldNames_1.return)) _g.call(outputFieldNames_1);\n          } finally {\n            if (e_60) throw e_60.error;\n          }\n        }\n      }\n    } catch (e_61_1) {\n      e_61 = {\n        error: e_61_1\n      };\n    } finally {\n      try {\n        if (inputColumnNames_3_1 && !inputColumnNames_3_1.done && (_h = inputColumnNames_3.return)) _h.call(inputColumnNames_3);\n      } finally {\n        if (e_61) throw e_61.error;\n      }\n    }\n\n    return output;\n\n    var e_58, _c, e_59, _f, e_61, _h, e_60, _g;\n  };\n  /**\r\n   * Reshape (or pivot) a dataframe based on column values.\r\n   * This is a powerful function that combines grouping, aggregation and sorting.\r\n   *\r\n   * @param columnOrColumns Column name whose values make the new DataFrame's columns.\r\n   * @param valueColumnNameOrSpec Column name or column spec that defines the columns whose values should be aggregated.\r\n   * @param aggregator Optional function used to aggregate pivotted vales.\r\n   *\r\n   * @return Returns a new dataframe that has been pivoted based on a particular column's values.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Simplest example.\r\n   * // Group by the values in 'PivotColumn'.\r\n   * // The unique set of values in 'PivotColumn' becomes the columns in the resulting dataframe.\r\n   * // The column 'ValueColumn' is aggregated for each group and this becomes the\r\n   * // values in the new output column.\r\n   * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Multiple input column example.\r\n   * // Similar to the previous example except now we are aggregating multiple input columns.\r\n   * // Each group has the average computed for 'ValueColumnA' and the sum for 'ValueColumnB'.\r\n   * const pivottedDf = df.pivot(\"PivotColumn\", {\r\n   *      ValueColumnA: aValues => aValues.average(),\r\n   *      ValueColumnB:  bValues => bValues.sum(),\r\n   * });\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Multiple output column example.\r\n   * // Similar to the previous example except now we are doing multiple aggregations for each input column.\r\n   * // The example produces an output dataframe with columns OutputColumnA, B, C and D.\r\n   * // OutputColumnA/B are the sum and average of ValueColumnA across each group as defined by PivotColumn.\r\n   * // OutputColumnC/D are the sum and average of ValueColumnB across each group as defined by PivotColumn.\r\n   * const pivottedDf = df.pivot(\"PivotColumn\", {\r\n   *      ValueColumnA: {\r\n   *          OutputColumnA: aValues => aValues.sum(),\r\n   *          OutputColumnB: aValues => aValues.average(),\r\n   *      },\r\n   *      ValueColumnB: {\r\n   *          OutputColumnC: bValues => bValues.sum(),\r\n   *          OutputColumnD: bValues => bValues.average(),\r\n   *      },\r\n   * });\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Full multi-column example.\r\n   * // Similar to the previous example now we are pivotting on multiple columns.\r\n   * // We now group by the 'PivotColumnA' and then by 'PivotColumnB', effectively creating a\r\n   * // multi-level group.\r\n   * const pivottedDf = df.pivot([\"PivotColumnA\", \"PivotColumnB\" ], {\r\n   *      ValueColumnA: aValues => aValues.average(),\r\n   *      ValueColumnB:  bValues => bValues.sum(),\r\n   * });\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // To help understand the pivot function, let's look at what it does internally.\r\n   * // Take the simplest example:\r\n   * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\r\n   *\r\n   * // If we expand out the internals of the pivot function, it will look something like this:\r\n   * const pivottedDf = df.groupBy(row => row.PivotColumn)\r\n   *          .select(group => ({\r\n   *              PivotColumn: group.deflate(row => row.ValueColumn).average()\r\n   *          }))\r\n   *          .orderBy(row  => row.PivotColumn);\r\n   *\r\n   * // You can see that pivoting a dataframe is the same as grouping, aggregating and sorting it.\r\n   * // Does pivoting seem simpler now?\r\n   *\r\n   * // It gets more complicated than that of course, because the pivot function supports multi-level nested\r\n   * // grouping and aggregation of multiple columns. So a full expansion of the pivot function is rather complex.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.pivot = function (columnOrColumns, valueColumnNameOrSpec, aggregator) {\n    var columnNames;\n\n    if (isString(columnOrColumns)) {\n      columnNames = [columnOrColumns];\n    } else {\n      if (!isArray(columnOrColumns)) throw new Error(\"Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to be a string or an array of strings that identifies the column(s) whose values make the new DataFrame's columns.\");\n      columnNames = Array.from(columnOrColumns);\n      if (columnNames.length === 0) throw new Error(\"Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to contain at least one string.\");\n\n      try {\n        for (var columnNames_10 = __values(columnNames), columnNames_10_1 = columnNames_10.next(); !columnNames_10_1.done; columnNames_10_1 = columnNames_10.next()) {\n          var columnName = columnNames_10_1.value;\n          if (!isString(columnName)) throw new Error(\"Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to be an array of strings, each string identifies a column in the DataFrame on which to pivot.\");\n        }\n      } catch (e_62_1) {\n        e_62 = {\n          error: e_62_1\n        };\n      } finally {\n        try {\n          if (columnNames_10_1 && !columnNames_10_1.done && (_a = columnNames_10.return)) _a.call(columnNames_10);\n        } finally {\n          if (e_62) throw e_62.error;\n        }\n      }\n    }\n\n    var aggSpec;\n\n    if (!isObject(valueColumnNameOrSpec)) {\n      if (!isString(valueColumnNameOrSpec)) throw new Error(\"Expected 'value' parameter to 'DataFrame.pivot' to be a string that identifies the column whose values to aggregate or a column spec that defines which column contains the value ot aggregate and the ways to aggregate that value.\");\n      if (!isFunction(aggregator)) throw new Error(\"Expected 'aggregator' parameter to 'DataFrame.pivot' to be a function to aggregate pivoted values.\");\n      var aggColumnName = valueColumnNameOrSpec;\n      var outputSpec = {};\n      outputSpec[aggColumnName] = aggregator;\n      aggSpec = {};\n      aggSpec[aggColumnName] = outputSpec;\n    } else {\n      aggSpec = valueColumnNameOrSpec;\n\n      try {\n        for (var _b = __values(Object.keys(aggSpec)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var inputColumnName = _c.value;\n          var columnAggSpec = aggSpec[inputColumnName];\n\n          if (isFunction(columnAggSpec)) {\n            aggSpec[inputColumnName] = {}; // Expand the pivot spec.\n\n            aggSpec[inputColumnName][inputColumnName] = columnAggSpec;\n          }\n        }\n      } catch (e_63_1) {\n        e_63 = {\n          error: e_63_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_d = _b.return)) _d.call(_b);\n        } finally {\n          if (e_63) throw e_63.error;\n        }\n      }\n    }\n\n    var firstColumnName = columnNames[0];\n    var working = this.groupBy(function (row) {\n      return row[firstColumnName];\n    }).select(function (group) {\n      var output = {};\n      output[firstColumnName] = group.first()[firstColumnName];\n      output.src = group;\n      return output;\n    });\n\n    var _loop_1 = function _loop_1(columnNameIndex) {\n      var nextColumnName = columnNames[columnNameIndex];\n      working = working.selectMany(function (parentGroup) {\n        var src = parentGroup.src;\n        return src.groupBy(function (row) {\n          return row[nextColumnName];\n        }).select(function (subGroup) {\n          var output = Object.assign({}, parentGroup);\n          output[nextColumnName] = subGroup.first()[nextColumnName];\n          output.src = subGroup;\n          return output;\n        });\n      });\n    };\n\n    for (var columnNameIndex = 1; columnNameIndex < columnNames.length; ++columnNameIndex) {\n      _loop_1(columnNameIndex);\n    }\n\n    var valueColumnNames = Object.keys(aggSpec);\n    var outputColumnsMap = toMap(valueColumnNames, function (valueColumnName) {\n      return valueColumnName;\n    }, function (valueColumnName) {\n      return Object.keys(aggSpec[valueColumnName]);\n    });\n    var pivotted = working.inflate(function (row) {\n      var _loop_2 = function _loop_2(valueColumnName) {\n        var outputColumnNames = outputColumnsMap[valueColumnName];\n\n        try {\n          for (var outputColumnNames_1 = __values(outputColumnNames), outputColumnNames_1_1 = outputColumnNames_1.next(); !outputColumnNames_1_1.done; outputColumnNames_1_1 = outputColumnNames_1.next()) {\n            var outputColumName = outputColumnNames_1_1.value;\n            var aggregatorFn = aggSpec[valueColumnName][outputColumName];\n            row[outputColumName] = aggregatorFn(row.src.deflate(function (srcRow) {\n              return srcRow[valueColumnName];\n            }));\n          }\n        } catch (e_64_1) {\n          e_64 = {\n            error: e_64_1\n          };\n        } finally {\n          try {\n            if (outputColumnNames_1_1 && !outputColumnNames_1_1.done && (_a = outputColumnNames_1.return)) _a.call(outputColumnNames_1);\n          } finally {\n            if (e_64) throw e_64.error;\n          }\n        }\n\n        var e_64, _a;\n      };\n\n      try {\n        for (var valueColumnNames_1 = __values(valueColumnNames), valueColumnNames_1_1 = valueColumnNames_1.next(); !valueColumnNames_1_1.done; valueColumnNames_1_1 = valueColumnNames_1.next()) {\n          var valueColumnName = valueColumnNames_1_1.value;\n\n          _loop_2(valueColumnName);\n        }\n      } catch (e_65_1) {\n        e_65 = {\n          error: e_65_1\n        };\n      } finally {\n        try {\n          if (valueColumnNames_1_1 && !valueColumnNames_1_1.done && (_a = valueColumnNames_1.return)) _a.call(valueColumnNames_1);\n        } finally {\n          if (e_65) throw e_65.error;\n        }\n      }\n\n      delete row.src;\n      return row;\n\n      var e_65, _a;\n    });\n    var ordered = pivotted.orderBy(function (row) {\n      return row[firstColumnName];\n    });\n\n    var _loop_3 = function _loop_3(columnNameIndex) {\n      var nextColumnName = columnNames[columnNameIndex];\n      ordered = ordered.thenBy(function (row) {\n        return row[nextColumnName];\n      });\n    };\n\n    for (var columnNameIndex = 1; columnNameIndex < columnNames.length; ++columnNameIndex) {\n      _loop_3(columnNameIndex);\n    }\n\n    return ordered;\n\n    var e_62, _a, e_63, _d;\n  };\n  /**\r\n   * Unpivot a DataFrame from wide to long format, optionally leaving identifiers set.\r\n   * This is a powerful function that combines grouping, aggregation and sorting.\r\n   *\r\n   * @param idColumnOrColumns Column(s) to use as identifier variables.\r\n   * @param valueColumnOrColumns Column(s) to unpivot.\r\n   *\r\n   * @return Returns a new dataframe that has been unpivoted based on a particular column's values.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Use column in 'idColumnOrColumns' as the identity column.\r\n   * // The column name passed in 'valueColumnOrColumns' forms the 'variable' column\r\n   * // and the values are used to populate the 'value' column of the new dataframe.\r\n   * const moltenDf = df.melt(\"A\", \"B\");\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Multiple value columns example.\r\n   * // Similar to the previous example except now the variable column will constitute\r\n   * // of multiple values.\r\n   * const moltenDf = df.melt(\"A\", [\"B\", \"C\"]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Multiple identity and value columns example.\r\n   * const moltenDf = df.melt([\"A\", \"B\"], [\"C\", \"D\"]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.melt = function (idColumnOrColumns, valueColumnOrColumns) {\n    var idColumnNames;\n    var valueColumnNames;\n\n    if (isString(idColumnOrColumns)) {\n      idColumnNames = [idColumnOrColumns];\n    } else {\n      if (!isArray(idColumnOrColumns)) throw new Error(\"Expected 'idColumnOrColumns' parameter to 'DataFrame.melt' to be a string or an array of strings that identifies the column(s) whose values make the new DataFrame's identity columns.\");\n      idColumnNames = Array.from(idColumnOrColumns);\n\n      try {\n        for (var idColumnNames_1 = __values(idColumnNames), idColumnNames_1_1 = idColumnNames_1.next(); !idColumnNames_1_1.done; idColumnNames_1_1 = idColumnNames_1.next()) {\n          var columnName = idColumnNames_1_1.value;\n          if (!isString(columnName)) throw new Error(\"Expected 'idColumnOrColumns' parameter to 'DataFrame.melt' to be a string or an array of strings that identifies the column(s) whose values make the new DataFrame's identity columns.\");\n        }\n      } catch (e_66_1) {\n        e_66 = {\n          error: e_66_1\n        };\n      } finally {\n        try {\n          if (idColumnNames_1_1 && !idColumnNames_1_1.done && (_a = idColumnNames_1.return)) _a.call(idColumnNames_1);\n        } finally {\n          if (e_66) throw e_66.error;\n        }\n      }\n    }\n\n    if (isString(valueColumnOrColumns)) {\n      valueColumnNames = [valueColumnOrColumns];\n    } else {\n      if (!isArray(valueColumnOrColumns)) throw new Error(\"Expected 'valueColumnOrColumns' parameter to 'DataFrame.melt' to be a string or an array of strings that identifies the column(s) whose molten values make the new DataFrame's 'variable' and 'value' columns.\");\n      valueColumnNames = Array.from(valueColumnOrColumns);\n\n      try {\n        for (var valueColumnNames_2 = __values(valueColumnNames), valueColumnNames_2_1 = valueColumnNames_2.next(); !valueColumnNames_2_1.done; valueColumnNames_2_1 = valueColumnNames_2.next()) {\n          var columnName = valueColumnNames_2_1.value;\n          if (!isString(columnName)) throw new Error(\"Expected 'valueColumnOrColumns' parameter to 'DataFrame.melt' to be a string or an array of strings that identifies the column(s) whose molten values make the new DataFrame's 'variable' and 'value' columns.\");\n        }\n      } catch (e_67_1) {\n        e_67 = {\n          error: e_67_1\n        };\n      } finally {\n        try {\n          if (valueColumnNames_2_1 && !valueColumnNames_2_1.done && (_b = valueColumnNames_2.return)) _b.call(valueColumnNames_2);\n        } finally {\n          if (e_67) throw e_67.error;\n        }\n      }\n    }\n\n    var K = valueColumnNames.length;\n    var N = this.count();\n    var mdata = new DataFrame();\n    var original = this.subset(idColumnNames.concat(valueColumnNames));\n\n    try {\n      for (var idColumnNames_2 = __values(idColumnNames), idColumnNames_2_1 = idColumnNames_2.next(); !idColumnNames_2_1.done; idColumnNames_2_1 = idColumnNames_2.next()) {\n        var col = idColumnNames_2_1.value;\n        original = original.dropSeries(col);\n        var idData = this.getSeries(col);\n        var columnData_1 = new TileIterable(idData, K);\n        var columnSeries_1 = new Series(columnData_1);\n        mdata = mdata.withSeries(col, columnSeries_1);\n      }\n    } catch (e_68_1) {\n      e_68 = {\n        error: e_68_1\n      };\n    } finally {\n      try {\n        if (idColumnNames_2_1 && !idColumnNames_2_1.done && (_c = idColumnNames_2.return)) _c.call(idColumnNames_2);\n      } finally {\n        if (e_68) throw e_68.error;\n      }\n    }\n\n    var seriesArray = [];\n\n    try {\n      for (var _d = __values(original.getColumns()), _e = _d.next(); !_e.done; _e = _d.next()) {\n        var col = _e.value;\n        seriesArray.push(this.getSeries(col.name));\n      }\n    } catch (e_69_1) {\n      e_69 = {\n        error: e_69_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n      } finally {\n        if (e_69) throw e_69.error;\n      }\n    }\n\n    var columnData = new RavelIterable(seriesArray);\n    var columnSeries = new Series(columnData);\n    mdata = mdata.withSeries('value', columnSeries);\n    var valueColumnData = new RepeatIterable(valueColumnNames, N);\n    var valueColumnSeries = new Series(valueColumnData);\n    mdata = mdata.withSeries('variable', valueColumnSeries);\n    return mdata;\n\n    var e_66, _a, e_67, _b, e_68, _c, e_69, _f;\n  };\n  /**\r\n   * Insert a pair at the start of the dataframe.\r\n   * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the inserted pair.\r\n   *\r\n   * @param pair The pair to insert.\r\n   *\r\n   * @return Returns a new dataframe with the specified pair inserted.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const newIndex = ... index of the new row ...\r\n   * const newRow = ... the new data row to insert ...\r\n   * const insertedDf = df.insertPair([newIndex, newRows]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.insertPair = function (pair) {\n    if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'DataFrame.insertPair' to be an array.\");\n    if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'DataFrame.insertPair' to be an array with two elements. The first element is the index, the second is the value.\");\n    return new DataFrame({\n      pairs: [pair]\n    }).concat(this);\n  };\n  /**\r\n   * Append a pair to the end of a dataframe.\r\n   * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the appended pair.\r\n   *\r\n   * @param pair - The pair to append.\r\n   *\r\n   * @return Returns a new dataframe with the specified pair appended.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const newIndex = ... index of the new row ...\r\n   * const newRow = ... the new data row to append ...\r\n   * const appendedDf = df.appendPair([newIndex, newRows]);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.appendPair = function (pair) {\n    if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'DataFrame.appendPair' to be an array.\");\n    if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'DataFrame.appendPair' to be an array with two elements. The first element is the index, the second is the value.\");\n    return this.concat(new DataFrame({\n      pairs: [pair]\n    }));\n  };\n  /**\r\n   * Fill gaps in a dataframe.\r\n   *\r\n   * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.\r\n   * @param generator User-defined generator function that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.\r\n   *\r\n   * @return Returns a new dataframe with gaps filled in.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   *   var sequenceWithGaps = ...\r\n   *\r\n   *  // Predicate that determines if there is a gap.\r\n   *  var gapExists = (pairA, pairB) => {\r\n   *      // Returns true if there is a gap.\r\n   *      return true;\r\n   *  };\r\n   *\r\n   *  // Generator function that produces new rows to fill the game.\r\n   *  var gapFiller = (pairA, pairB) => {\r\n   *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\r\n   *      return [\r\n   *          newPair1,\r\n   *          newPair2,\r\n   *          newPair3,\r\n   *      ];\r\n   *  };\r\n   *\r\n   *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.fillGaps = function (comparer, generator) {\n    if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'DataFrame.fillGaps' to be a comparer function that compares two values and returns a boolean.\");\n    if (!isFunction(generator)) throw new Error(\"Expected 'generator' parameter to 'DataFrame.fillGaps' to be a generator function that takes two values and returns an array of generated pairs to span the gap.\");\n    return this.rollingWindow(2).selectMany(function (window) {\n      var pairs = window.toPairs();\n      var pairA = pairs[0];\n      var pairB = pairs[1];\n\n      if (!comparer(pairA, pairB)) {\n        return [pairA];\n      }\n\n      var generatedRows = generator(pairA, pairB);\n      if (!isArray(generatedRows)) throw new Error(\"Expected return from 'generator' parameter to 'DataFrame.fillGaps' to be an array of pairs, instead got a \" + typeof generatedRows);\n      return [pairA].concat(generatedRows);\n    }).withIndex(function (pair) {\n      return pair[0];\n    }).inflate(function (pair) {\n      return pair[1];\n    }).concat(this.tail(1));\n  };\n  /**\r\n   * Returns the specified default dataframe if the dataframe is empty.\r\n   *\r\n   * @param defaultDataFrame Default dataframe to return if the dataframe is empty.\r\n   *\r\n   * @return Returns 'defaultDataFrame' if the dataframe is empty.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const emptyDataFrame = new DataFrame();\r\n   * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\r\n   * expect(emptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(defaultDataFrame);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const nonEmptyDataFrame = new DataFrame([ { A: 100 }]);\r\n   * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\r\n   * expect(nonEmptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(nonEmptyDataFrame);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.defaultIfEmpty = function (defaultDataFrame) {\n    if (this.none()) {\n      if (defaultDataFrame instanceof DataFrame) {\n        return defaultDataFrame;\n      } else if (isArray(defaultDataFrame)) {\n        return new DataFrame(defaultDataFrame);\n      } else {\n        throw new Error(\"Expected 'defaultSequence' parameter to 'DataFrame.defaultIfEmpty' to be an array or a series.\");\n      }\n    } else {\n      return this;\n    }\n  };\n  /**\r\n   * Detect the the frequency of the types of the values in the dataframe.\r\n   * This is a good way to understand the shape of your data.\r\n   *\r\n   * @return Returns a dataframe with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\r\n   * const dataTypes = df.detectTypes();\r\n   * console.log(dataTypes.toString());\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.detectTypes = function () {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var typeFrequencies = _this.getColumns().selectMany(function (column) {\n        return column.series.detectTypes().select(function (typeFrequency) {\n          var output = Object.assign({}, typeFrequency);\n          output.Column = column.name;\n          return output;\n        });\n      });\n\n      return {\n        columnNames: [\"Type\", \"Frequency\", \"Column\"],\n        values: typeFrequencies\n      };\n    });\n  };\n  /**\r\n   * Detect the frequency of the values in the dataframe.\r\n   * This is a good way to understand the shape of your data.\r\n   *\r\n   * @return Returns a dataframe with rows that conform to {@link IValueFrequency} that describes the values contained in the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\r\n   * const dataValues = df.detectedValues();\r\n   * console.log(dataValues.toString());\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.detectValues = function () {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var valueFrequencies = _this.getColumns().selectMany(function (column) {\n        return column.series.detectValues().select(function (valueFrequency) {\n          var output = Object.assign({}, valueFrequency);\n          output.Column = column.name;\n          return output;\n        });\n      });\n\n      return {\n        columnNames: [\"Value\", \"Frequency\", \"Column\"],\n        values: valueFrequencies\n      };\n    });\n  };\n  /**\r\n   * Serialize the dataframe to the JSON data format.\r\n   *\r\n   * @return Returns a string in the JSON data format that represents the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const jsonData = df.toJSON();\r\n   * console.log(jsonData);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.toJSON = function () {\n    return JSON.stringify(this.toArray(), null, 4);\n  };\n  /**\r\n   * Serialize the dataframe to the JSON5 data format.\r\n   *\r\n   * @return Returns a string in the JSON5 data format that represents the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const jsonData = df.toJSON5();\r\n   * console.log(jsonData);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.toJSON5 = function () {\n    return JSON5.stringify(this.toArray(), null, 4);\n  };\n  /**\r\n   * Serialize the dataframe to the CSV data format.\r\n   *\r\n   * @param options Options for CSV output. The options object is passed directly to [PapaParse.unparse](https://www.papaparse.com/docs#unparse), please see [PapaParse docs for additional options](https://www.papaparse.com/docs#unparse-config-default).\r\n   *\r\n   * @return Returns a string in the CSV data format that represents the dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const csvData = df.toCSV();\r\n   * console.log(csvData);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const csvData = df.toCSV({ header: false });\r\n   * console.log(csvData);\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.toCSV = function (options) {\n    var headerLine = options === undefined || options.header === undefined || options.header ? [this.getColumnNames()] : [];\n    var rows = headerLine.concat(this.toRows());\n    return PapaParse.unparse(rows, options);\n  };\n  /**\r\n   * Serialize the dataframe to HTML.\r\n   *\r\n   * @return Returns a string in HTML format that represents the dataframe.\r\n   */\n\n\n  DataFrame.prototype.toHTML = function () {\n    var columNames = this.getColumnNames();\n    var header = columNames.map(function (columnName) {\n      return \"            <th>\" + columnName + \"</th>\";\n    }).join(\"\\n\");\n    var pairs = this.toPairs();\n    return '<table border=\"1\" class=\"dataframe\">\\n' + '    <thead>\\n' + '        <tr style=\"text-align: right;\">\\n' + '            <th></th>\\n' + header + '\\n' + '       </tr>\\n' + '    </thead>\\n' + '    <tbody>\\n' + pairs.map(function (pair) {\n      var index = pair[0];\n      var value = pair[1];\n      return '        <tr>\\n' + '            <th>' + index + '</th>\\n' + columNames.map(function (columName) {\n        return '            <td>' + value[columName] + '</td>';\n      }).join('\\n') + '\\n' + '        </tr>';\n    }).join('\\n') + '\\n' + '    </tbody>\\n' + '</table>';\n  };\n  /**\r\n   * Serialize the dataframe to an ordinary JavaScript data structure.\r\n   * The resulting data structure is suitable for further serialization to JSON and can be used to\r\n   * transmit a DataFrame and its internal structure over the wire.\r\n   * Use the {@link deserialize} function to later reconstitute the serialized dataframe.\r\n   *\r\n   * @return Returns a JavaScript data structure conforming to {@link ISerializedDataFrame} that represents the dataframe and its internal structure.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const jsDataStructure = df.serialize();\r\n   * const jsonData = JSON.stringify(jsDataStructure);\r\n   * console.log(jsonData);\r\n   * const deserializedJsDataStructure = JSON.parse(jsonData);\r\n   * const deserializedDf = DataFrame.deserialize(deserializedJsDataStructure); // Reconsituted.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.prototype.serialize = function () {\n    var rows = this.toArray(); // Bake the dataframe to an array.\n\n    var index = this.getIndex(); // Extract the index.\n\n    var indexValues = index.head(rows.length).toArray();\n    var columns = this.getColumns();\n    var serializedColumns = toMap(columns, function (column) {\n      return column.name;\n    }, function (column) {\n      return column.type;\n    });\n    var indexType = index.getType();\n\n    if (indexType === \"date\") {\n      indexValues = indexValues.map(function (index) {\n        return moment(index).toISOString();\n      }); // Manually serialize date value, they aren't supported directly by JSON.\n    }\n\n    var cloned = false;\n\n    try {\n      // Serialize date values.\n      for (var columns_1 = __values(columns), columns_1_1 = columns_1.next(); !columns_1_1.done; columns_1_1 = columns_1.next()) {\n        var column = columns_1_1.value;\n\n        if (column.type === \"date\") {\n          if (!cloned) {\n            rows = rows.map(function (row) {\n              return Object.assign({}, row);\n            }); // Clone so we don't modify any original data.\n\n            cloned = true;\n          }\n\n          try {\n            for (var rows_1 = __values(rows), rows_1_1 = rows_1.next(); !rows_1_1.done; rows_1_1 = rows_1.next()) {\n              var row = rows_1_1.value;\n              row[column.name] = moment(row[column.name]).toISOString(); // Manually serialize date value.\n            }\n          } catch (e_70_1) {\n            e_70 = {\n              error: e_70_1\n            };\n          } finally {\n            try {\n              if (rows_1_1 && !rows_1_1.done && (_a = rows_1.return)) _a.call(rows_1);\n            } finally {\n              if (e_70) throw e_70.error;\n            }\n          }\n        }\n      }\n    } catch (e_71_1) {\n      e_71 = {\n        error: e_71_1\n      };\n    } finally {\n      try {\n        if (columns_1_1 && !columns_1_1.done && (_b = columns_1.return)) _b.call(columns_1);\n      } finally {\n        if (e_71) throw e_71.error;\n      }\n    }\n\n    return {\n      columnOrder: this.getColumnNames(),\n      columns: serializedColumns,\n      index: {\n        type: indexType,\n        values: indexValues\n      },\n      values: rows\n    };\n\n    var e_71, _b, e_70, _a;\n  };\n  /**\r\n   * Deserialize the dataframe from an ordinary JavaScript data structure.\r\n   * Can reconstitute a dataframe that previously serialized with the {@link serialize} function.\r\n   * This can rebuilds the dataframe with the exact same internal structure after it has been transmitted over the wire.\r\n   *\r\n   * @param input The serialize JavaScript data structure for the dataframe.\r\n   *\r\n   * @return Returns the deserialized/reconstituted dataframe.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const jsDataStructure = df.serialize();\r\n   * const jsonData = JSON.stringify(jsDataStructure);\r\n   * console.log(jsonData);\r\n   * const deserializedJsDataStructure = JSON.parse(jsonData);\r\n   * const deserializedDf = DataFrame.deserialize(deserializedJsDataStructure); // Reconsituted.\r\n   * </pre>\r\n   */\n\n\n  DataFrame.deserialize = function (input) {\n    var indexValues = input.index && input.index.values || [];\n    var rows = input.values && input.values || [];\n    var cloned = false; // Deserialize dates.\n\n    if (input.columns) {\n      try {\n        for (var _a = __values(Object.keys(input.columns)), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var columnName = _b.value;\n\n          if (input.columns[columnName] !== \"date\") {\n            continue; // No need to process other types, they are natively supported by JSON.\n          }\n\n          if (!cloned) {\n            rows = rows.map(function (row) {\n              return Object.assign({}, row);\n            }); // Clone so we don't modify any original data.\n\n            cloned = true;\n          }\n\n          try {\n            for (var rows_2 = __values(rows), rows_2_1 = rows_2.next(); !rows_2_1.done; rows_2_1 = rows_2.next()) {\n              var row = rows_2_1.value;\n              row[columnName] = moment(row[columnName]).toDate(); // Manually deserialize data value.\n            }\n          } catch (e_72_1) {\n            e_72 = {\n              error: e_72_1\n            };\n          } finally {\n            try {\n              if (rows_2_1 && !rows_2_1.done && (_c = rows_2.return)) _c.call(rows_2);\n            } finally {\n              if (e_72) throw e_72.error;\n            }\n          }\n        }\n      } catch (e_73_1) {\n        e_73 = {\n          error: e_73_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\n        } finally {\n          if (e_73) throw e_73.error;\n        }\n      }\n    }\n\n    if (input.index && input.index.type === \"date\") {\n      indexValues = indexValues.map(function (value) {\n        return moment(value).toDate();\n      }); // Manually deserialize data value.\n    }\n\n    return new DataFrame({\n      columnNames: input.columnOrder || [],\n      index: indexValues,\n      values: rows\n    });\n\n    var e_73, _d, e_72, _c;\n  };\n  /***\r\n   * Allows the dataframe to be queried to confirm that it is actually a dataframe.\r\n   * Used from JavaScript to tell the difference between a Series and a DataFrame.\r\n   *\r\n   * @return Returns the string \"dataframe\".\r\n   */\n\n\n  DataFrame.prototype.getTypeCode = function () {\n    return \"dataframe\";\n  };\n\n  DataFrame.defaultCountIterable = new CountIterable();\n  DataFrame.defaultEmptyIterable = new EmptyIterable();\n  return DataFrame;\n}();\n/**\r\n * @hidden\r\n * Represents a dataframe that has been sorted.\r\n */\n\n\nvar OrderedDataFrame =\n/** @class */\nfunction (_super) {\n  __extends(OrderedDataFrame, _super);\n\n  function OrderedDataFrame(config) {\n    var _this = this;\n\n    var valueSortSpecs = [];\n    var pairSortSpecs = [];\n    var sortLevel = 0;\n    var parent = config.parent;\n    var parents = [];\n\n    while (parent !== null) {\n      parents.push(parent);\n      parent = parent.config.parent;\n    }\n\n    parents.reverse();\n\n    try {\n      for (var parents_1 = __values(parents), parents_1_1 = parents_1.next(); !parents_1_1.done; parents_1_1 = parents_1.next()) {\n        var parent_1 = parents_1_1.value;\n        var parentConfig = parent_1.config;\n        valueSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, parentConfig.selector, parentConfig.direction));\n        pairSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, OrderedDataFrame.makePairsSelector(parentConfig.selector), parentConfig.direction));\n        ++sortLevel;\n      }\n    } catch (e_74_1) {\n      e_74 = {\n        error: e_74_1\n      };\n    } finally {\n      try {\n        if (parents_1_1 && !parents_1_1.done && (_a = parents_1.return)) _a.call(parents_1);\n      } finally {\n        if (e_74) throw e_74.error;\n      }\n    }\n\n    valueSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, config.selector, config.direction));\n    pairSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, OrderedDataFrame.makePairsSelector(config.selector), config.direction));\n    _this = _super.call(this, {\n      columnNames: config.columnNames,\n      values: new OrderedIterable(config.values, valueSortSpecs),\n      pairs: new OrderedIterable(config.pairs, pairSortSpecs)\n    }) || this;\n    _this.config = config;\n    return _this;\n\n    var e_74, _a;\n  } //\n  // Helper function to create a sort spec.\n  //\n\n\n  OrderedDataFrame.makeSortSpec = function (sortLevel, selector, direction) {\n    return {\n      sortLevel: sortLevel,\n      selector: selector,\n      direction: direction\n    };\n  }; //\n  // Helper function to make a sort selector for pairs, this captures the parent correct when generating the closure.\n  //\n\n\n  OrderedDataFrame.makePairsSelector = function (selector) {\n    return function (pair, index) {\n      return selector(pair[1], index);\n    };\n  };\n  /**\r\n   * Applys additional sorting (ascending) to an already sorted dataframe.\r\n   *\r\n   * @param selector User-defined selector that selects the additional value to sort by.\r\n   *\r\n   * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Order sales by salesperson and then by amount (from least to most).\r\n   * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\r\n   * </pre>\r\n   */\n\n\n  OrderedDataFrame.prototype.thenBy = function (selector) {\n    return new OrderedDataFrame({\n      columnNames: this.config.columnNames,\n      values: this.config.values,\n      pairs: this.config.pairs,\n      selector: selector,\n      direction: Direction.Ascending,\n      parent: this\n    });\n  };\n  /**\r\n   * Applys additional sorting (descending) to an already sorted dataframe.\r\n   *\r\n   * @param selector User-defined selector that selects the additional value to sort by.\r\n   *\r\n   * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Order sales by salesperson and then by amount (from most to least).\r\n   * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\r\n   * </pre>\r\n   */\n\n\n  OrderedDataFrame.prototype.thenByDescending = function (selector) {\n    return new OrderedDataFrame({\n      columnNames: this.config.columnNames,\n      values: this.config.values,\n      pairs: this.config.pairs,\n      selector: selector,\n      direction: Direction.Descending,\n      parent: this\n    });\n  };\n\n  return OrderedDataFrame;\n}(DataFrame);\n\nmoment.extend(customParseFormat);\n/**\r\n * Specifies where from a data window the index is pulled from: the start of the window, the end or from the middle.\r\n */\n\nvar WhichIndex;\n\n(function (WhichIndex) {\n  WhichIndex[\"Start\"] = \"start\";\n  WhichIndex[\"End\"] = \"end\";\n})(WhichIndex || (WhichIndex = {}));\n/**\r\n * Class that represents a series containing a sequence of indexed values.\r\n */\n\n\nvar Series =\n/** @class */\nfunction () {\n  /**\r\n   * Create a series.\r\n   *\r\n   * @param config This can be an array, a configuration object or a function that lazily produces a configuration object.\r\n   *\r\n   * It can be an array that specifies the values that the series contains.\r\n   *\r\n   * It can be a {@link ISeriesConfig} that defines the values and configuration of the series.\r\n   *\r\n   * Or it can be a function that lazily produces a {@link ISeriesConfig}.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = new Series();\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = new Series([10, 20, 30, 40]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = new Series({ index: [1, 2, 3, 4], values: [10, 20, 30, 40]});\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [10, 20, 30, 40] });\r\n   * const series = new Series(lazyInit);\r\n   * </pre>\r\n   */\n  function Series(config) {\n    //\n    // Function to lazy evaluate the configuration of the series.\n    //\n    this.configFn = null; //\n    // The content of the series.\n    // When this is null it means the series is yet to be lazy initialised.\n    //\n\n    this.content = null; // \n    // Indexed content of the dataframe.\n    // \n\n    this.indexedContent = null;\n\n    if (config) {\n      if (isFunction(config)) {\n        this.configFn = config;\n      } else if (isArray(config) || isFunction(config[Symbol.iterator])) {\n        this.content = Series.initFromArray(config);\n      } else {\n        this.content = Series.initFromConfig(config);\n      }\n    } else {\n      this.content = Series.initEmpty();\n    }\n  } //\n  // Initialise series content from an array of values.\n  //\n\n\n  Series.initFromArray = function (arr) {\n    return {\n      index: Series.defaultCountIterable,\n      values: arr,\n      pairs: new MultiIterable([Series.defaultCountIterable, arr]),\n      isBaked: true\n    };\n  }; //\n  // Initialise an empty series.\n  //\n\n\n  Series.initEmpty = function () {\n    return {\n      index: Series.defaultEmptyIterable,\n      values: Series.defaultEmptyIterable,\n      pairs: Series.defaultEmptyIterable,\n      isBaked: true\n    };\n  }; //\n  // Check that a value is an interable.\n  //\n\n\n  Series.checkIterable = function (input, fieldName) {\n    if (isArray(input)) ;else if (isFunction(input[Symbol.iterator])) ;else {\n      // Not ok\n      throw new Error(\"Expected '\" + fieldName + \"' field of Series config object to be an array of values or an iterable of values.\");\n    }\n  }; //\n  // Initialise series content from a config object.\n  //\n\n\n  Series.initFromConfig = function (config) {\n    var index;\n    var values;\n    var pairs;\n    var isBaked = false;\n\n    if (config.pairs) {\n      Series.checkIterable(config.pairs, \"pairs\");\n      pairs = config.pairs;\n    }\n\n    if (config.index) {\n      Series.checkIterable(config.index, \"index\");\n      index = config.index;\n    } else if (pairs) {\n      index = new ExtractElementIterable(pairs, 0);\n    } else {\n      index = Series.defaultCountIterable;\n    }\n\n    if (config.values) {\n      Series.checkIterable(config.values, \"values\");\n      values = config.values;\n    } else if (pairs) {\n      values = new ExtractElementIterable(pairs, 1);\n    } else {\n      values = Series.defaultEmptyIterable;\n    }\n\n    if (!pairs) {\n      pairs = new MultiIterable([index, values]);\n    }\n\n    if (config.baked !== undefined) {\n      isBaked = config.baked;\n    }\n\n    return {\n      index: index,\n      values: values,\n      pairs: pairs,\n      isBaked: isBaked\n    };\n  }; //\n  // Ensure the series content has been initialised.\n  //\n\n\n  Series.prototype.lazyInit = function () {\n    if (this.content === null && this.configFn !== null) {\n      this.content = Series.initFromConfig(this.configFn());\n    }\n  }; //\n  // Ensure the series content is lazy initalised and return it.\n  //\n\n\n  Series.prototype.getContent = function () {\n    this.lazyInit();\n    return this.content;\n  }; // \n  // Lazy builds content index, does basic hash lookup.\n  //\n\n\n  Series.prototype.getRowByIndex = function (index) {\n    if (!this.indexedContent) {\n      this.indexedContent = new Map();\n\n      try {\n        for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var pair = _b.value;\n          this.indexedContent.set(pair[0], pair[1]);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    return this.indexedContent.get(index);\n\n    var e_1, _c;\n  };\n  /**\r\n   * Get an iterator to enumerate the values of the series.\r\n   * Enumerating the iterator forces lazy evaluation to complete.\r\n   * This function is automatically called by `for...of`.\r\n   *\r\n   * @return An iterator for the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * for (const value of series) {\r\n   *     // ... do something with the value ...\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  Series.prototype[Symbol.iterator] = function () {\n    return this.getContent().values[Symbol.iterator]();\n  };\n  /**\r\n   * Cast the value of the series to a new type.\r\n   * This operation has no effect but to retype the values that the series contains.\r\n   *\r\n   * @return The same series, but with the type changed.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const castSeries = series.cast<SomeOtherType>();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.cast = function () {\n    return this;\n  };\n  /**\r\n   * Get the index for the series.\r\n   *\r\n   * @return The {@link Index} for the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const index = series.getIndex();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.getIndex = function () {\n    var _this = this;\n\n    return new Index(function () {\n      return {\n        values: _this.getContent().index\n      };\n    });\n  };\n  /**\r\n   * Apply a new {@link Index} to the series.\r\n   *\r\n   * @param newIndex The new array or iterable to be the new {@link Index} of the series. Can also be a selector to choose the {@link Index} for each value in the series.\r\n   *\r\n   * @return Returns a new series with the specified {@link Index} attached.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const indexedSeries = series.withIndex([10, 20, 30]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const indexedSeries = series.withIndex(someOtherSeries);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const indexedSeries = series.withIndex(value => computeIndexFromValue(value));\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const indexedSeries = series.withIndex(value => value + 20);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.withIndex = function (newIndex) {\n    var _this = this;\n\n    if (isFunction(newIndex)) {\n      return new Series(function () {\n        return {\n          values: _this.getContent().values,\n          index: _this.select(newIndex)\n        };\n      });\n    } else {\n      Series.checkIterable(newIndex, 'newIndex');\n      return new Series(function () {\n        return {\n          values: _this.getContent().values,\n          index: newIndex\n        };\n      });\n    }\n  };\n  /**\r\n   * Resets the {@link Index} of the series back to the default zero-based sequential integer index.\r\n   *\r\n   * @return Returns a new series with the {@link Index} reset to the default zero-based index.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesWithResetIndex = series.resetIndex();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.resetIndex = function () {\n    var _this = this;\n\n    return new Series(function () {\n      return {\n        values: _this.getContent().values // Just strip the index.\n\n      };\n    });\n  };\n  /**\r\n   * Merge multiple series into a single series.\r\n   * Values are merged by index.\r\n   * Values at each index are combined into arrays in the resulting series.\r\n   *\r\n   * @param series An array or series of series to merge.\r\n   *\r\n   * @returns The merged series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const mergedSeries = Series.merge([series1, series2, etc]);\r\n   * </pre>\r\n   */\n\n\n  Series.merge = function (series) {\n    var rowMap = new Map();\n    var numSeries = Array.from(series).length; //TODO: Be nice not to have to do this.\n\n    var seriesIndex = 0;\n\n    try {\n      for (var series_1 = __values(series), series_1_1 = series_1.next(); !series_1_1.done; series_1_1 = series_1.next()) {\n        var workingSeries = series_1_1.value;\n\n        try {\n          for (var _a = __values(workingSeries.toPairs()), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var pair = _b.value;\n            var index = pair[0];\n\n            if (!rowMap.has(index)) {\n              rowMap.set(index, new Array(numSeries));\n            }\n\n            rowMap.get(index)[seriesIndex] = pair[1];\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        ++seriesIndex;\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (series_1_1 && !series_1_1.done && (_d = series_1.return)) _d.call(series_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    var mergedPairs = Array.from(rowMap.keys()).map(function (index) {\n      return [index, rowMap.get(index)];\n    });\n    mergedPairs.sort(function (a, b) {\n      if (a[0] === b[0]) {\n        return 0;\n      } else if (a[0] > b[0]) {\n        return 1;\n      } else {\n        return -1;\n      }\n    });\n    return new Series({\n      pairs: mergedPairs\n    });\n\n    var e_3, _d, e_2, _c;\n  };\n  /**\r\n    * Merge one or more series into this series.\r\n    * Values are merged by index.\r\n    * Values at each index are combined into arrays in the resulting series.\r\n    *\r\n    * @param series... One or more other series to merge into the series.\r\n    *\r\n    * @returns The merged series.\r\n    *\r\n    * @example\r\n    * <pre>\r\n    *\r\n    * const mergedSeries = series1.merge(series2);\r\n    * </pre>\r\n    *\r\n    * <pre>\r\n    *\r\n    * const mergedSeries = series1.merge(series2, series3, etc);\r\n    * </pre>\r\n    */\n\n\n  Series.prototype.merge = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return Series.merge([this].concat(args));\n  };\n  /**\r\n  * Extract values from the series as an array.\r\n  * This forces lazy evaluation to complete.\r\n  *\r\n  * @return Returns an array of the values contained within the series.\r\n  *\r\n  * @example\r\n  * <pre>\r\n  * const values = series.toArray();\r\n  * </pre>\r\n  */\n\n\n  Series.prototype.toArray = function () {\n    var values = [];\n\n    try {\n      for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n\n        if (value !== undefined && value !== null) {\n          values.push(value);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return values;\n\n    var e_4, _c;\n  };\n  /**\r\n   * Retreive the index, values pairs from the series as an array.\r\n   * Each pair is [index, value].\r\n   * This forces lazy evaluation to complete.\r\n   *\r\n   * @return Returns an array of pairs that contains the series values. Each pair is a two element array that contains an index and a value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   * const pairs = series.toPairs();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.toPairs = function () {\n    var pairs = [];\n\n    try {\n      for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var pair = _b.value;\n\n        if (pair[1] !== undefined && pair[1] !== null) {\n          pairs.push(pair);\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return pairs;\n\n    var e_5, _c;\n  };\n  /**\r\n   * Convert the series to a JavaScript object.\r\n   *\r\n   * @param keySelector User-defined selector function that selects keys for the resulting object.\r\n   * @param valueSelector User-defined selector function that selects values for the resulting object.\r\n   *\r\n   * @return Returns a JavaScript object generated from the series by applying the key and value selector functions.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const someObject = series.toObject(\r\n   *      value => value, // Specify the value to use for field names in the output object.\r\n   *      value => value // Specify the value to use as the value for each field.\r\n   * );\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.toObject = function (keySelector, valueSelector) {\n    if (!isFunction(keySelector)) throw new Error(\"Expected 'keySelector' parameter to Series.toObject to be a function.\");\n    if (!isFunction(valueSelector)) throw new Error(\"Expected 'valueSelector' parameter to Series.toObject to be a function.\");\n    return toMap(this, keySelector, valueSelector);\n  };\n  /**\r\n   * Generates a new series by repeatedly calling a user-defined selector function on each value in the original series.\r\n   *\r\n   * @param selector A user-defined selector function that transforms each row to create the new dataframe.\r\n   *\r\n   * @return Returns a new series with each value transformed by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * function transformValue (inputValue) {\r\n   *      const outputValue = {\r\n   *          // ... construct output value derived from input value ...\r\n   *      };\r\n   *\r\n   *      return outputValue;\r\n   * }\r\n   *\r\n   * const transformedSeries = series.select(value => transformValue(value));\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.select = function (selector) {\n    var _this = this;\n\n    if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.select' function to be a function.\");\n    return new Series(function () {\n      return {\n        values: new SelectIterable(_this.getContent().values, selector),\n        index: _this.getContent().index\n      };\n    });\n  };\n  /**\r\n   * Generates a new series by repeatedly calling a user-defined selector function on each row in the original series.\r\n   *\r\n   * Similar to the {@link select} function, but in this case the selector function produces a collection of output values that are flattened and merged to create the new series.\r\n   *\r\n   * @param selector A user-defined selector function that transforms each value into a collection of output values.\r\n   *\r\n   * @return Returns a new series where each value has been transformed into 0 or more new values by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * function produceOutputValues (inputValue) {\r\n   *      const outputValues = [];\r\n   *      while (someCondition) {\r\n   *          // ... generate zero or more output values ...\r\n   *          outputValues.push(... some generated value ...);\r\n   *      }\r\n   *      return outputValues;\r\n   * }\r\n   *\r\n   * const modifiedSeries = series.selectMany(value => produceOutputValues(value));\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.selectMany = function (selector) {\n    var _this = this;\n\n    if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.selectMany' to be a function.\");\n    return new Series(function () {\n      return {\n        pairs: new SelectManyIterable(_this.getContent().pairs, function (pair, index) {\n          var outputPairs = [];\n\n          try {\n            for (var _a = __values(selector(pair[1], index)), _b = _a.next(); !_b.done; _b = _a.next()) {\n              var transformed = _b.value;\n              outputPairs.push([pair[0], transformed]);\n            }\n          } catch (e_6_1) {\n            e_6 = {\n              error: e_6_1\n            };\n          } finally {\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_6) throw e_6.error;\n            }\n          }\n\n          return outputPairs;\n\n          var e_6, _c;\n        })\n      };\n    });\n  };\n  /**\r\n   * Partition a series into a {@link Series} of *data windows*.\r\n   * Each value in the new series is a chunk of data from the original series.\r\n   *\r\n   * @param period The number of values to include in each data window.\r\n   * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n   *\r\n   * @return Returns a new series, each value of which is a chunk (data window) of the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const windows = series.window(2); // Get values in pairs.\r\n   * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());\r\n   * console.log(pctIncrease.toString());\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const salesDf = ... // Daily sales data.\r\n   * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\r\n   * console.log(weeklySales.toString());\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.window = function (period, whichIndex) {\n    var _this = this;\n\n    if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'Series.window' to be a number.\");\n    return new Series(function () {\n      return {\n        pairs: new SeriesWindowIterable(_this.getContent().pairs, period, whichIndex || WhichIndex.End)\n      };\n    });\n  };\n  /**\r\n   * Partition a series into a new series of *rolling data windows*.\r\n   * Each value in the new series is a rolling chunk of data from the original series.\r\n   *\r\n   * @param period The number of data values to include in each data window.\r\n   * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n   *\r\n   * @return Returns a new series, each value of which is a rolling chunk of the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const salesData = ... // Daily sales data.\r\n   * const rollingWeeklySales = salesData.rollingWindow(7); // Get rolling window over weekly sales data.\r\n   * console.log(rollingWeeklySales.toString());\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.rollingWindow = function (period, whichIndex) {\n    var _this = this;\n\n    if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'Series.rollingWindow' to be a number.\");\n    return new Series(function () {\n      return {\n        pairs: new SeriesRollingWindowIterable(_this.getContent().pairs, period, whichIndex || WhichIndex.End)\n      };\n    });\n  };\n  /**\r\n   * Partition a series into a new series of variable-length *data windows*\r\n   * where the divisions between the data chunks are\r\n   * defined by a user-provided *comparer* function.\r\n   *\r\n   * @param comparer Function that compares two adjacent data values and returns true if they should be in the same window.\r\n   *\r\n   * @return Returns a new series, each value of which is a chunk of data from the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * function rowComparer (valueA, valueB) {\r\n   *      if (... valueA should be in the same data window as valueB ...) {\r\n   *          return true;\r\n   *      }\r\n   *      else {\r\n   *          return false;\r\n   *      }\r\n   * };\r\n   *\r\n   * const variableWindows = series.variableWindow(rowComparer);\r\n   */\n\n\n  Series.prototype.variableWindow = function (comparer) {\n    var _this = this;\n\n    if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'Series.variableWindow' to be a function.\");\n    return new Series(function () {\n      return {\n        values: new SeriesVariableWindowIterable(_this.getContent().pairs, comparer)\n      };\n    });\n  };\n  /**\r\n   * Eliminates adjacent duplicate values.\r\n   *\r\n   * For each group of adjacent values that are equivalent only returns the last index/row for the group,\r\n   * thus ajacent equivalent values are collapsed down to the last value.\r\n   *\r\n   * @param selector Optional selector function to determine the value used to compare for equivalence.\r\n   *\r\n   * @return Returns a new series with groups of adjacent duplicate vlaues collapsed to a single value per group.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value);\r\n   *\r\n   * // Or\r\n   * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value.someNestedField);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.sequentialDistinct = function (selector) {\n    if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.\");\n    } else {\n      selector = function selector(value) {\n        return value;\n      };\n    }\n\n    return this.variableWindow(function (a, b) {\n      return selector(a) === selector(b);\n    }).select(function (window) {\n      return [window.getIndex().first(), window.first()];\n    }).withIndex(function (pair) {\n      return pair[0];\n    }).select(function (pair) {\n      return pair[1];\n    });\n  };\n  /**\r\n   * Aggregate the values in the series to a single result.\r\n   *\r\n   * @param seed Optional seed value for producing the aggregation.\r\n   * @param selector Function that takes the seed and then each value in the series and produces the aggregated value.\r\n   *\r\n   * @return Returns a new value that has been aggregated from the series using the 'selector' function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dailySales = ... daily sales figures for the past month ...\r\n   * const totalSalesForthisMonth = dailySales.aggregate(\r\n   *      0, // Seed - the starting value.\r\n   *      (accumulator, salesAmount) => accumulator + salesAmount // Aggregation function.\r\n   * );\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.\r\n   * const dailySales = ... daily sales figures for the past month ...\r\n   * const updatedTotalSalesAllTime = dailySales.aggregate(\r\n   *      totalSalesAllTime,\r\n   *      (accumulator, salesAmount) => accumulator + salesAmount\r\n   * );\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * var salesDataSummary = salesData.aggregate({\r\n   *      TotalSales: series => series.count(),\r\n   *      AveragePrice: series => series.average(),\r\n   *      TotalRevenue: series => series.sum(),\r\n   * });\r\n   * </pre>\r\n  */\n\n\n  Series.prototype.aggregate = function (seedOrSelector, selector) {\n    if (isFunction(seedOrSelector) && !selector) {\n      return this.skip(1).aggregate(this.first(), seedOrSelector);\n    } else {\n      if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to aggregate to be a function.\");\n      var accum = seedOrSelector;\n\n      try {\n        for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var value = _b.value;\n          accum = selector(accum, value);\n        }\n      } catch (e_7_1) {\n        e_7 = {\n          error: e_7_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_7) throw e_7.error;\n        }\n      }\n\n      return accum;\n    }\n\n    var e_7, _c;\n  };\n  /**\r\n   * Compute the absolute range of values in each period.\r\n   * The range for each period is the absolute difference between largest (max) and smallest (min) values in that period.\r\n   *\r\n   * @param period - Period for computing the range.\r\n   *\r\n   * @returns Returns a new series where each value indicates the absolute range of values for each period in the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const closingPrice = ... series of closing prices for a particular stock ...\r\n   * const volatility = closingPrice.amountRange(5);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.amountRange = function (period, whichIndex) {\n    return this // Have to assume this is a number series.\n    .rollingWindow(period, whichIndex).select(function (window) {\n      return window.max() - window.min();\n    });\n  };\n  /**\r\n   * Compute the range of values in each period in proportion to the latest value.\r\n   * The range for each period is the absolute difference between largest (max) and smallest (min) values in that period.\r\n   * Proportions are expressed as 0-1 values.\r\n   *\r\n   * @param period - Period for computing the range.\r\n   *\r\n   * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\r\n   *\r\n   * @returns Returns a new series where each value indicates the proportionate range of values for each period in the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const closingPrice = ... series of closing prices for a particular stock ...\r\n   * const proportionVolatility = closingPrice.proportionRange(5);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.proportionRange = function (period, whichIndex) {\n    return this // Have to assume this is a number series.\n    .rollingWindow(period, whichIndex).select(function (window) {\n      return (window.max() - window.min()) / window.last();\n    });\n  };\n  /**\r\n   * Compute the range of values in each period in proportion to the latest value.\r\n   * The range for each period is the absolute difference between largest (max) and smallest (min) values in that period.\r\n   * Proportions are expressed as 0-1 values.\r\n   *\r\n   * @param period - Period for computing the range.\r\n   *\r\n   * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\r\n   *\r\n   * @returns Returns a new series where each value indicates the proportionate range of values for each period in the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const closingPrice = ... series of closing prices for a particular stock ...\r\n   * const percentVolatility = closingPrice.percentRange(5);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.percentRange = function (period, whichIndex) {\n    return this.proportionRange(period, whichIndex).select(function (v) {\n      return v * 100;\n    });\n  };\n  /**\r\n   * Compute the amount of change between pairs or sets of values in the series.\r\n   *\r\n   * @param period Optional period for computing the change - defaults to 2.\r\n   *\r\n   * @returns Returns a new series where each value indicates the amount of change from the previous number value in the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const saleFigures = ... running series of daily sales figures ...\r\n   * const amountChanged = salesFigures.amountChanged(); // Amount that sales has changed, day to day.\r\n   * </pre>\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const saleFigures = ... running series of daily sales figures ...\r\n   * const amountChanged = salesFigures.amountChanged(7); // Amount that sales has changed, week to week.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.amountChange = function (period, whichIndex) {\n    return this // Have to assume this is a number series.\n    .rollingWindow(period === undefined ? 2 : period, whichIndex).select(function (window) {\n      return window.last() - window.first();\n    });\n  };\n  /**\r\n   * Compute the proportion change between pairs or sets of values in the series.\r\n   * Proportions are expressed as 0-1 values.\r\n   *\r\n   * @param period Optional period for computing the proportion - defaults to 2.\r\n   *\r\n   * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const saleFigures = ... running series of daily sales figures ...\r\n   * const proportionChanged = salesFigures.amountChanged(); // Proportion that sales has changed, day to day.\r\n   * </pre>\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const saleFigures = ... running series of daily sales figures ...\r\n   * const proportionChanged = salesFigures.amountChanged(7); // Proportion that sales has changed, week to week.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.proportionChange = function (period, whichIndex) {\n    return this // Have to assume this is a number series.\n    .rollingWindow(period === undefined ? 2 : period, whichIndex).select(function (window) {\n      return (window.last() - window.first()) / window.first();\n    });\n  };\n  /**\r\n   * Compute the percentage change between pairs or sets of values in the series.\r\n   * Percentages are expressed as 0-100 values.\r\n   *\r\n   * @param period Optional period for computing the percentage - defaults to 2.\r\n   *\r\n   * @returns Returns a new series where each value indicates the percent change from the previous number value in the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const saleFigures = ... running series of daily sales figures ...\r\n   * const percentChanged = salesFigures.amountChanged(); // Percent that sales has changed, day to day.\r\n   * </pre>\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const saleFigures = ... running series of daily sales figures ...\r\n   * const percentChanged = salesFigures.amountChanged(7); // Percent that sales has changed, week to week.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.percentChange = function (period, whichIndex) {\n    return this.proportionChange(period, whichIndex).select(function (v) {\n      return v * 100;\n    });\n  };\n  /**\r\n   * For each period, compute the proportion of values that are less than the last value in the period.\r\n   * Proportions are expressed as 0-1 values.\r\n   *\r\n   * @param period Optional period for computing the proportion rank - defaults to 2.\r\n   *\r\n   * @returns Returns a new series where each value indicates the proportion rank value for that period.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const proportionRank = series.proportionRank();\r\n   * </pre>\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const proportionRank = series.proportionRank(100);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.proportionRank = function (period) {\n    if (period === undefined) {\n      period = 2;\n    }\n\n    if (!isNumber(period)) {\n      throw new Error(\"Expected 'period' parameter to 'Series.proportionRank' to be a number that specifies the time period for the ranking.\");\n    }\n\n    return this.rollingWindow(period + 1) // +1 to account for the last value being used.\n    .select(function (window) {\n      var latestValue = window.last();\n      var numLowerValues = window.head(-1).where(function (prevMomentum) {\n        return prevMomentum < latestValue;\n      }).count();\n      var proportionRank = numLowerValues / period;\n      return proportionRank;\n    });\n  };\n  /**\r\n   * For each period, compute the percent of values that are less than the last value in the period.\r\n   * Percent are expressed as 0-100 values.\r\n   *\r\n   * @param period Optional period for computing the percent rank - defaults to 2.\r\n   *\r\n   * @returns Returns a new series where each value indicates the percent rank value for that period.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const percentRank = series.percentRank();\r\n   * </pre>\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const percentRank = series.percentRank(100);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.percentRank = function (period) {\n    if (period === undefined) {\n      period = 2;\n    }\n\n    if (!isNumber(period)) {\n      throw new Error(\"Expected 'period' parameter to 'Series.percentRank' to be a number that specifies the time period for the ranking.\");\n    }\n\n    return this.proportionRank(period).select(function (proportion) {\n      return proportion * 100;\n    });\n  };\n  /**\r\n   * Generates a cumulative sum across a series.\r\n   *\r\n   * @returns Returns a new series that is the cumulative sum of values across the input series.\r\n   */\n\n\n  Series.prototype.cumsum = function () {\n    var _this = this;\n\n    return new Series(function () {\n      var working = 0;\n\n      var pairs = _this.toPairs();\n\n      var output = pairs.map(function (_a) {\n        var _b = __read(_a, 2),\n            index = _b[0],\n            value = _b[1];\n\n        return [index, working += value];\n      });\n      return {\n        pairs: output\n      };\n    });\n  };\n  /**\r\n   * Skip a number of values in the series.\r\n   *\r\n   * @param numValues Number of values to skip.\r\n   *\r\n   * @return Returns a new series with the specified number of values skipped.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesWithRowsSkipped = series.skip(10); // Skip 10 rows in the original series.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.skip = function (numValues) {\n    var _this = this;\n\n    return new Series(function () {\n      return {\n        values: new SkipIterable(_this.getContent().values, numValues),\n        index: new SkipIterable(_this.getContent().index, numValues),\n        pairs: new SkipIterable(_this.getContent().pairs, numValues)\n      };\n    });\n  };\n  /**\r\n   * Skips values in the series while a condition evaluates to true or truthy.\r\n   *\r\n   * @param predicate Returns true/truthy to continue to skip values in the original series.\r\n   *\r\n   * @return Returns a new series with all initial sequential values removed while the predicate returned true/truthy.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesWithRowsSkipped = series.skipWhile(salesFigure => salesFigure > 100); // Skip initial sales figure that are less than 100.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.skipWhile = function (predicate) {\n    var _this = this;\n\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.skipWhile' function to be a predicate function that returns true/false.\");\n    return new Series(function () {\n      return {\n        values: new SkipWhileIterable(_this.getContent().values, predicate),\n        pairs: new SkipWhileIterable(_this.getContent().pairs, function (pair) {\n          return predicate(pair[1]);\n        })\n      };\n    });\n  };\n  /**\r\n   * Skips values in the series untils a condition evaluates to true or truthy.\r\n   *\r\n   * @param predicate Return true/truthy to stop skipping values in the original series.\r\n   *\r\n   * @return Returns a new series with all initial sequential values removed until the predicate returned true/truthy.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesWithRowsSkipped = series.skipUntil(salesFigure => salesFigure > 100); // Skip initial sales figures unitl we see one greater than 100.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.skipUntil = function (predicate) {\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.skipUntil' function to be a predicate function that returns true/false.\");\n    return this.skipWhile(function (value) {\n      return !predicate(value);\n    });\n  };\n  /**\r\n   * Take a number of  values from the series.\r\n   *\r\n   * @param numValues Number of values to take.\r\n   *\r\n   * @return Returns a new series with only the specified number of values taken from the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesWithRowsTaken = series.take(15); // Take only the first 15 values from the original series.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.take = function (numRows) {\n    var _this = this;\n\n    if (!isNumber(numRows)) throw new Error(\"Expected 'numRows' parameter to 'Series.take' function to be a number.\");\n    return new Series(function () {\n      return {\n        index: new TakeIterable(_this.getContent().index, numRows),\n        values: new TakeIterable(_this.getContent().values, numRows),\n        pairs: new TakeIterable(_this.getContent().pairs, numRows)\n      };\n    });\n  };\n  /**\r\n   * Takes values from the series while a condition evaluates to true or truthy.\r\n   *\r\n   * @param predicate Returns true/truthy to continue to take values from the original series.\r\n   *\r\n   * @return Returns a new series with only the initial sequential values that were taken while the predicate returned true/truthy.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesWithRowsTaken = series.takeWhile(salesFigure => salesFigure > 100); // Take only initial sales figures that are greater than 100.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.takeWhile = function (predicate) {\n    var _this = this;\n\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.takeWhile' function to be a predicate function that returns true/false.\");\n    return new Series(function () {\n      return {\n        values: new TakeWhileIterable(_this.getContent().values, predicate),\n        pairs: new TakeWhileIterable(_this.getContent().pairs, function (pair) {\n          return predicate(pair[1]);\n        })\n      };\n    });\n  };\n  /**\r\n   * Takes values from the series until a condition evaluates to true or truthy.\r\n   *\r\n   * @param predicate Return true/truthy to stop taking values in the original series.\r\n   *\r\n   * @return Returns a new series with only the initial sequential values taken until the predicate returned true/truthy.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesWithRowsTaken = series.takeUntil(salesFigure => salesFigure > 100); // Take all initial sales figures until we see one that is greater than 100.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.takeUntil = function (predicate) {\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.takeUntil' function to be a predicate function that returns true/false.\");\n    return this.takeWhile(function (value) {\n      return !predicate(value);\n    });\n  };\n  /**\r\n   * Static version of the count function for use with summarize and pivot functions.\r\n   *\r\n   * @param series Input series to be counted.\r\n   *\r\n   * @returns Returns the count of values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = dataFrame.summarize({\r\n   *      ColumnToBeCounted: Series.count,\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  Series.count = function (series) {\n    return series.count();\n  };\n  /**\r\n   * Count the number of values in the series.\r\n   *\r\n   * @return Returns the count of all values.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const numValues = series.count();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.count = function () {\n    var total = 0;\n\n    try {\n      for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        ++total;\n      }\n    } catch (e_8_1) {\n      e_8 = {\n        error: e_8_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_8) throw e_8.error;\n      }\n    }\n\n    return total;\n\n    var e_8, _c;\n  };\n  /**\r\n   * Get the first value of the series.\r\n   *\r\n   * @return Returns the first value of the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const firstValue = series.first();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.first = function () {\n    try {\n      for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        return value; // Only need the first value.\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n\n    throw new Error(\"Series.first: No values in Series.\");\n\n    var e_9, _c;\n  };\n  /**\r\n   * Get the last value of the series.\r\n   *\r\n   * @return Returns the last value of the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const lastValue = series.last();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.last = function () {\n    var lastValue = null;\n\n    try {\n      for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        lastValue = value; // Throw away all values until we get to the last one.\n      }\n    } catch (e_10_1) {\n      e_10 = {\n        error: e_10_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_10) throw e_10.error;\n      }\n    }\n\n    if (lastValue === null) {\n      throw new Error(\"Series.last: No values in Series.\");\n    }\n\n    return lastValue;\n\n    var e_10, _c;\n  };\n  /**\r\n   * Get the value, if there is one, with the specified index.\r\n   *\r\n   * @param index Index to for which to retreive the value.\r\n   *\r\n   * @return Returns the value from the specified index in the series or undefined if there is no such index in the present in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const value = series.at(5); // Get the value at index 5 (with a default 0-based index).\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const date = ... some date ...\r\n   * // Retreive the value with specified date from a time-series (assuming date indexed has been applied).\r\n   * const value = series.at(date);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.at = function (index) {\n    if (this.none()) {\n      return undefined;\n    }\n\n    return this.getRowByIndex(index);\n  };\n  /**\r\n   * Get X value from the start of the series.\r\n   * Pass in a negative value to get all values at the head except for X values at the tail.\r\n   *\r\n   * @param numValues Number of values to take.\r\n   *\r\n   * @return Returns a new series that has only the specified number of values taken from the start of the original series.\r\n   *\r\n   * @examples\r\n   * <pre>\r\n   *\r\n   * const sample = series.head(10); // Take a sample of 10 values from the start of the series.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.head = function (numValues) {\n    if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'Series.head' function to be a number.\");\n\n    if (numValues === 0) {\n      return new Series(); // Empty series.\n    }\n\n    var toTake = numValues < 0 ? this.count() - Math.abs(numValues) : numValues;\n    return this.take(toTake);\n  };\n  /**\r\n   * Get X values from the end of the series.\r\n   * Pass in a negative value to get all values at the tail except X values at the head.\r\n   *\r\n   * @param numValues Number of values to take.\r\n   *\r\n   * @return Returns a new series that has only the specified number of values taken from the end of the original series.\r\n   *\r\n   * @examples\r\n   * <pre>\r\n   *\r\n   * const sample = series.tail(12); // Take a sample of 12 values from the end of the series.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.tail = function (numValues) {\n    if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'Series.tail' function to be a number.\");\n\n    if (numValues === 0) {\n      return new Series(); // Empty series.\n    }\n\n    var toSkip = numValues > 0 ? this.count() - numValues : Math.abs(numValues);\n    return this.skip(toSkip);\n  };\n  /**\r\n   * Filter the series using user-defined predicate function.\r\n   *\r\n   * @param predicate Predicte function to filter values from the series. Returns true/truthy to keep values, or false/falsy to omit values.\r\n   *\r\n   * @return Returns a new series containing only the values from the original series that matched the predicate.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const filtered = series.where(salesFigure => salesFigure > 100); // Filter so we only have sales figures greater than 100.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.where = function (predicate) {\n    var _this = this;\n\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.where' function to be a function.\");\n    return new Series(function () {\n      return {\n        values: new WhereIterable(_this.getContent().values, predicate),\n        pairs: new WhereIterable(_this.getContent().pairs, function (pair) {\n          return predicate(pair[1]);\n        })\n      };\n    });\n  };\n  /**\r\n   * Invoke a callback function for each value in the series.\r\n   *\r\n   * @param callback The calback function to invoke for each value.\r\n   *\r\n   * @return Returns the original series with no modifications.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * series.forEach(value => {\r\n   *      // ... do something with the value ...\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.forEach = function (callback) {\n    if (!isFunction(callback)) throw new Error(\"Expected 'callback' parameter to 'Series.forEach' to be a function.\");\n    var index = 0;\n\n    try {\n      for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n        callback(value, index++);\n      }\n    } catch (e_11_1) {\n      e_11 = {\n        error: e_11_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_11) throw e_11.error;\n      }\n    }\n\n    return this;\n\n    var e_11, _c;\n  };\n  /**\r\n   * Evaluates a predicate function for every value in the series to determine\r\n   * if some condition is true/truthy for **all** values in the series.\r\n   *\r\n   * @param predicate Predicate function that receives each value. It should returns true/truthy for a match, otherwise false/falsy.\r\n   *\r\n   * @return Returns true if the predicate has returned true or truthy for every value in the series, otherwise returns false. Returns false for an empty series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const result = series.all(salesFigure => salesFigure > 100); // Returns true if all sales figures are greater than 100.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.all = function (predicate) {\n    if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.all' to be a function.\");\n    var count = 0;\n\n    try {\n      for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n        var value = _b.value;\n\n        if (!predicate(value)) {\n          return false;\n        }\n\n        ++count;\n      }\n    } catch (e_12_1) {\n      e_12 = {\n        error: e_12_1\n      };\n    } finally {\n      try {\n        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n      } finally {\n        if (e_12) throw e_12.error;\n      }\n    }\n\n    return count > 0;\n\n    var e_12, _c;\n  };\n  /**\r\n   * Evaluates a predicate function for every value in the series to determine\r\n   * if some condition is true/truthy for **any** of values in the series.\r\n   *\r\n   * If no predicate is specified then it simply checks if the series contains more than zero values.\r\n   *\r\n   * @param predicate Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\r\n   *\r\n   * @return Returns true if the predicate has returned truthy for any value in the series, otherwise returns false.\r\n   * If no predicate is passed it returns true if the series contains any values at all.\r\n   * Returns false for an empty series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const result = series.any(salesFigure => salesFigure > 100); // Do we have any sales figures greater than 100?\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const result = series.any(); // Do we have any sales figures at all?\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.any = function (predicate) {\n    if (predicate) {\n      if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.any' to be a function.\");\n    }\n\n    if (predicate) {\n      try {\n        // Use the predicate to check each value.\n        for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var value = _b.value;\n\n          if (predicate(value)) {\n            return true;\n          }\n        }\n      } catch (e_13_1) {\n        e_13 = {\n          error: e_13_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_13) throw e_13.error;\n        }\n      }\n    } else {\n      // Just check if there is at least one item.\n      var iterator = this[Symbol.iterator]();\n      return !iterator.next().done;\n    }\n\n    return false; // Nothing passed.\n\n    var e_13, _c;\n  };\n  /**\r\n   * Evaluates a predicate function for every value in the series to determine\r\n   * if some condition is true/truthy for **none** of values in the series.\r\n   *\r\n   * If no predicate is specified then it simply checks if the series contains zero values.\r\n   *\r\n   * @param predicate Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\r\n   *\r\n   * @return Returns true if the predicate has returned truthy for zero values in the series, otherwise returns false. Returns false for an empty series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const result = series.none(salesFigure => salesFigure > 100); // Do we have zero sales figures greater than 100?\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const result = series.none(); // Do we have zero sales figures?\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.none = function (predicate) {\n    if (predicate) {\n      if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.none' to be a function.\");\n    }\n\n    if (predicate) {\n      try {\n        // Use the predicate to check each value.\n        for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var value = _b.value;\n\n          if (predicate(value)) {\n            return false;\n          }\n        }\n      } catch (e_14_1) {\n        e_14 = {\n          error: e_14_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_14) throw e_14.error;\n        }\n      }\n    } else {\n      // Just check if empty.\n      var iterator = this[Symbol.iterator]();\n      return iterator.next().done;\n    }\n\n    return true; // Nothing failed the predicate.\n\n    var e_14, _c;\n  };\n  /**\r\n   * Gets a new series containing all values starting at or after the specified index value.\r\n   *\r\n   * @param indexValue The index value at which to start the new series.\r\n   *\r\n   * @return Returns a new series containing all values starting at or after the specified index value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = new Series({\r\n   *      index: [0, 1, 2, 3], // This is the default index.\r\n   *      values: [10, 20, 30, 40],\r\n   * });\r\n   *\r\n   * const lastHalf = series.startAt(2);\r\n   * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSeries = ... a series indexed by date/time ...\r\n   *\r\n   * // Get all values starting at (or after) a particular date.\r\n   * const result = timeSeries.startAt(new Date(2016, 5, 4));\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.startAt = function (indexValue) {\n    var _this = this;\n\n    return new Series(function () {\n      var lessThan = _this.getIndex().getLessThan();\n\n      return {\n        index: new SkipWhileIterable(_this.getContent().index, function (index) {\n          return lessThan(index, indexValue);\n        }),\n        pairs: new SkipWhileIterable(_this.getContent().pairs, function (pair) {\n          return lessThan(pair[0], indexValue);\n        })\n      };\n    });\n  };\n  /**\r\n   * Gets a new series containing all values up until and including the specified index value (inclusive).\r\n   *\r\n   * @param indexValue The index value at which to end the new series.\r\n   *\r\n   * @return Returns a new series containing all values up until and including the specified index value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = new Series({\r\n   *      index: [0, 1, 2, 3], // This is the default index.\r\n   *      values: [10, 20, 30, 40],\r\n   * });\r\n   *\r\n   * const firstHalf = series.endAt(1);\r\n   * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSeries = ... a series indexed by date/time ...\r\n   *\r\n   * // Get all values ending at a particular date.\r\n   * const result = timeSeries.endAt(new Date(2016, 5, 4));\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.endAt = function (indexValue) {\n    var _this = this;\n\n    return new Series(function () {\n      var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();\n\n      return {\n        index: new TakeWhileIterable(_this.getContent().index, function (index) {\n          return lessThanOrEqualTo(index, indexValue);\n        }),\n        pairs: new TakeWhileIterable(_this.getContent().pairs, function (pair) {\n          return lessThanOrEqualTo(pair[0], indexValue);\n        })\n      };\n    });\n  };\n  /**\r\n   * Gets a new series containing all values up to the specified index value (exclusive).\r\n   *\r\n   * @param indexValue The index value at which to end the new series.\r\n   *\r\n   * @return Returns a new series containing all values up to (but not including) the specified index value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = new Series({\r\n   *      index: [0, 1, 2, 3], // This is the default index.\r\n   *      values: [10, 20, 30, 40],\r\n   * });\r\n   *\r\n   * const firstHalf = series.before(2);\r\n   * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSeries = ... a series indexed by date/time ...\r\n   *\r\n   * // Get all values before the specified date.\r\n   * const result = timeSeries.before(new Date(2016, 5, 4));\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.before = function (indexValue) {\n    var _this = this;\n\n    return new Series(function () {\n      var lessThan = _this.getIndex().getLessThan();\n\n      return {\n        index: new TakeWhileIterable(_this.getContent().index, function (index) {\n          return lessThan(index, indexValue);\n        }),\n        pairs: new TakeWhileIterable(_this.getContent().pairs, function (pair) {\n          return lessThan(pair[0], indexValue);\n        })\n      };\n    });\n  };\n  /**\r\n   * Gets a new series containing all values after the specified index value (exclusive).\r\n   *\r\n   * @param indexValue The index value after which to start the new series.\r\n   *\r\n   * @return Returns a new series containing all values after the specified index value.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = new Series({\r\n   *      index: [0, 1, 2, 3], // This is the default index.\r\n   *      values: [10, 20, 30, 40],\r\n   * });\r\n   *\r\n   * const lastHalf = df.before(1);\r\n   * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSerie = ... a series indexed by date/time ...\r\n   *\r\n   * // Get all values after the specified date.\r\n   * const result = timeSeries.after(new Date(2016, 5, 4));\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.after = function (indexValue) {\n    var _this = this;\n\n    return new Series(function () {\n      var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();\n\n      return {\n        index: new SkipWhileIterable(_this.getContent().index, function (index) {\n          return lessThanOrEqualTo(index, indexValue);\n        }),\n        pairs: new SkipWhileIterable(_this.getContent().pairs, function (pair) {\n          return lessThanOrEqualTo(pair[0], indexValue);\n        })\n      };\n    });\n  };\n  /**\r\n   * Gets a new series containing all values between the specified index values (inclusive).\r\n   *\r\n   * @param startIndexValue The index at which to start the new series.\r\n   * @param endIndexValue The index at which to end the new series.\r\n   *\r\n   * @return Returns a new series containing all values between the specified index values (inclusive).\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = new Series({\r\n   *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\r\n   *      values: [10, 20, 30, 40, 50, 60],\r\n   * });\r\n   *\r\n   * const middleSection = series.between(1, 4);\r\n   * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const timeSeries = ... a series indexed by date/time ...\r\n   *\r\n   * // Get all values between the start and end dates (inclusive).\r\n   * const result = timeSeries.after(new Date(2016, 5, 4), new Date(2016, 5, 22));\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.between = function (startIndexValue, endIndexValue) {\n    return this.startAt(startIndexValue).endAt(endIndexValue);\n  };\n  /**\r\n   * Format the series for display as a string.\r\n   * This forces lazy evaluation to complete.\r\n   *\r\n   * @return Generates and returns a string representation of the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * console.log(series.toString());\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.toString = function () {\n    var header = [\"__index__\", \"__value__\"];\n    var rows = this.toPairs();\n    var table = new Table();\n\n    for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\n      var row = rows[rowIndex];\n\n      for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\n        var cell = row[cellIndex];\n        table.cell(header[cellIndex], cell);\n      }\n\n      table.newRow();\n    }\n\n    return table.toString();\n  }; //\n  // Helper function to parse a string to an int.\n  //\n\n\n  Series.parseInt = function (value, valueIndex) {\n    if (value === undefined || value === null) {\n      return undefined;\n    } else {\n      if (!isString(value)) {\n        throw new Error(\"Called Series.parseInts, expected all values in the series to be strings, instead found a '\" + typeof value + \"' at index \" + valueIndex);\n      }\n\n      if (value.length === 0) {\n        return undefined;\n      }\n\n      return parseInt(value);\n    }\n  };\n  /**\r\n   * Parse a series with string values and convert it to a series with int values.\r\n   *\r\n   * @return Returns a new series with values parsed from strings to ints.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const parsed = series.parseInts();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.parseInts = function () {\n    return this.select(Series.parseInt);\n  }; //\n  // Helper function to parse a string to a float.\n  //\n\n\n  Series.parseFloat = function (value, valueIndex) {\n    if (value === undefined || value === null) {\n      return undefined;\n    } else {\n      if (!isString(value)) throw new Error(\"Called Series.parseFloats, expected all values in the series to be strings, instead found a '\" + typeof value + \"' at index \" + valueIndex);\n\n      if (value.length === 0) {\n        return undefined;\n      }\n\n      return parseFloat(value);\n    }\n  };\n  /**\r\n   * Parse a series with string values and convert it to a series with float values.\r\n   *\r\n   * @return Returns a new series with values parsed from strings to floats.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const parsed = series.parseFloats();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.parseFloats = function () {\n    return this.select(Series.parseFloat);\n  }; //\n  // Helper function to parse a string to a date.\n  //\n\n\n  Series.parseDate = function (value, valueIndex, formatString) {\n    if (value === undefined || value === null) {\n      return undefined;\n    } else {\n      if (!isString(value)) throw new Error(\"Called Series.parseDates, expected all values in the series to be strings, instead found a '\" + typeof value + \"' at index \" + valueIndex);\n\n      if (value.length === 0) {\n        return undefined;\n      }\n\n      return moment(value, formatString).toDate();\n    }\n  };\n  /**\r\n   * Parse a series with string values and convert it to a series with date values.\r\n   *\r\n   * @param formatString Optional formatting string for dates.\r\n   *\r\n   * Moment is used for date parsing.\r\n   * https://momentjs.com\r\n   *\r\n   * @return Returns a new series with values parsed from strings to dates.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const parsed = series.parseDates();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.parseDates = function (formatString) {\n    if (formatString) {\n      if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to Series.parseDates to be a string (if specified).\");\n    }\n\n    return this.select(function (value, valueIndex) {\n      return Series.parseDate(value, valueIndex, formatString);\n    });\n  }; //\n  // Helper function to convert a value to a string.\n  //\n\n\n  Series.toString = function (value, formatString) {\n    if (value === undefined) {\n      return undefined;\n    } else if (value === null) {\n      return null;\n    } else if (formatString && isDate(value)) {\n      return moment(value).format(formatString);\n    } else if (formatString && isNumber(value)) {\n      return numeral(value).format(formatString);\n    } else {\n      return value.toString();\n    }\n  };\n  /**\r\n   * Convert a series of values of different types to a series containing string values.\r\n   *\r\n   * @param formatString Optional formatting string for dates.\r\n   *\r\n   * Numeral.js is used for number formatting.\r\n   * http://numeraljs.com/\r\n   *\r\n   * Moment is used for date formatting.\r\n   * https://momentjs.com/docs/#/parsing/string-format/\r\n   *\r\n   * @return Returns a new series values converted from values to strings.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const result = series.toStrings(\"YYYY-MM-DD\");\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const result = series.toStrings(\"0.00\");\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.toStrings = function (formatString) {\n    if (formatString) {\n      if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to Series.toStrings to be a string (if specified).\");\n    }\n\n    return this.select(function (value) {\n      return Series.toString(value, formatString);\n    });\n  };\n  /**\r\n   * Forces lazy evaluation to complete and 'bakes' the series into memory.\r\n   *\r\n   * @return Returns a series that has been 'baked', all lazy evaluation has completed.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const baked = series.bake();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.bake = function () {\n    if (this.getContent().isBaked) {\n      // Already baked.\n      return this;\n    }\n\n    return new Series({\n      values: this.toArray(),\n      pairs: this.toPairs(),\n      baked: true\n    });\n  };\n  /**\r\n   * Converts (inflates) a series to a {@link DataFrame}.\r\n   *\r\n   * @param selector Optional user-defined selector function that transforms each value to produce the dataframe.\r\n   *\r\n   * @returns Returns a dataframe that was created from the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dataframe = series.inflate(); // Inflate a series of objects to a dataframe.\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dataframe = series.inflate(value => { AColumn:  value }); // Produces a dataframe with 1 column from a series of values.\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dataframe = series.inflate(value => { AColumn:  value.NestedValue }); // Extract a nested value and produce a dataframe from it.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.inflate = function (selector) {\n    var _this = this;\n\n    if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to Series.inflate to be a selector function.\");\n      return new DataFrame(function () {\n        var content = _this.getContent();\n\n        return {\n          values: new SelectIterable(content.values, selector),\n          index: content.index,\n          pairs: new SelectIterable(content.pairs, function (pair, index) {\n            return [pair[0], selector(pair[1], index)];\n          })\n        };\n      });\n    } else {\n      return new DataFrame(function () {\n        var content = _this.getContent();\n\n        return {\n          values: content.values,\n          index: content.index,\n          pairs: content.pairs\n        };\n      });\n    }\n  };\n  /**\r\n   * Static version of the sum function for use with summarize and pivot functions.\r\n   *\r\n   * @param series Input series to be summed.\r\n   *\r\n   * @returns Returns the sum of the number values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = dataFrame.summarize({\r\n   *      ColumnToBeSummed: Series.sum,\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  Series.sum = function (series) {\n    return series.sum();\n  };\n  /**\r\n   * Sum the values in a series and returns the result.\r\n   *\r\n   * @returns Returns the sum of the number values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const totalSales = salesFigures.sum();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.sum = function () {\n    if (this.none()) {\n      return 0;\n    }\n\n    var numberSeries = this; // Have to assume we are working with a number series here.\n\n    return numberSeries.aggregate(function (prev, value) {\n      return prev + value;\n    });\n  };\n  /**\r\n   * Static version of the average function for use with summarize and pivot functions.\r\n   *\r\n   * @param series Input series to be averaged.\r\n   *\r\n   * @returns Returns the average of the number values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = dataFrame.summarize({\r\n   *      ColumnToBeAveraged: Series.average,\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  Series.average = function (series) {\n    return series.average();\n  };\n  /**\r\n   * Average the values in a series and returns the result\r\n   *\r\n   * @returns Returns the average of the number values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const averageSales = salesFigures.average();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.average = function () {\n    var count = this.count();\n\n    if (count > 0) {\n      return this.sum() / count;\n    } else {\n      return 0;\n    }\n  };\n  /**\r\n   * Static version of the median function for use with summarize and pivot functions.\r\n   *\r\n   * @param series Input series to find the median of.\r\n   *\r\n   * @returns Returns the median of the number values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = dataFrame.summarize({\r\n   *      InputColumn: Series.median,\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  Series.median = function (series) {\n    return series.median();\n  };\n  /**\r\n   * Get the median value in the series.\r\n   * Note that this sorts the series, which can be expensive.\r\n   *\r\n   * @returns Returns the median of the values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const medianSales = salesFigures.median();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.median = function () {\n    //\n    // From here: http://stackoverflow.com/questions/5275115/add-a-median-method-to-a-list\n    //\n    var numberSeries = this; // Have to assume we are working with a number series here.\n\n    var count = numberSeries.count();\n\n    if (count === 0) {\n      return 0;\n    }\n\n    var ordered = numberSeries.orderBy(function (value) {\n      return value;\n    }).toArray();\n\n    if (count % 2 == 0) {\n      // Even.\n      var a = ordered[count / 2 - 1];\n      var b = ordered[count / 2];\n      return (a + b) / 2;\n    } // Odd\n\n\n    return ordered[Math.floor(count / 2)];\n  };\n  /**\r\n   * Static version of the standard deviation function for use with summarize and pivot functions.\r\n   *\r\n   * @param series Input series to find the standard deviation of.\r\n   *\r\n   * @returns Returns the standard deviation of the values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = dataFrame.summarize({\r\n   *      InputColumn: Series.std,\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  Series.std = function (series) {\n    return series.std();\n  };\n  /**\r\n   * Get the standard deviation of number values in the series.\r\n   *\r\n   * @returns Returns the standard deviation of the values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const salesStdDev = salesFigures.std();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.std = function () {\n    // Have to assume we are working with a number series here.\n    // Bake so we don't evaluate multiple times.\n    // TODO: Caching can help here.\n    var numberSeries = this.bake();\n    var valueCount = numberSeries.count();\n\n    if (valueCount === 0) {\n      return 0;\n    } // https://en.wikipedia.org/wiki/Standard_deviation\n\n\n    var mean = numberSeries.average();\n    var sumOfSquaredDiffs = numberSeries.select(function (value) {\n      var diffFromMean = value - mean;\n      return diffFromMean * diffFromMean;\n    }).sum();\n    return Math.sqrt(sumOfSquaredDiffs / valueCount);\n  };\n  /**\r\n   * Static version of the min function for use with summarize and pivot functions.\r\n   *\r\n   * @param series Input series to find the minimum of.\r\n   *\r\n   * @returns Returns the minimum of number values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = dataFrame.summarize({\r\n   *      Column: Series.min,\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  Series.min = function (series) {\n    return series.min();\n  };\n  /**\r\n   * Get the min value in the series.\r\n   *\r\n   * @returns Returns the minimum of the number values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const minSales = salesFigures.min();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.min = function () {\n    var numberSeries = this; // Have to assume we are working with a number series here.\n\n    return numberSeries.aggregate(function (prev, value) {\n      return Math.min(prev, value);\n    });\n  };\n  /**\r\n   * Static version of the max function for use with summarize and pivot functions.\r\n   *\r\n   * @param series Input series to find the maximum of.\r\n   *\r\n   * @returns Returns the maximum of number values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const summary = dataFrame.summarize({\r\n   *      Column: Series.max,\r\n   * });\r\n   * </pre>\r\n   */\n\n\n  Series.max = function (series) {\n    return series.max();\n  };\n  /**\r\n   * Get the max value in the series.\r\n   *\r\n   * @returns Returns the maximum of the number values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const maxSales = salesFigures.max();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.max = function () {\n    var numberSeries = this; // Have to assume we are working with a number series here.\n\n    return numberSeries.aggregate(function (prev, value) {\n      return Math.max(prev, value);\n    });\n  };\n  /**\r\n   * Invert the sign of every number value in the series.\r\n   * This assumes that the input series contains numbers.\r\n   *\r\n   * @returns Returns a new series with all number values inverted.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const inverted = series.invert();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.invert = function () {\n    var inputSeries = this;\n    return inputSeries.select(function (value) {\n      return -value;\n    });\n  };\n  /**\r\n   * Counts the number of sequential values where the predicate evaluates to truthy.\r\n   * Outputs 0 for values when the predicate evaluates to falsy.\r\n   *\r\n   * @param predicate User-defined function. Should evaluate to truthy to activate the counter or falsy to deactivate it.\r\n   *\r\n   * @returns Returns a new series that counts up the number of sequential values where the predicate evaluates to truthy. 0 values appear when the prediate evaluates to falsy.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = new Series([ 1, 10, 3, 15, 8, 5 ]);\r\n   * const counted = series.counter(value => value >= 3);\r\n   * console.log(counted.toString());\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.counter = function (predicate) {\n    return this.groupSequentialBy(predicate).selectMany(function (group, i) {\n      if (predicate(group.first())) {\n        // This group matches the predicate.\n        return range(1, group.count()).withIndex(group.getIndex()).toPairs(); //TODO: selectMany wipes the index. It needs to respect it!\n      } else {\n        // This group doesn't match the predicate.\n        return replicate(0, group.count()).withIndex(group.getIndex()).toPairs(); //TODO: selectMany wipes the index. It needs to respect it!\n      }\n    }).withIndex(function (pair) {\n      return pair[0];\n    }).select(function (pair) {\n      return pair[1];\n    });\n  };\n  /**\r\n   * Gets a new series in reverse order.\r\n   *\r\n   * @return Returns a new series that is the reverse of the original.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const reversed = series.reverse();\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.reverse = function () {\n    var _this = this;\n\n    return new Series(function () {\n      return {\n        values: new ReverseIterable(_this.getContent().values),\n        index: new ReverseIterable(_this.getContent().index),\n        pairs: new ReverseIterable(_this.getContent().pairs)\n      };\n    });\n  };\n  /**\r\n   * Returns only the set of values in the series that are distinct.\r\n   * Provide a user-defined selector to specify criteria for determining the distinctness.\r\n   * This can be used to remove duplicate values from the series.\r\n   *\r\n   * @param selector Optional user-defined selector function that specifies the criteria used to make comparisons for duplicate values.\r\n   *\r\n   * @return Returns a series containing only unique values in the series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const uniqueValues = series.distinct(); // Get only non-duplicated value in the series.\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const bucketedValues = series.distinct(value => Math.floor(value / 10)); // Lump values into buckets of 10.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.distinct = function (selector) {\n    var _this = this;\n\n    return new Series(function () {\n      return {\n        values: new DistinctIterable(_this.getContent().values, selector),\n        pairs: new DistinctIterable(_this.getContent().pairs, function (pair) {\n          return selector && selector(pair[1]) || pair[1];\n        })\n      };\n    });\n  };\n  /**\r\n   * Collects values in the series into a new series of groups according to a user-defined selector function.\r\n   *\r\n   * @param selector User-defined selector function that specifies the criteriay to group by.\r\n   *\r\n   * @return Returns a new series of groups. Each group is a series with values that have been grouped by the 'selector' function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const sales = ... product sales ...\r\n   * const salesByProduct = sales.groupBy(sale => sale.ProductId);\r\n   * for (const productSalesGroup of salesByProduct) {\r\n   *      // ... do something with each product group ...\r\n   *      const productId = productSalesGroup.first().ProductId;\r\n   *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\r\n   *      console.log(totalSalesForProduct);\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.groupBy = function (selector) {\n    var _this = this;\n\n    if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.groupBy' to be a selector function that determines the value to group the series by.\");\n    return new Series(function () {\n      var groups = []; // Each group, in order of discovery.\n\n      var groupMap = {}; // Group map, records groups by key.\n\n      var valueIndex = 0;\n\n      try {\n        for (var _a = __values(_this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var pair = _b.value;\n          var groupKey = selector(pair[1], valueIndex);\n          ++valueIndex;\n          var existingGroup = groupMap[groupKey];\n\n          if (existingGroup) {\n            existingGroup.push(pair);\n          } else {\n            var newGroup = [];\n            newGroup.push(pair);\n            groups.push(newGroup);\n            groupMap[groupKey] = newGroup;\n          }\n        }\n      } catch (e_15_1) {\n        e_15 = {\n          error: e_15_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_15) throw e_15.error;\n        }\n      }\n\n      return {\n        values: groups.map(function (group) {\n          return new Series({\n            pairs: group\n          });\n        })\n      };\n\n      var e_15, _c;\n    });\n  };\n  /**\r\n   * Collects values in the series into a new series of groups based on if the values are the same or according to a user-defined selector function.\r\n   *\r\n   * @param selector Optional selector that specifies the criteria for grouping.\r\n   *\r\n   * @return Returns a new series of groups. Each group is a series with values that are the same or have been grouped by the 'selector' function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Some ultra simple stock trading strategy backtesting...\r\n   * const dailyStockPrice = ... daily stock price for a company ...\r\n   * const priceGroups  = dailyStockPrice.groupBy(day => day.close > day.movingAverage);\r\n   * for (const priceGroup of priceGroups) {\r\n   *      // ... do something with each stock price group ...\r\n   *\r\n   *      const firstDay = priceGroup.first();\r\n   *      if (firstDay.close > movingAverage) {\r\n   *          // This group of days has the stock price above its moving average.\r\n   *          // ... maybe enter a long trade here ...\r\n   *      }\r\n   *      else {\r\n   *          // This group of days has the stock price below its moving average.\r\n   *          // ... maybe enter a short trade here ...\r\n   *      }\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.groupSequentialBy = function (selector) {\n    if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.groupSequentialBy' to be a selector function that determines the value to group the series by.\");\n    } else {\n      selector = function selector(value) {\n        return value;\n      };\n    }\n\n    return this.variableWindow(function (a, b) {\n      return selector(a) === selector(b);\n    });\n  };\n  /**\r\n   * Concatenate multiple series into a single series.\r\n   *\r\n   * @param series - Array of series to concatenate.\r\n   *\r\n   * @returns Returns a single series concatenated from multiple input series.\r\n   */\n\n\n  Series.concat = function (series) {\n    if (!isArray(series)) throw new Error(\"Expected 'series' parameter to 'Series.concat' to be an array of series.\");\n    return new Series(function () {\n      var upcast = series; // Upcast so that we can access private index, values and pairs.\n\n      var contents = upcast.map(function (series) {\n        return series.getContent();\n      });\n      return {\n        values: new ConcatIterable(contents.map(function (content) {\n          return content.values;\n        })),\n        pairs: new ConcatIterable(contents.map(function (content) {\n          return content.pairs;\n        }))\n      };\n    });\n  };\n  /**\r\n   * Concatenate multiple other series onto this series.\r\n   *\r\n   * @param series Multiple arguments. Each can be either a series or an array of series.\r\n   *\r\n   * @return Returns a single series concatenated from multiple input series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const concatenated = a.concat(b);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const concatenated = a.concat(b, c);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const concatenated = a.concat([b, c]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const concatenated = a.concat(b, [c, d]);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const otherSeries = [... array of series...];\r\n   * const concatenated = a.concat(otherSeries);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.concat = function () {\n    var series = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      series[_i] = arguments[_i];\n    }\n\n    var concatInput = [this];\n\n    try {\n      for (var series_2 = __values(series), series_2_1 = series_2.next(); !series_2_1.done; series_2_1 = series_2.next()) {\n        var input = series_2_1.value;\n\n        if (isArray(input)) {\n          try {\n            for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {\n              var subInput = input_1_1.value;\n              concatInput.push(subInput);\n            }\n          } catch (e_16_1) {\n            e_16 = {\n              error: e_16_1\n            };\n          } finally {\n            try {\n              if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);\n            } finally {\n              if (e_16) throw e_16.error;\n            }\n          }\n        } else {\n          concatInput.push(input);\n        }\n      }\n    } catch (e_17_1) {\n      e_17 = {\n        error: e_17_1\n      };\n    } finally {\n      try {\n        if (series_2_1 && !series_2_1.done && (_b = series_2.return)) _b.call(series_2);\n      } finally {\n        if (e_17) throw e_17.error;\n      }\n    }\n\n    return Series.concat(concatInput);\n\n    var e_17, _b, e_16, _a;\n  };\n  /**\r\n  * Zip together multiple series to create a new series.\r\n  * Preserves the index of the first series.\r\n  *\r\n  * @param series - An iterable of series to be zipped.\r\n  * @param zipper - Selector function that produces a new series based on the input series.\r\n  *\r\n  * @returns Returns a single series zipped from multiple input series.\r\n  */\n\n\n  Series.zip = function (series, zipper) {\n    var input = Array.from(series);\n\n    if (input.length === 0) {\n      return new Series();\n    }\n\n    var firstSeries = input[0];\n\n    if (firstSeries.none()) {\n      return new Series();\n    }\n\n    return new Series(function () {\n      var firstSeriesUpCast = firstSeries;\n      var upcast = input; // Upcast so that we can access private index, values and pairs.\n\n      return {\n        index: firstSeriesUpCast.getContent().index,\n        values: new ZipIterable(upcast.map(function (s) {\n          return s.getContent().values;\n        }), zipper)\n      };\n    });\n  };\n\n  Series.prototype.zip = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var selector = args[args.length - 1];\n    var input = [this].concat(args.slice(0, args.length - 1));\n    return Series.zip(input, function (values) {\n      return selector.apply(void 0, __spread(values));\n    });\n  };\n  /**\r\n   * Sorts the series in ascending order by a value defined by the user-defined selector function.\r\n   *\r\n   * @param selector User-defined selector function that selects the value to sort by.\r\n   *\r\n   * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const orderedSeries = series.orderBy(value => value);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const orderedSeries = series.orderBy(value => value.NestedValue);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.orderBy = function (selector) {\n    var content = this.getContent();\n    return new OrderedSeries({\n      values: content.values,\n      pairs: content.pairs,\n      selector: selector,\n      direction: Direction.Ascending,\n      parent: null\n    });\n  };\n  /**\r\n   * Sorts the series in descending order by a value defined by the user-defined selector function.\r\n   *\r\n   * @param selector User-defined selector function that selects the value to sort by.\r\n   *\r\n   * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const orderedSeries = series.orderByDescending(value => value);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const orderedSeries = series.orderByDescending(value => value.NestedValue);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.orderByDescending = function (selector) {\n    var content = this.getContent();\n    return new OrderedSeries({\n      values: content.values,\n      pairs: content.pairs,\n      selector: selector,\n      direction: Direction.Descending,\n      parent: null\n    });\n  };\n  /**\r\n   * Creates a new series by merging two input dataframes.\r\n   * The resulting series contains the union of value from the two input series.\r\n   * These are the unique combination of values in both series.\r\n   * This is basically a concatenation and then elimination of duplicates.\r\n   *\r\n   * @param other The other series to merge.\r\n   * @param selector Optional user-defined selector function that selects the value to compare to determine distinctness.\r\n   *\r\n   * @return Returns the union of the two series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesA = ...\r\n   * const seriesB = ...\r\n   * const merged = seriesA.union(seriesB);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Merge two sets of customer records that may contain the same\r\n   * // customer record in each set. This is basically a concatenation\r\n   * // of the series and then an elimination of any duplicate records\r\n   * // that result.\r\n   * const customerRecordsA = ...\r\n   * const customerRecordsB = ...\r\n   * const mergedCustomerRecords = customerRecordsA.union(\r\n   *      customerRecordsB,\r\n   *      customerRecord => customerRecord.CustomerId\r\n   * );\r\n   * </pre>\r\n   *\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Note that you can achieve the exact same result as the previous\r\n   * // example by doing a {@link Series.concat) and {@link Series.distinct}\r\n   * // of the input series and then an elimination of any duplicate records\r\n   * // that result.\r\n   * const customerRecordsA = ...\r\n   * const customerRecordsB = ...\r\n   * const mergedCustomerRecords = customerRecordsA\r\n   *      .concat(customerRecordsB)\r\n   *      .distinct(customerRecord => customerRecord.CustomerId);\r\n   * </pre>\r\n   *\r\n   */\n\n\n  Series.prototype.union = function (other, selector) {\n    if (selector) {\n      if (!isFunction(selector)) throw new Error(\"Expected optional 'selector' parameter to 'Series.union' to be a selector function.\");\n    }\n\n    return this.concat(other).distinct(selector);\n  };\n  /**\r\n   * Creates a new series by merging two input series.\r\n   * The resulting series contains the intersection of values from the two input series.\r\n   * These are only the values that appear in both series.\r\n   *\r\n   * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\r\n   * @param outerSelector Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\r\n   * @param innerSelector Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\r\n   *\r\n   * @return Returns a new series that contains the intersection of values from the two input series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesA = ...\r\n   * const seriesB = ...\r\n   * const mergedDf = seriesA.intersection(seriesB);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Merge two sets of customer records to find only the\r\n   * // customers that appears in both.\r\n   * const customerRecordsA = ...\r\n   * const customerRecordsB = ...\r\n   * const intersectionOfCustomerRecords = customerRecordsA.intersection(\r\n   *      customerRecordsB,\r\n   *      customerRecord => customerRecord.CustomerId\r\n   * );\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.intersection = function (inner, outerSelector, innerSelector) {\n    if (outerSelector) {\n      if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'Series.intersection' to be a function.\");\n    } else {\n      outerSelector = function outerSelector(value) {\n        return value;\n      };\n    }\n\n    if (innerSelector) {\n      if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'Series.intersection' to be a function.\");\n    } else {\n      innerSelector = function innerSelector(value) {\n        return value;\n      };\n    }\n\n    var outer = this;\n    return outer.where(function (outerValue) {\n      var outerKey = outerSelector(outerValue);\n      return inner.where(function (innerValue) {\n        return outerKey === innerSelector(innerValue);\n      }).any();\n    });\n  };\n  /**\r\n   * Creates a new series by merging two input series.\r\n   * The resulting series contains only the values from the 1st series that don't appear in the 2nd series.\r\n   * This is essentially subtracting the values from the 2nd series from the 1st and creating a new series with the remaining values.\r\n   *\r\n   * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\r\n   * @param outerSelector Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\r\n   * @param innerSelector Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\r\n   *\r\n   * @return Returns a new series that contains only the values from the 1st series that don't appear in the 2nd series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const seriesA = ...\r\n   * const seriesB = ...\r\n   * const remainingDf = seriesA.except(seriesB);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Find the list of customers haven't bought anything recently.\r\n   * const allCustomers = ... list of all customers ...\r\n   * const recentCustomers = ... list of customers who have purchased recently ...\r\n   * const remainingCustomers = allCustomers.except(\r\n   *      recentCustomers,\r\n   *      customerRecord => customerRecord.CustomerId\r\n   * );\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.except = function (inner, outerSelector, innerSelector) {\n    if (outerSelector) {\n      if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'Series.except' to be a function.\");\n    } else {\n      outerSelector = function outerSelector(value) {\n        return value;\n      };\n    }\n\n    if (innerSelector) {\n      if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'Series.except' to be a function.\");\n    } else {\n      innerSelector = function innerSelector(value) {\n        return value;\n      };\n    }\n\n    var outer = this;\n    return outer.where(function (outerValue) {\n      var outerKey = outerSelector(outerValue);\n      return inner.where(function (innerValue) {\n        return outerKey === innerSelector(innerValue);\n      }).none();\n    });\n  };\n  /**\r\n    * Creates a new series by merging two input series.\r\n    * The resulting dataframe contains only those value that have matching keys in both input series.\r\n    *\r\n    * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n    * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n    * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n    * @param resultSelector User-defined function that merges outer and inner values.\r\n    *\r\n    * @return Returns the new merged series.\r\n    *\r\n    * @example\r\n    * <pre>\r\n    *\r\n    * // Join together two sets of customers to find those\r\n    * // that have bought both product A and product B.\r\n    * const customerWhoBoughtProductA = ...\r\n    * const customerWhoBoughtProductB = ...\r\n    * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\r\n    *          customerWhoBoughtProductB,\r\n    *          customerA => customerA.CustomerId, // Join key.\r\n    *          customerB => customerB.CustomerId, // Join key.\r\n    *          (customerA, customerB) => {\r\n    *              return {\r\n    *                  // ... merge the results ...\r\n    *              };\r\n    *          }\r\n    *      );\r\n    * </pre>\r\n    */\n\n\n  Series.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector) {\n    if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.join' to be a selector function.\");\n    if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.join' to be a selector function.\");\n    if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.join' to be a selector function.\");\n    var outer = this;\n    return new Series(function () {\n      var innerMap = inner.groupBy(innerKeySelector).toObject(function (group) {\n        return innerKeySelector(group.first());\n      }, function (group) {\n        return group;\n      });\n      var outerContent = outer.getContent();\n      var output = [];\n\n      try {\n        for (var outer_1 = __values(outer), outer_1_1 = outer_1.next(); !outer_1_1.done; outer_1_1 = outer_1.next()) {\n          var outerValue = outer_1_1.value;\n          var outerKey = outerKeySelector(outerValue);\n          var innerGroup = innerMap[outerKey];\n\n          if (innerGroup) {\n            try {\n              for (var innerGroup_1 = __values(innerGroup), innerGroup_1_1 = innerGroup_1.next(); !innerGroup_1_1.done; innerGroup_1_1 = innerGroup_1.next()) {\n                var innerValue = innerGroup_1_1.value;\n                output.push(resultSelector(outerValue, innerValue));\n              }\n            } catch (e_18_1) {\n              e_18 = {\n                error: e_18_1\n              };\n            } finally {\n              try {\n                if (innerGroup_1_1 && !innerGroup_1_1.done && (_a = innerGroup_1.return)) _a.call(innerGroup_1);\n              } finally {\n                if (e_18) throw e_18.error;\n              }\n            }\n          }\n        }\n      } catch (e_19_1) {\n        e_19 = {\n          error: e_19_1\n        };\n      } finally {\n        try {\n          if (outer_1_1 && !outer_1_1.done && (_b = outer_1.return)) _b.call(outer_1);\n        } finally {\n          if (e_19) throw e_19.error;\n        }\n      }\n\n      return {\n        values: output\n      };\n\n      var e_19, _b, e_18, _a;\n    });\n  };\n  /**\r\n   * Creates a new series by merging two input series.\r\n   * The resulting series contains only those values that are only present in one or the other of the series, not both.\r\n   *\r\n   * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n   * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n   * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n   * @param resultSelector User-defined function that merges outer and inner values.\r\n   *\r\n   * Implementation from here:\r\n   *\r\n   * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n   *\r\n   * @return Returns the new merged series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Join together two sets of customers to find those\r\n   * // that have bought either product A or product B, not not both.\r\n   * const customerWhoBoughtProductA = ...\r\n   * const customerWhoBoughtProductB = ...\r\n   * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\r\n   *          customerWhoBoughtProductB,\r\n   *          customerA => customerA.CustomerId, // Join key.\r\n   *          customerB => customerB.CustomerId, // Join key.\r\n   *          (customerA, customerB) => {\r\n   *              return {\r\n   *                  // ... merge the results ...\r\n   *              };\r\n   *          }\r\n   *      );\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.joinOuter = function (inner, outerKeySelector, innerKeySelector, resultSelector) {\n    if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.joinOuter' to be a selector function.\");\n    if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.joinOuter' to be a selector function.\");\n    if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.joinOuter' to be a selector function.\"); // Get the results in the outer that are not in the inner.\n\n    var outer = this;\n    var outerResult = outer.except(inner, outerKeySelector, innerKeySelector).select(function (outer) {\n      return resultSelector(outer, null);\n    }).resetIndex(); // Get the results in the inner that are not in the outer.\n\n    var innerResult = inner.except(outer, innerKeySelector, outerKeySelector).select(function (inner) {\n      return resultSelector(null, inner);\n    }).resetIndex(); // Get the intersection of results between inner and outer.\n\n    var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);\n    return outerResult.concat(intersectionResults).concat(innerResult).resetIndex();\n  };\n  /**\r\n   * Creates a new series by merging two input series.\r\n   * The resulting series contains only those values that are present either in both series or only in the outer (left) series.\r\n   *\r\n   * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n   * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n   * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n   * @param resultSelector User-defined function that merges outer and inner values.\r\n   *\r\n   * Implementation from here:\r\n   *\r\n   * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n   *\r\n   * @return Returns the new merged series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Join together two sets of customers to find those\r\n   * // that have bought either just product A or both product A and product B.\r\n   * const customerWhoBoughtProductA = ...\r\n   * const customerWhoBoughtProductB = ...\r\n   * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\r\n   *          customerWhoBoughtProductB,\r\n   *          customerA => customerA.CustomerId, // Join key.\r\n   *          customerB => customerB.CustomerId, // Join key.\r\n   *          (customerA, customerB) => {\r\n   *              return {\r\n   *                  // ... merge the results ...\r\n   *              };\r\n   *          }\r\n   *      );\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.joinOuterLeft = function (inner, outerKeySelector, innerKeySelector, resultSelector) {\n    if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\n    if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\n    if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.joinOuterLeft' to be a selector function.\"); // Get the results in the outer that are not in the inner.\n\n    var outer = this;\n    var outerResult = outer.except(inner, outerKeySelector, innerKeySelector).select(function (outer) {\n      return resultSelector(outer, null);\n    }).resetIndex(); // Get the intersection of results between inner and outer.\n\n    var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);\n    return outerResult.concat(intersectionResults).resetIndex();\n  };\n  /**\r\n   * Creates a new series by merging two input series.\r\n   * The resulting series contains only those values that are present either in both series or only in the inner (right) series.\r\n   *\r\n   * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n   * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n   * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n   * @param resultSelector User-defined function that merges outer and inner values.\r\n   *\r\n   * Implementation from here:\r\n   *\r\n   * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n   *\r\n   * @return Returns the new merged series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Join together two sets of customers to find those\r\n   * // that have bought either just product B or both product A and product B.\r\n   * const customerWhoBoughtProductA = ...\r\n   * const customerWhoBoughtProductB = ...\r\n   * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\r\n   *          customerWhoBoughtProductB,\r\n   *          customerA => customerA.CustomerId, // Join key.\r\n   *          customerB => customerB.CustomerId, // Join key.\r\n   *          (customerA, customerB) => {\r\n   *              return {\r\n   *                  // ... merge the results ...\r\n   *              };\r\n   *          }\r\n   *      );\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.joinOuterRight = function (inner, outerKeySelector, innerKeySelector, resultSelector) {\n    if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\n    if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\n    if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.joinOuterRight' to be a selector function.\"); // Get the results in the inner that are not in the outer.\n\n    var outer = this;\n    var innerResult = inner.except(outer, innerKeySelector, outerKeySelector).select(function (inner) {\n      return resultSelector(null, inner);\n    }).resetIndex(); // Get the intersection of results between inner and outer.\n\n    var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);\n    return intersectionResults.concat(innerResult).resetIndex();\n  };\n  /**\r\n   * Produces a new series with all string values truncated to the requested maximum length.\r\n   *\r\n   * @param maxLength - The maximum length of the string values after truncation.\r\n   *\r\n   * @returns Returns a new series with strings that are truncated to the specified maximum length.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const truncated = series.truncateStrings(10); // Truncate all string values to max length of 10 characters.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.truncateStrings = function (maxLength) {\n    if (!isNumber(maxLength)) {\n      throw new Error(\"Expected 'maxLength' parameter to 'Series.truncateStrings' to be a number.\");\n    }\n\n    return this.select(function (value) {\n      if (isString(value)) {\n        if (value.length > maxLength) {\n          return value.substring(0, maxLength);\n        }\n      }\n\n      return value;\n    });\n  };\n  /**\r\n   * Produces a new series with all number values rounded to the specified number of places.\r\n   *\r\n   * @param numDecimalPlaces The number of decimal places, defaults to 2.\r\n   *\r\n   * @returns Returns a new series with all number values rounded to the specified number of places.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = ... your data series ...\r\n   * const rounded = series.round(); // Round numbers to two decimal places.\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const series = ... your data series ...\r\n   * const rounded = series.round(3); // Round numbers to three decimal places.\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.round = function (numDecimalPlaces) {\n    if (numDecimalPlaces !== undefined) {\n      if (!isNumber(numDecimalPlaces)) {\n        throw new Error(\"Expected 'numDecimalPlaces' parameter to 'Series.round' to be a number.\");\n      }\n    } else {\n      numDecimalPlaces = 2; // Default to two decimal places.\n    }\n\n    return this.select(function (value) {\n      if (isNumber(value)) {\n        return parseFloat(value.toFixed(numDecimalPlaces));\n      }\n\n      return value;\n    });\n  };\n  /**\r\n   * Insert a pair at the start of the series.\r\n   * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the inserted pair.\r\n   *\r\n   * @param pair The index/value pair to insert.\r\n   *\r\n   * @return Returns a new series with the specified pair inserted.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const newIndex = ... index of the new row ...\r\n   * const newRow = ... the new data row to insert ...\r\n   * const insertedSeries = series.insertPair([newIndex, newRows]);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.insertPair = function (pair) {\n    if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'Series.insertPair' to be an array.\");\n    if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'Series.insertPair' to be an array with two elements. The first element is the index, the second is the value.\");\n    return new Series({\n      pairs: [pair]\n    }).concat(this);\n  };\n  /**\r\n   * Append a pair to the end of a series.\r\n   * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the appended pair.\r\n   *\r\n   * @param pair The index/value pair to append.\r\n   *\r\n   * @return Returns a new series with the specified pair appended.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const newIndex = ... index of the new row ...\r\n   * const newRow = ... the new data row to append ...\r\n   * const appendedSeries = series.appendPair([newIndex, newRows]);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.appendPair = function (pair) {\n    if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'Series.appendPair' to be an array.\");\n    if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'Series.appendPair' to be an array with two elements. The first element is the index, the second is the value.\");\n    return this.concat(new Series({\n      pairs: [pair]\n    }));\n  };\n  /**\r\n   * Fill gaps in a series.\r\n   *\r\n   * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive values, return truthy if there is a gap between the value, or falsey if there is no gap.\r\n   * @param generator User-defined generator function that is passed pairA and pairB, two consecutive values, returns an array of pairs that fills the gap between the values.\r\n   *\r\n   * @return Returns a new series with gaps filled in.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   *   var sequenceWithGaps = ...\r\n   *\r\n   *  // Predicate that determines if there is a gap.\r\n   *  var gapExists = (pairA, pairB) => {\r\n   *      // Returns true if there is a gap.\r\n   *      return true;\r\n   *  };\r\n   *\r\n   *  // Generator function that produces new rows to fill the game.\r\n   *  var gapFiller = (pairA, pairB) => {\r\n   *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\r\n   *      return [\r\n   *          newPair1,\r\n   *          newPair2,\r\n   *          newPair3,\r\n   *      ];\r\n   *  };\r\n   *\r\n   *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.fillGaps = function (comparer, generator) {\n    if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'Series.fillGaps' to be a comparer function that compares two values and returns a boolean.\");\n    if (!isFunction(generator)) throw new Error(\"Expected 'generator' parameter to 'Series.fillGaps' to be a generator function that takes two values and returns an array of generated pairs to span the gap.\");\n    return this.rollingWindow(2).selectMany(function (window) {\n      var pairs = window.toPairs();\n      var pairA = pairs[0];\n      var pairB = pairs[1];\n\n      if (!comparer(pairA, pairB)) {\n        return [pairA];\n      }\n\n      var generatedRows = generator(pairA, pairB);\n      if (!isArray(generatedRows)) throw new Error(\"Expected return from 'generator' parameter to 'Series.fillGaps' to be an array of pairs, instead got a \" + typeof generatedRows);\n      return [pairA].concat(generatedRows);\n    }).withIndex(function (pair) {\n      return pair[0];\n    }).select(function (pair) {\n      return pair[1];\n    }).concat(this.tail(1));\n  };\n  /**\r\n   * Returns the specified default series if the input series is empty.\r\n   *\r\n   * @param defaultSequence Default series to return if the input series is empty.\r\n   *\r\n   * @return Returns 'defaultSequence' if the input series is empty.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const emptySeries = new Series();\r\n   * const defaultSeries = new Series([ 1, 2, 3 ]);\r\n   * expect(emptyDataFrame.defaultIfEmpty(defaultSeries)).to.eql(defaultSeries);\r\n   * </pre>\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const nonEmptySeries = new Series([ 100 ]);\r\n   * const defaultSeries = new Series([ 1, 2, 3 ]);\r\n   * expect(nonEmptySeries.defaultIfEmpty(defaultSeries)).to.eql(nonEmptySeries);\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.defaultIfEmpty = function (defaultSequence) {\n    if (this.none()) {\n      if (defaultSequence instanceof Series) {\n        return defaultSequence;\n      } else if (isArray(defaultSequence)) {\n        return new Series(defaultSequence);\n      } else {\n        throw new Error(\"Expected 'defaultSequence' parameter to 'Series.defaultIfEmpty' to be an array or a series.\");\n      }\n    } else {\n      return this;\n    }\n  };\n  /**\r\n   * Detect the the frequency of the types of the values in the series.\r\n   * This is a good way to understand the shape of your data.\r\n   *\r\n   * @return Returns a {@link DataFrame} with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dataTypes = series.detectTypes();\r\n   * console.log(dataTypes.toString());\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.detectTypes = function () {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var totalValues = _this.count();\n\n      var typeFrequencies = _this.select(function (value) {\n        var valueType = typeof value;\n\n        if (valueType === \"object\") {\n          if (isDate(value)) {\n            valueType = \"date\";\n          }\n        }\n\n        return valueType;\n      }).aggregate({}, function (accumulated, valueType) {\n        var typeInfo = accumulated[valueType];\n\n        if (!typeInfo) {\n          typeInfo = {\n            count: 0\n          };\n          accumulated[valueType] = typeInfo;\n        }\n\n        ++typeInfo.count;\n        return accumulated;\n      });\n\n      return {\n        columnNames: [\"Type\", \"Frequency\"],\n        rows: Object.keys(typeFrequencies).map(function (valueType) {\n          return [valueType, typeFrequencies[valueType].count / totalValues * 100];\n        })\n      };\n    });\n  };\n  /**\r\n   * Detect the frequency of the values in the series.\r\n   * This is a good way to understand the shape of your data.\r\n   *\r\n   * @return Returns a {@link DataFrame} with rows that conform to {@link IValueFrequency} that describes the values contained in the original series.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const dataValues = series.detectValues();\r\n   * console.log(dataValues.toString());\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.detectValues = function () {\n    var _this = this;\n\n    return new DataFrame(function () {\n      var totalValues = _this.count();\n\n      var valueFrequencies = _this.aggregate(new Map(), function (accumulated, value) {\n        var valueInfo = accumulated.get(value);\n\n        if (!valueInfo) {\n          valueInfo = {\n            count: 0,\n            value: value\n          };\n          accumulated.set(value, valueInfo);\n        }\n\n        ++valueInfo.count;\n        return accumulated;\n      });\n\n      return {\n        columnNames: [\"Value\", \"Frequency\"],\n        rows: Array.from(valueFrequencies.keys()).map(function (value) {\n          var valueInfo = valueFrequencies.get(value);\n          return [valueInfo.value, valueInfo.count / totalValues * 100];\n        })\n      };\n    });\n  };\n  /**\r\n   * Organise all values in the series into the specified number of buckets.\r\n   * Assumes that the series is a series of numbers.\r\n   *\r\n   * @param numBuckets - The number of buckets to create.\r\n   *\r\n   * @returns Returns a dataframe containing bucketed values. The input values are divided up into these buckets.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * const buckets = series.bucket(20); // Distribute values into 20 evenly spaced buckets.\r\n   * console.log(buckets.toString());\r\n   * </pre>\r\n   */\n\n\n  Series.prototype.bucket = function (numBuckets) {\n    if (!isNumber(numBuckets)) {\n      throw new Error(\"Expected 'numBuckets' parameter to 'Series.bucket' to be a number.\");\n    }\n\n    if (this.none()) {\n      return new DataFrame();\n    }\n\n    var numberSeries = this;\n    var min = numberSeries.min();\n    var max = numberSeries.max();\n    var range = max - min;\n    var width = range / (numBuckets - 1);\n    return numberSeries.select(function (v) {\n      var bucket = Math.floor((v - min) / width);\n      var bucketMin = bucket * width + min;\n      return {\n        Value: v,\n        Bucket: bucket,\n        Min: bucketMin,\n        Mid: bucketMin + width * 0.5,\n        Max: bucketMin + width\n      };\n    }).inflate();\n  };\n  /***\r\n   * Allows the series to be queried to confirm that it is actually a series.\r\n   * Used from JavaScript to tell the difference between a Series and a DataFrame.\r\n   *\r\n   * @return Returns the string \"series\".\r\n   */\n\n\n  Series.prototype.getTypeCode = function () {\n    return \"series\";\n  };\n\n  Series.defaultCountIterable = new CountIterable();\n  Series.defaultEmptyIterable = new EmptyIterable();\n  return Series;\n}();\n/**\r\n * @hidden\r\n * A series that has been ordered.\r\n */\n\n\nvar OrderedSeries =\n/** @class */\nfunction (_super) {\n  __extends(OrderedSeries, _super);\n\n  function OrderedSeries(config) {\n    var _this = this;\n\n    var valueSortSpecs = [];\n    var pairSortSpecs = [];\n    var sortLevel = 0;\n    var parent = config.parent;\n    var parents = [];\n\n    while (parent !== null) {\n      parents.push(parent);\n      parent = parent.config.parent;\n    }\n\n    parents.reverse();\n\n    try {\n      for (var parents_1 = __values(parents), parents_1_1 = parents_1.next(); !parents_1_1.done; parents_1_1 = parents_1.next()) {\n        var parent_1 = parents_1_1.value;\n        var parentConfig = parent_1.config;\n        valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, parentConfig.selector, parentConfig.direction));\n        pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(parentConfig.selector), parentConfig.direction));\n        ++sortLevel;\n      }\n    } catch (e_20_1) {\n      e_20 = {\n        error: e_20_1\n      };\n    } finally {\n      try {\n        if (parents_1_1 && !parents_1_1.done && (_a = parents_1.return)) _a.call(parents_1);\n      } finally {\n        if (e_20) throw e_20.error;\n      }\n    }\n\n    valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, config.selector, config.direction));\n    pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(config.selector), config.direction));\n    _this = _super.call(this, {\n      values: new OrderedIterable(config.values, valueSortSpecs),\n      pairs: new OrderedIterable(config.pairs, pairSortSpecs)\n    }) || this;\n    _this.config = config;\n    return _this;\n\n    var e_20, _a;\n  } //\n  // Helper function to create a sort spec.\n  //\n\n\n  OrderedSeries.makeSortSpec = function (sortLevel, selector, direction) {\n    return {\n      sortLevel: sortLevel,\n      selector: selector,\n      direction: direction\n    };\n  }; //\n  // Helper function to make a sort selector for pairs, this captures the parent correct when generating the closure.\n  //\n\n\n  OrderedSeries.makePairsSelector = function (selector) {\n    return function (pair, index) {\n      return selector(pair[1], index);\n    };\n  };\n  /**\r\n   * Applys additional sorting (ascending) to an already sorted series.\r\n   *\r\n   * @param selector User-defined selector that selects the additional value to sort by.\r\n   *\r\n   * @return Returns a new series has been additionally sorted by the value chosen by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Order sales by salesperson and then by amount (from least to most).\r\n   * const ordered = sales.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\r\n   * </pre>\r\n   */\n\n\n  OrderedSeries.prototype.thenBy = function (selector) {\n    return new OrderedSeries({\n      values: this.config.values,\n      pairs: this.config.pairs,\n      selector: selector,\n      direction: Direction.Ascending,\n      parent: this\n    });\n  };\n  /**\r\n   * Applys additional sorting (descending) to an already sorted series.\r\n   *\r\n   * @param selector User-defined selector that selects the additional value to sort by.\r\n   *\r\n   * @return Returns a new series has been additionally sorted by the value chosen by the selector function.\r\n   *\r\n   * @example\r\n   * <pre>\r\n   *\r\n   * // Order sales by salesperson and then by amount (from most to least).\r\n   * const ordered = sales.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\r\n   * </pre>\r\n   */\n\n\n  OrderedSeries.prototype.thenByDescending = function (selector) {\n    return new OrderedSeries({\n      values: this.config.values,\n      pairs: this.config.pairs,\n      selector: selector,\n      direction: Direction.Descending,\n      parent: this\n    });\n  };\n\n  return OrderedSeries;\n}(Series);\n/**\r\n * Class that represents an index for a Series.\r\n */\n\n\nvar Index =\n/** @class */\nfunction (_super) {\n  __extends(Index, _super);\n\n  function Index(config) {\n    return _super.call(this, config) || this;\n  }\n  /**\r\n   * Get the type of the index.\r\n   *\r\n   * @returns Returns a string that specifies the type of the index.\r\n   */\n\n\n  Index.prototype.getType = function () {\n    if (!this._type) {\n      //\n      // Detect the type.\n      //\n      if (this.any()) {\n        this._type = determineType(this.first());\n      } else {\n        this._type = 'empty';\n      }\n    }\n\n    return this._type;\n  };\n  /**\r\n   * Get the less than operation for the index.\r\n   *\r\n   * @returns Returns a function that can be used to compare a value against an index value.\r\n   */\n\n\n  Index.prototype.getLessThan = function () {\n    switch (this.getType()) {\n      case \"date\":\n        return function (d1, d2) {\n          return moment(d1).isBefore(d2);\n        };\n\n      case \"string\":\n      case \"number\":\n        return function (v1, v2) {\n          return v1 < v2;\n        };\n\n      case \"empty\":\n        return function () {\n          return true;\n        };\n      // Series is empty, so this makes no difference.\n\n      default:\n        throw new Error(\"No less than operation available for type: \" + this.getType());\n    }\n  };\n  /**\r\n   * Get the less than or equal to operation for the index.\r\n   *\r\n   * @returns Returns a function that can be used to compare a value against an index value.\r\n   */\n\n\n  Index.prototype.getLessThanOrEqualTo = function () {\n    var _this = this;\n\n    return function (v1, v2) {\n      return !_this.getGreaterThan()(v1, v2);\n    }; //TODO: Should expand  this out.\n  };\n  /**\r\n   * Get the greater than operation for the index.\r\n   *\r\n   * @returns Returns a function that can be used to compare a value against an index value.\r\n   */\n\n\n  Index.prototype.getGreaterThan = function () {\n    switch (this.getType()) {\n      case \"date\":\n        return function (d1, d2) {\n          return moment(d1).isAfter(d2);\n        };\n\n      case \"string\":\n      case \"number\":\n        return function (v1, v2) {\n          return v1 > v2;\n        };\n\n      case \"empty\":\n        return function () {\n          return true;\n        };\n      // Series is empty, so this makes no difference.\n\n      default:\n        throw new Error(\"No greater than operation available for type: \" + this.getType());\n    }\n  };\n\n  return Index;\n}(Series);\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar isBuffer = function isBuffer(arg) {\n  return arg instanceof Buffer;\n};\n\nvar inherits_browser = createCommonjsModule(function (module) {\n  if (typeof Object.create === 'function') {\n    // implementation from standard node.js 'util' module\n    module.exports = function inherits(ctor, superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    };\n  } else {\n    // old school shim for old browsers\n    module.exports = function inherits(ctor, superCtor) {\n      ctor.super_ = superCtor;\n\n      var TempCtor = function TempCtor() {};\n\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    };\n  }\n});\nvar inherits = createCommonjsModule(function (module) {\n  try {\n    var util$1 = util;\n    if (typeof util$1.inherits !== 'function') throw '';\n    module.exports = util$1.inherits;\n  } catch (e) {\n    module.exports = inherits_browser;\n  }\n});\nvar util = createCommonjsModule(function (module, exports) {\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n\n    return descriptors;\n  };\n\n  var formatRegExp = /%[sdj%]/g;\n\n  exports.format = function (f) {\n    if (!isString(f)) {\n      var objects = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        objects.push(inspect(arguments[i]));\n      }\n\n      return objects.join(' ');\n    }\n\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    var str = String(f).replace(formatRegExp, function (x) {\n      if (x === '%%') return '%';\n      if (i >= len) return x;\n\n      switch (x) {\n        case '%s':\n          return String(args[i++]);\n\n        case '%d':\n          return Number(args[i++]);\n\n        case '%j':\n          try {\n            return JSON.stringify(args[i++]);\n          } catch (_) {\n            return '[Circular]';\n          }\n\n        default:\n          return x;\n      }\n    });\n\n    for (var x = args[i]; i < len; x = args[++i]) {\n      if (isNull(x) || !isObject(x)) {\n        str += ' ' + x;\n      } else {\n        str += ' ' + inspect(x);\n      }\n    }\n\n    return str;\n  }; // Mark that a method should not be used.\n  // Returns a modified function which warns once by default.\n  // If --no-deprecation is set, then it is a no-op.\n\n\n  exports.deprecate = function (fn, msg) {\n    if (typeof process !== 'undefined' && process.noDeprecation === true) {\n      return fn;\n    } // Allow for deprecating things in the process of starting up.\n\n\n    if (typeof process === 'undefined') {\n      return function () {\n        return exports.deprecate(fn, msg).apply(this, arguments);\n      };\n    }\n\n    var warned = false;\n\n    function deprecated() {\n      if (!warned) {\n        if (process.throwDeprecation) {\n          throw new Error(msg);\n        } else if (process.traceDeprecation) {\n          console.trace(msg);\n        } else {\n          console.error(msg);\n        }\n\n        warned = true;\n      }\n\n      return fn.apply(this, arguments);\n    }\n\n    return deprecated;\n  };\n\n  var debugs = {};\n  var debugEnviron;\n\n  exports.debuglog = function (set) {\n    if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';\n    set = set.toUpperCase();\n\n    if (!debugs[set]) {\n      if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n        var pid = process.pid;\n\n        debugs[set] = function () {\n          var msg = exports.format.apply(exports, arguments);\n          console.error('%s %d: %s', set, pid, msg);\n        };\n      } else {\n        debugs[set] = function () {};\n      }\n    }\n\n    return debugs[set];\n  };\n  /**\n   * Echos the value of a value. Trys to print the value out\n   * in the best way possible given the different types.\n   *\n   * @param {Object} obj The object to print out.\n   * @param {Object} opts Optional options object that alters the output.\n   */\n\n  /* legacy: obj, showHidden, depth, colors*/\n\n\n  function inspect(obj, opts) {\n    // default options\n    var ctx = {\n      seen: [],\n      stylize: stylizeNoColor\n    }; // legacy...\n\n    if (arguments.length >= 3) ctx.depth = arguments[2];\n    if (arguments.length >= 4) ctx.colors = arguments[3];\n\n    if (isBoolean(opts)) {\n      // legacy...\n      ctx.showHidden = opts;\n    } else if (opts) {\n      // got an \"options\" object\n      exports._extend(ctx, opts);\n    } // set default options\n\n\n    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n    if (isUndefined(ctx.depth)) ctx.depth = 2;\n    if (isUndefined(ctx.colors)) ctx.colors = false;\n    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n  }\n\n  exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\n  inspect.colors = {\n    'bold': [1, 22],\n    'italic': [3, 23],\n    'underline': [4, 24],\n    'inverse': [7, 27],\n    'white': [37, 39],\n    'grey': [90, 39],\n    'black': [30, 39],\n    'blue': [34, 39],\n    'cyan': [36, 39],\n    'green': [32, 39],\n    'magenta': [35, 39],\n    'red': [31, 39],\n    'yellow': [33, 39]\n  }; // Don't use 'blue' not visible on cmd.exe\n\n  inspect.styles = {\n    'special': 'cyan',\n    'number': 'yellow',\n    'boolean': 'yellow',\n    'undefined': 'grey',\n    'null': 'bold',\n    'string': 'green',\n    'date': 'magenta',\n    // \"name\": intentionally not styling\n    'regexp': 'red'\n  };\n\n  function stylizeWithColor(str, styleType) {\n    var style = inspect.styles[styleType];\n\n    if (style) {\n      return \"\\x1B[\" + inspect.colors[style][0] + 'm' + str + \"\\x1B[\" + inspect.colors[style][1] + 'm';\n    } else {\n      return str;\n    }\n  }\n\n  function stylizeNoColor(str, styleType) {\n    return str;\n  }\n\n  function arrayToHash(array) {\n    var hash = {};\n    array.forEach(function (val, idx) {\n      hash[val] = true;\n    });\n    return hash;\n  }\n\n  function formatValue(ctx, value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special\n    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.\n    !(value.constructor && value.constructor.prototype === value)) {\n      var ret = value.inspect(recurseTimes, ctx);\n\n      if (!isString(ret)) {\n        ret = formatValue(ctx, ret, recurseTimes);\n      }\n\n      return ret;\n    } // Primitive types cannot have properties\n\n\n    var primitive = formatPrimitive(ctx, value);\n\n    if (primitive) {\n      return primitive;\n    } // Look up the keys of the object.\n\n\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n\n    if (ctx.showHidden) {\n      keys = Object.getOwnPropertyNames(value);\n    } // IE doesn't make error fields non-enumerable\n    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\n\n    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n      return formatError(value);\n    } // Some type of object without properties can be shortcutted.\n\n\n    if (keys.length === 0) {\n      if (isFunction(value)) {\n        var name = value.name ? ': ' + value.name : '';\n        return ctx.stylize('[Function' + name + ']', 'special');\n      }\n\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      }\n\n      if (isDate(value)) {\n        return ctx.stylize(Date.prototype.toString.call(value), 'date');\n      }\n\n      if (isError(value)) {\n        return formatError(value);\n      }\n    }\n\n    var base = '',\n        array = false,\n        braces = ['{', '}']; // Make Array say that they are Array\n\n    if (isArray(value)) {\n      array = true;\n      braces = ['[', ']'];\n    } // Make functions say that they are functions\n\n\n    if (isFunction(value)) {\n      var n = value.name ? ': ' + value.name : '';\n      base = ' [Function' + n + ']';\n    } // Make RegExps say that they are RegExps\n\n\n    if (isRegExp(value)) {\n      base = ' ' + RegExp.prototype.toString.call(value);\n    } // Make dates with properties first say the date\n\n\n    if (isDate(value)) {\n      base = ' ' + Date.prototype.toUTCString.call(value);\n    } // Make error with message first say the error\n\n\n    if (isError(value)) {\n      base = ' ' + formatError(value);\n    }\n\n    if (keys.length === 0 && (!array || value.length == 0)) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      } else {\n        return ctx.stylize('[Object]', 'special');\n      }\n    }\n\n    ctx.seen.push(value);\n    var output;\n\n    if (array) {\n      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n      output = keys.map(function (key) {\n        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n      });\n    }\n\n    ctx.seen.pop();\n    return reduceToSingleString(output, base, braces);\n  }\n\n  function formatPrimitive(ctx, value) {\n    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n\n    if (isString(value)) {\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n    }\n\n    if (isNumber(value)) return ctx.stylize('' + value, 'number');\n    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is \"object\", so special case here.\n\n    if (isNull(value)) return ctx.stylize('null', 'null');\n  }\n\n  function formatError(value) {\n    return '[' + Error.prototype.toString.call(value) + ']';\n  }\n\n  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n\n    for (var i = 0, l = value.length; i < l; ++i) {\n      if (hasOwnProperty(value, String(i))) {\n        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n      } else {\n        output.push('');\n      }\n    }\n\n    keys.forEach(function (key) {\n      if (!key.match(/^\\d+$/)) {\n        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n      }\n    });\n    return output;\n  }\n\n  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || {\n      value: value[key]\n    };\n\n    if (desc.get) {\n      if (desc.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (desc.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n\n    if (!hasOwnProperty(visibleKeys, key)) {\n      name = '[' + key + ']';\n    }\n\n    if (!str) {\n      if (ctx.seen.indexOf(desc.value) < 0) {\n        if (isNull(recurseTimes)) {\n          str = formatValue(ctx, desc.value, null);\n        } else {\n          str = formatValue(ctx, desc.value, recurseTimes - 1);\n        }\n\n        if (str.indexOf('\\n') > -1) {\n          if (array) {\n            str = str.split('\\n').map(function (line) {\n              return '  ' + line;\n            }).join('\\n').substr(2);\n          } else {\n            str = '\\n' + str.split('\\n').map(function (line) {\n              return '   ' + line;\n            }).join('\\n');\n          }\n        }\n      } else {\n        str = ctx.stylize('[Circular]', 'special');\n      }\n    }\n\n    if (isUndefined(name)) {\n      if (array && key.match(/^\\d+$/)) {\n        return str;\n      }\n\n      name = JSON.stringify('' + key);\n\n      if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n        name = name.substr(1, name.length - 2);\n        name = ctx.stylize(name, 'name');\n      } else {\n        name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n        name = ctx.stylize(name, 'string');\n      }\n    }\n\n    return name + ': ' + str;\n  }\n\n  function reduceToSingleString(output, base, braces) {\n    var length = output.reduce(function (prev, cur) {\n      if (cur.indexOf('\\n') >= 0) ;\n      return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n    }, 0);\n\n    if (length > 60) {\n      return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n    }\n\n    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n  } // NOTE: These type checking functions intentionally don't use `instanceof`\n  // because it is fragile and can be easily faked with `Object.create()`.\n\n\n  function isArray(ar) {\n    return Array.isArray(ar);\n  }\n\n  exports.isArray = isArray;\n\n  function isBoolean(arg) {\n    return typeof arg === 'boolean';\n  }\n\n  exports.isBoolean = isBoolean;\n\n  function isNull(arg) {\n    return arg === null;\n  }\n\n  exports.isNull = isNull;\n\n  function isNullOrUndefined(arg) {\n    return arg == null;\n  }\n\n  exports.isNullOrUndefined = isNullOrUndefined;\n\n  function isNumber(arg) {\n    return typeof arg === 'number';\n  }\n\n  exports.isNumber = isNumber;\n\n  function isString(arg) {\n    return typeof arg === 'string';\n  }\n\n  exports.isString = isString;\n\n  function isSymbol(arg) {\n    return typeof arg === 'symbol';\n  }\n\n  exports.isSymbol = isSymbol;\n\n  function isUndefined(arg) {\n    return arg === void 0;\n  }\n\n  exports.isUndefined = isUndefined;\n\n  function isRegExp(re) {\n    return isObject(re) && objectToString(re) === '[object RegExp]';\n  }\n\n  exports.isRegExp = isRegExp;\n\n  function isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n  }\n\n  exports.isObject = isObject;\n\n  function isDate(d) {\n    return isObject(d) && objectToString(d) === '[object Date]';\n  }\n\n  exports.isDate = isDate;\n\n  function isError(e) {\n    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);\n  }\n\n  exports.isError = isError;\n\n  function isFunction(arg) {\n    return typeof arg === 'function';\n  }\n\n  exports.isFunction = isFunction;\n\n  function isPrimitive(arg) {\n    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol\n    typeof arg === 'undefined';\n  }\n\n  exports.isPrimitive = isPrimitive;\n  exports.isBuffer = isBuffer;\n\n  function objectToString(o) {\n    return Object.prototype.toString.call(o);\n  }\n\n  function pad(n) {\n    return n < 10 ? '0' + n.toString(10) : n.toString(10);\n  }\n\n  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34\n\n  function timestamp() {\n    var d = new Date();\n    var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');\n    return [d.getDate(), months[d.getMonth()], time].join(' ');\n  } // log is just a thin wrapper to console.log that prepends a timestamp\n\n\n  exports.log = function () {\n    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n  };\n  /**\n   * Inherit the prototype methods from one constructor into another.\n   *\n   * The Function.prototype.inherits from lang.js rewritten as a standalone\n   * function (not on Function.prototype). NOTE: If this file is to be loaded\n   * during bootstrapping this function needs to be rewritten using some native\n   * functions as prototype setup using normal JavaScript does not work as\n   * expected during bootstrapping (see mirror.js in r114903).\n   *\n   * @param {function} ctor Constructor function which needs to inherit the\n   *     prototype.\n   * @param {function} superCtor Constructor function to inherit prototype from.\n   */\n\n\n  exports.inherits = inherits;\n\n  exports._extend = function (origin, add) {\n    // Don't do anything if add isn't an object\n    if (!add || !isObject(add)) return origin;\n    var keys = Object.keys(add);\n    var i = keys.length;\n\n    while (i--) {\n      origin[keys[i]] = add[keys[i]];\n    }\n\n    return origin;\n  };\n\n  function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\n  exports.promisify = function promisify(original) {\n    if (typeof original !== 'function') throw new TypeError('The \"original\" argument must be of type Function');\n\n    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n      var fn = original[kCustomPromisifiedSymbol];\n\n      if (typeof fn !== 'function') {\n        throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n      }\n\n      Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n        value: fn,\n        enumerable: false,\n        writable: false,\n        configurable: true\n      });\n      return fn;\n    }\n\n    function fn() {\n      var promiseResolve, promiseReject;\n      var promise = new Promise(function (resolve, reject) {\n        promiseResolve = resolve;\n        promiseReject = reject;\n      });\n      var args = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n      }\n\n      args.push(function (err, value) {\n        if (err) {\n          promiseReject(err);\n        } else {\n          promiseResolve(value);\n        }\n      });\n\n      try {\n        original.apply(this, args);\n      } catch (err) {\n        promiseReject(err);\n      }\n\n      return promise;\n    }\n\n    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    });\n    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));\n  };\n\n  exports.promisify.custom = kCustomPromisifiedSymbol;\n\n  function callbackifyOnRejected(reason, cb) {\n    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n    // Because `null` is a special error value in callbacks which means \"no error\n    // occurred\", we error-wrap so the callback consumer can distinguish between\n    // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n    if (!reason) {\n      var newReason = new Error('Promise was rejected with a falsy value');\n      newReason.reason = reason;\n      reason = newReason;\n    }\n\n    return cb(reason);\n  }\n\n  function callbackify(original) {\n    if (typeof original !== 'function') {\n      throw new TypeError('The \"original\" argument must be of type Function');\n    } // We DO NOT return the promise as it gives the user a false sense that\n    // the promise is actually somehow related to the callback's execution\n    // and that the callback throwing will reject the promise.\n\n\n    function callbackified() {\n      var args = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n      }\n\n      var maybeCb = args.pop();\n\n      if (typeof maybeCb !== 'function') {\n        throw new TypeError('The last argument must be of type Function');\n      }\n\n      var self = this;\n\n      var cb = function cb() {\n        return maybeCb.apply(self, arguments);\n      }; // In true node style we process the callback on `nextTick` with all the\n      // implications (stack, `uncaughtException`, `async_hooks`)\n\n\n      original.apply(this, args).then(function (ret) {\n        process.nextTick(cb, null, ret);\n      }, function (rej) {\n        process.nextTick(callbackifyOnRejected, rej, cb);\n      });\n    }\n\n    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));\n    return callbackified;\n  }\n\n  exports.callbackify = callbackify;\n});\nvar util_1 = util.format;\nvar util_2 = util.deprecate;\nvar util_3 = util.debuglog;\nvar util_4 = util.inspect;\nvar util_5 = util.isArray;\nvar util_6 = util.isBoolean;\nvar util_7 = util.isNull;\nvar util_8 = util.isNullOrUndefined;\nvar util_9 = util.isNumber;\nvar util_10 = util.isString;\nvar util_11 = util.isSymbol;\nvar util_12 = util.isUndefined;\nvar util_13 = util.isRegExp;\nvar util_14 = util.isObject;\nvar util_15 = util.isDate;\nvar util_16 = util.isError;\nvar util_17 = util.isFunction;\nvar util_18 = util.isPrimitive;\nvar util_19 = util.isBuffer;\nvar util_20 = util.log;\nvar util_21 = util.inherits;\nvar util_22 = util._extend;\nvar util_23 = util.promisify;\nvar util_24 = util.callbackify;\nmoment.extend(customParseFormat);\n/**\r\n * Convert a regular JavaScript obejct to a dataframe.\r\n * Each row in the dataframe represents a field from the object.\r\n *\r\n * @param obj - The JavaScript object to convert to a dataframe.\r\n *\r\n * @returns Returns a dataframe that lists the fields in the pass-in object.\r\n */\n\nfunction fromObject(obj) {\n  return new DataFrame(Object.keys(obj).map(function (fieldName) {\n    return {\n      Field: fieldName,\n      Value: obj[fieldName]\n    };\n  }));\n}\n/**\r\n * Deserialize a dataframe from a JSON text string.\r\n *\r\n * @param jsonTextString The JSON text to deserialize.\r\n *\r\n * @returns Returns a dataframe that has been deserialized from the JSON data.\r\n */\n\n\nfunction fromJSON(jsonTextString) {\n  if (!isString(jsonTextString)) throw new Error(\"Expected 'jsonTextString' parameter to 'dataForge.fromJSON' to be a string containing data encoded in the JSON format.\");\n  return new DataFrame({\n    values: JSON.parse(jsonTextString)\n  });\n}\n/**\r\n * Deserialize a dataframe from a JSON5 text string.\r\n *\r\n * @param jsonTextString The JSON5 text to deserialize.\r\n *\r\n * @returns Returns a dataframe that has been deserialized from the JSON data.\r\n */\n\n\nfunction fromJSON5(jsonTextString) {\n  if (!isString(jsonTextString)) throw new Error(\"Expected 'jsonTextString' parameter to 'dataForge.fromJSON5' to be a string containing data encoded in the JSON5 format.\");\n  return new DataFrame({\n    values: JSON5.parse(jsonTextString)\n  });\n}\n/**\r\n * Deserialize a DataFrame from a CSV text string.\r\n *\r\n * @param csvTextString The CSV text to deserialize.\r\n * @param config Optional configuration options for parsing the CSV data.\r\n * The config object is passed directly to [PapaParse.parse](https://www.papaparse.com/docs#strings), please see [PapaParse docs for additional options](https://www.papaparse.com/docs#config).\r\n *\r\n * @returns Returns a dataframe that has been deserialized from the CSV data.\r\n */\n\n\nfunction fromCSV(csvTextString, config) {\n  if (!isString(csvTextString)) throw new Error(\"Expected 'csvTextString' parameter to 'dataForge.fromCSV' to be a string containing data encoded in the CSV format.\");\n\n  if (config) {\n    if (!isObject(config)) throw new Error(\"Expected 'config' parameter to 'dataForge.fromCSV' to be an object with CSV parsing configuration options.\");\n\n    if (config.columnNames) {\n      if (!util_17(config.columnNames[Symbol.iterator])) {\n        if (!isArray(config.columnNames)) throw new Error(\"Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array or iterable of strings that specifies column names.\");\n      }\n\n      try {\n        for (var _a = __values(config.columnNames), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var columnName = _b.value;\n          if (!isString(columnName)) throw new Error(\"Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array of strings that specify column names.\");\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    if (config.skipEmptyLines === undefined) {\n      config = Object.assign({}, config); // Clone the config. Don't want to modify the original.\n\n      config.skipEmptyLines = true;\n    }\n  } else {\n    config = {\n      skipEmptyLines: true\n    };\n  }\n\n  var parsed = PapaParse.parse(csvTextString, config);\n  var rows = parsed.data;\n\n  if (rows.length === 0) {\n    return new DataFrame();\n  }\n\n  var columnNames;\n  rows = rows.map(function (row) {\n    return row.map(function (cell) {\n      return isString(cell) ? cell.trim() : cell;\n    }); // Trim each cell that is still a string.\n  });\n\n  if (config && config.columnNames) {\n    columnNames = config.columnNames;\n  } else {\n    columnNames = rows.shift();\n  }\n\n  return new DataFrame({\n    rows: rows,\n    columnNames: columnNames\n  });\n\n  var e_1, _c;\n}\n\nvar concat = Series.concat;\nvar zip = Series.zip;\n/**\r\n * Generate a series from a range of numbers.\r\n *\r\n * @param start - The value of the first number in the range.\r\n * @param count - The number of sequential values in the range.\r\n *\r\n * @returns Returns a series with a sequence of generated values. The series contains 'count' values beginning at 'start'.\r\n */\n\nfunction range(start, count) {\n  if (!isNumber(start)) throw new Error(\"Expect 'start' parameter to 'dataForge.range' function to be a number.\");\n  if (!isNumber(count)) throw new Error(\"Expect 'count' parameter to 'dataForge.range' function to be a number.\");\n  var values = [];\n\n  for (var valueIndex = 0; valueIndex < count; ++valueIndex) {\n    values.push(start + valueIndex);\n  }\n\n  return new Series(values);\n}\n/**\r\n * Replicate a particular value N times to create a series.\r\n *\r\n * @param value The value to replicate.\r\n * @param count The number of times to replicate the value.\r\n *\r\n * @returns Returns a new series that contains N copies of the value.\r\n */\n\n\nfunction replicate(value, count) {\n  var values = [];\n\n  for (var i = 0; i < count; ++i) {\n    values.push(value);\n  }\n\n  return new Series(values);\n}\n/**\r\n * Generate a data-frame containing a matrix of values.\r\n *\r\n * @param numColumns - The number of columns in the data-frame.\r\n * @param numRows - The number of rows in the data-frame.\r\n * @param start - The starting value.\r\n * @param increment - The value to increment by for each new value.\r\n *\r\n * @returns Returns a dataframe that contains a matrix of generated values.\r\n */\n\n\nfunction matrix(numColumns, numRows, start, increment) {\n  if (!isNumber(numColumns)) throw new Error(\"Expect 'numColumns' parameter to 'dataForge.matrix' function to be a number.\");\n  if (!isNumber(numRows)) throw new Error(\"Expect 'numRows' parameter to 'dataForge.matrix' function to be a number.\");\n  if (!isNumber(start)) throw new Error(\"Expect 'start' parameter to 'dataForge.matrix' function to be a number.\");\n  if (!isNumber(increment)) throw new Error(\"Expect 'increment' parameter to 'dataForge.matrix' function to be a number.\");\n  var rows = [];\n  var columnNames = [];\n  var nextValue = start;\n\n  for (var colIndex = 0; colIndex < numColumns; ++colIndex) {\n    columnNames.push((colIndex + 1).toString());\n  }\n\n  for (var rowIndex = 0; rowIndex < numRows; ++rowIndex) {\n    var row = [];\n\n    for (var colIndex = 0; colIndex < numColumns; ++colIndex) {\n      row.push(nextValue + colIndex * increment);\n    }\n\n    nextValue += numColumns * increment;\n    rows.push(row);\n  }\n\n  return new DataFrame({\n    columnNames: columnNames,\n    rows: rows\n  });\n}\n\nexport { DataFrame, Index, Series, concat as concatSeries, fromCSV, fromJSON, fromJSON5, fromObject, matrix, range, replicate, zip as zipSeries };"],"sourceRoot":""}